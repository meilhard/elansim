#line 1 "h:\\c_projekte\\elansim\\preferences.cpp"




#line 1 "h:\\c_projekte\\elansim\\preferences.h"







#line 1 "c:\\qt\\include\\qstring.h"










































#line 1 "c:\\qt\\include\\qcstring.h"










































#line 1 "c:\\qt\\include\\qarray.h"









































#line 1 "c:\\qt\\include\\qgarray.h"









































#line 1 "c:\\qt\\include\\qshared.h"









































#line 1 "c:\\qt\\include\\qglobal.h"











































































#line 77 "c:\\qt\\include\\qglobal.h"

#line 79 "c:\\qt\\include\\qglobal.h"





#line 85 "c:\\qt\\include\\qglobal.h"



















































#line 137 "c:\\qt\\include\\qglobal.h"











#line 149 "c:\\qt\\include\\qglobal.h"



























#line 177 "c:\\qt\\include\\qglobal.h"

#line 179 "c:\\qt\\include\\qglobal.h"


#line 182 "c:\\qt\\include\\qglobal.h"

























































































#line 272 "c:\\qt\\include\\qglobal.h"









#line 282 "c:\\qt\\include\\qglobal.h"




#line 287 "c:\\qt\\include\\qglobal.h"
















#line 304 "c:\\qt\\include\\qglobal.h"


#line 307 "c:\\qt\\include\\qglobal.h"


#line 310 "c:\\qt\\include\\qglobal.h"












#line 323 "c:\\qt\\include\\qglobal.h"




#line 328 "c:\\qt\\include\\qglobal.h"


















#line 347 "c:\\qt\\include\\qglobal.h"

#line 349 "c:\\qt\\include\\qglobal.h"



#line 353 "c:\\qt\\include\\qglobal.h"



#line 357 "c:\\qt\\include\\qglobal.h"








#line 366 "c:\\qt\\include\\qglobal.h"

typedef unsigned char	uchar;
typedef unsigned short	ushort;
typedef unsigned	uint;
typedef unsigned long	ulong;
typedef char	       *pchar;
typedef uchar	       *puchar;
typedef const char     *pcchar;







const bool FALSE = 0;
const bool TRUE = !0;
#line 384 "c:\\qt\\include\\qglobal.h"









#line 394 "c:\\qt\\include\\qglobal.h"











inline int qRound( double d )
{
    return d > 0.0 ? int(d+0.5) : int(d-0.5);
}









typedef signed char	INT8;			
typedef unsigned char	UINT8;			
typedef short		INT16;			
typedef unsigned short	UINT16;			
typedef int		INT32;			
typedef unsigned int	UINT32;			
#line 425 "c:\\qt\\include\\qglobal.h"

typedef signed char	Q_INT8;			
typedef unsigned char	Q_UINT8;		
typedef short		Q_INT16;		
typedef unsigned short	Q_UINT16;		
typedef int		Q_INT32;		
typedef unsigned int	Q_UINT32;		
typedef long		Q_INT64;		
typedef unsigned long	Q_UINT64;		





class QDataStream;




extern bool qt_winunicode;
#line 446 "c:\\qt\\include\\qglobal.h"


#line 1 "c:\\qt\\include\\qfeatures.h"



















































#line 53 "c:\\qt\\include\\qfeatures.h"
#line 1 "c:\\qt\\include\\qconfig.h"


#line 4 "c:\\qt\\include\\qconfig.h"






#line 54 "c:\\qt\\include\\qfeatures.h"
#line 55 "c:\\qt\\include\\qfeatures.h"













#line 69 "c:\\qt\\include\\qfeatures.h"







#line 77 "c:\\qt\\include\\qfeatures.h"






























#line 108 "c:\\qt\\include\\qfeatures.h"
























#line 133 "c:\\qt\\include\\qfeatures.h"







































#line 173 "c:\\qt\\include\\qfeatures.h"
















#line 190 "c:\\qt\\include\\qfeatures.h"





#line 196 "c:\\qt\\include\\qfeatures.h"








#line 205 "c:\\qt\\include\\qfeatures.h"












#line 218 "c:\\qt\\include\\qfeatures.h"






#line 225 "c:\\qt\\include\\qfeatures.h"






#line 232 "c:\\qt\\include\\qfeatures.h"





#line 238 "c:\\qt\\include\\qfeatures.h"






#line 245 "c:\\qt\\include\\qfeatures.h"






#line 252 "c:\\qt\\include\\qfeatures.h"












#line 265 "c:\\qt\\include\\qfeatures.h"















#line 281 "c:\\qt\\include\\qfeatures.h"





#line 287 "c:\\qt\\include\\qfeatures.h"









#line 297 "c:\\qt\\include\\qfeatures.h"














#line 312 "c:\\qt\\include\\qfeatures.h"






#line 319 "c:\\qt\\include\\qfeatures.h"











#line 331 "c:\\qt\\include\\qfeatures.h"




















                                        












#line 365 "c:\\qt\\include\\qfeatures.h"





















































#line 419 "c:\\qt\\include\\qfeatures.h"























#line 443 "c:\\qt\\include\\qfeatures.h"






#line 450 "c:\\qt\\include\\qfeatures.h"






#line 457 "c:\\qt\\include\\qfeatures.h"







#line 465 "c:\\qt\\include\\qfeatures.h"



















#line 485 "c:\\qt\\include\\qfeatures.h"






#line 492 "c:\\qt\\include\\qfeatures.h"




















#line 513 "c:\\qt\\include\\qfeatures.h"






#line 520 "c:\\qt\\include\\qfeatures.h"













#line 534 "c:\\qt\\include\\qfeatures.h"















































#line 582 "c:\\qt\\include\\qfeatures.h"





#line 588 "c:\\qt\\include\\qfeatures.h"





















#line 610 "c:\\qt\\include\\qfeatures.h"





#line 616 "c:\\qt\\include\\qfeatures.h"





#line 622 "c:\\qt\\include\\qfeatures.h"





#line 628 "c:\\qt\\include\\qfeatures.h"











#line 640 "c:\\qt\\include\\qfeatures.h"





#line 646 "c:\\qt\\include\\qfeatures.h"





#line 652 "c:\\qt\\include\\qfeatures.h"





#line 658 "c:\\qt\\include\\qfeatures.h"









#line 668 "c:\\qt\\include\\qfeatures.h"





#line 674 "c:\\qt\\include\\qfeatures.h"



























#line 702 "c:\\qt\\include\\qfeatures.h"







#line 710 "c:\\qt\\include\\qfeatures.h"









#line 720 "c:\\qt\\include\\qfeatures.h"






#line 727 "c:\\qt\\include\\qfeatures.h"





#line 733 "c:\\qt\\include\\qfeatures.h"


















#line 752 "c:\\qt\\include\\qfeatures.h"





#line 758 "c:\\qt\\include\\qfeatures.h"





#line 764 "c:\\qt\\include\\qfeatures.h"









#line 774 "c:\\qt\\include\\qfeatures.h"












#line 787 "c:\\qt\\include\\qfeatures.h"






#line 794 "c:\\qt\\include\\qfeatures.h"










#line 805 "c:\\qt\\include\\qfeatures.h"










#line 816 "c:\\qt\\include\\qfeatures.h"







#line 824 "c:\\qt\\include\\qfeatures.h"








































#line 865 "c:\\qt\\include\\qfeatures.h"






#line 872 "c:\\qt\\include\\qfeatures.h"






#line 879 "c:\\qt\\include\\qfeatures.h"






#line 886 "c:\\qt\\include\\qfeatures.h"










#line 897 "c:\\qt\\include\\qfeatures.h"





#line 903 "c:\\qt\\include\\qfeatures.h"






#line 910 "c:\\qt\\include\\qfeatures.h"





#line 916 "c:\\qt\\include\\qfeatures.h"





#line 922 "c:\\qt\\include\\qfeatures.h"






#line 929 "c:\\qt\\include\\qfeatures.h"






#line 936 "c:\\qt\\include\\qfeatures.h"






#line 943 "c:\\qt\\include\\qfeatures.h"






#line 950 "c:\\qt\\include\\qfeatures.h"






#line 957 "c:\\qt\\include\\qfeatures.h"





#line 963 "c:\\qt\\include\\qfeatures.h"






#line 970 "c:\\qt\\include\\qfeatures.h"

#line 972 "c:\\qt\\include\\qfeatures.h"
#line 449 "c:\\qt\\include\\qglobal.h"
#line 450 "c:\\qt\\include\\qglobal.h"









#line 460 "c:\\qt\\include\\qglobal.h"






#line 467 "c:\\qt\\include\\qglobal.h"
#line 468 "c:\\qt\\include\\qglobal.h"




#line 473 "c:\\qt\\include\\qglobal.h"



#line 477 "c:\\qt\\include\\qglobal.h"









__declspec(dllimport) const char *qVersion();
__declspec(dllimport) bool qSysInfo( int *wordSize, bool *bigEndian );











#line 500 "c:\\qt\\include\\qglobal.h"



#line 504 "c:\\qt\\include\\qglobal.h"









#line 514 "c:\\qt\\include\\qglobal.h"


#pragma warning(disable: 4244)
#pragma warning(disable: 4275)
#pragma warning(disable: 4514)
#pragma warning(disable: 4800)
#pragma warning(disable: 4097)
#pragma warning(disable: 4706)










#line 533 "c:\\qt\\include\\qglobal.h"
#line 534 "c:\\qt\\include\\qglobal.h"







#line 542 "c:\\qt\\include\\qglobal.h"








__declspec(dllimport) void qDebug( const char *, ... )	


#line 554 "c:\\qt\\include\\qglobal.h"
;

__declspec(dllimport) void qWarning( const char *, ... )	


#line 560 "c:\\qt\\include\\qglobal.h"
;

__declspec(dllimport) void qFatal( const char *, ... )	


#line 566 "c:\\qt\\include\\qglobal.h"
;







__declspec(dllimport) void debug( const char *, ... )	


#line 578 "c:\\qt\\include\\qglobal.h"
;

__declspec(dllimport) void warning( const char *, ... )	


#line 584 "c:\\qt\\include\\qglobal.h"
;

__declspec(dllimport) void fatal( const char *, ... )	


#line 590 "c:\\qt\\include\\qglobal.h"
;


#line 594 "c:\\qt\\include\\qglobal.h"






#line 601 "c:\\qt\\include\\qglobal.h"


#line 604 "c:\\qt\\include\\qglobal.h"


#line 607 "c:\\qt\\include\\qglobal.h"
#line 608 "c:\\qt\\include\\qglobal.h"

__declspec(dllimport) bool qt_check_pointer( bool c, const char *, int );





#line 616 "c:\\qt\\include\\qglobal.h"

enum QtMsgType { QtDebugMsg, QtWarningMsg, QtFatalMsg };

typedef void (*msg_handler)(QtMsgType, const char *);
__declspec(dllimport) msg_handler qInstallMsgHandler( msg_handler );


__declspec(dllimport) void qSuppressObsoleteWarnings( bool = TRUE );



__declspec(dllimport) void qObsolete( const char *obj, const char *oldfunc,
			 const char *newfunc );
__declspec(dllimport) void qObsolete( const char *obj, const char *oldfunc );
__declspec(dllimport) void qObsolete( const char *message );
#line 632 "c:\\qt\\include\\qglobal.h"

#line 634 "c:\\qt\\include\\qglobal.h"

#line 43 "c:\\qt\\include\\qshared.h"
#line 44 "c:\\qt\\include\\qshared.h"


struct QShared
{
    QShared()		{ count = 1; }
    void ref()		{ count++; }
    bool deref()	{ return !--count; }
    uint count;
};


#line 56 "c:\\qt\\include\\qshared.h"
#line 43 "c:\\qt\\include\\qgarray.h"
#line 44 "c:\\qt\\include\\qgarray.h"


class __declspec(dllimport) QGArray					
{
friend class QBuffer;
public:
    
    struct array_data : public QShared {	
	array_data()	{ data=0; len=0; }
	char *data;				
	uint  len;
    };
    QGArray();
protected:
    QGArray( int, int );			
    QGArray( int size );			
    QGArray( const QGArray &a );		
    virtual ~QGArray();

    QGArray    &operator=( const QGArray &a ) { return assign( a ); }

    virtual void detach()	{ duplicate(*this); }

    char       *data()	 const	{ return shd->data; }
    uint	nrefs()	 const	{ return shd->count; }
    uint	size()	 const	{ return shd->len; }
    bool	isEqual( const QGArray &a ) const;

    bool	resize( uint newsize );

    bool	fill( const char *d, int len, uint sz );

    QGArray    &assign( const QGArray &a );
    QGArray    &assign( const char *d, uint len );
    QGArray    &duplicate( const QGArray &a );
    QGArray    &duplicate( const char *d, uint len );
    void	store( const char *d, uint len );

    array_data *sharedBlock()	const		{ return shd; }
    void	setSharedBlock( array_data *p ) { shd=(array_data*)p; }

    QGArray    &setRawData( const char *d, uint len );
    void	resetRawData( const char *d, uint len );

    int		find( const char *d, uint index, uint sz ) const;
    int		contains( const char *d, uint sz ) const;
    
    void	sort( uint sz );
    int		bsearch( const char *d, uint sz ) const;

    char       *at( uint index ) const;

    bool	setExpand( uint index, const char *d, uint sz );

protected:
    virtual array_data *newData();
    virtual void deleteData( array_data *p );

private:
    static void msg_index( uint );
    array_data *shd;
};


inline char *QGArray::at( uint index ) const
{

    if ( index >= size() ) {
	msg_index( index );
	index = 0;
    }
#line 116 "c:\\qt\\include\\qgarray.h"
    return &shd->data[index];
}


#line 121 "c:\\qt\\include\\qgarray.h"
#line 43 "c:\\qt\\include\\qarray.h"
#line 44 "c:\\qt\\include\\qarray.h"


template<class type> class __declspec(dllimport) QArray : public QGArray
{
public:
    typedef type* Iterator;
    typedef const type* ConstIterator;
    typedef type ValueType;

protected:
    QArray( int, int ) : QGArray( 0, 0 ) {}

public:
    QArray() {}
    QArray( int size ) : QGArray(size*sizeof(type)) {}
    QArray( const QArray<type> &a ) : QGArray(a) {}
   ~QArray() {}
    QArray<type> &operator=(const QArray<type> &a)
				{ return (QArray<type>&)QGArray::assign(a); }
    type *data()    const	{ return (type *)QGArray::data(); }
    uint  nrefs()   const	{ return QGArray::nrefs(); }
    uint  size()    const	{ return QGArray::size()/sizeof(type); }
    uint  count()   const 	{ return size(); }
    bool  isEmpty() const	{ return QGArray::size() == 0; }
    bool  isNull()  const	{ return QGArray::data() == 0; }
    bool  resize( uint size )	{ return QGArray::resize(size*sizeof(type)); }
    bool  truncate( uint pos )	{ return QGArray::resize(pos*sizeof(type)); }
    bool  fill( const type &d, int size = -1 )
	{ return QGArray::fill((char*)&d,size,sizeof(type) ); }
    void  detach()		{ QGArray::detach(); }
    QArray<type>   copy() const
	{ QArray<type> tmp; return tmp.duplicate(*this); }
    QArray<type>& assign( const QArray<type>& a )
	{ return (QArray<type>&)QGArray::assign(a); }
    QArray<type>& assign( const type *a, uint n )
	{ return (QArray<type>&)QGArray::assign((char*)a,n*sizeof(type)); }
    QArray<type>& duplicate( const QArray<type>& a )
	{ return (QArray<type>&)QGArray::duplicate(a); }
    QArray<type>& duplicate( const type *a, uint n )
	{ return (QArray<type>&)QGArray::duplicate((char*)a,n*sizeof(type)); }
    QArray<type>& setRawData( const type *a, uint n )
	{ return (QArray<type>&)QGArray::setRawData((char*)a,
						     n*sizeof(type)); }
    void resetRawData( const type *a, uint n )
	{ QGArray::resetRawData((char*)a,n*sizeof(type)); }
    int	 find( const type &d, uint i=0 ) const
	{ return QGArray::find((char*)&d,i,sizeof(type)); }
    int	 contains( const type &d ) const
	{ return QGArray::contains((char*)&d,sizeof(type)); }
    void sort() { QGArray::sort(sizeof(type)); }
    int  bsearch( const type &d ) const
	{ return QGArray::bsearch((const char*)&d,sizeof(type)); }
    type& operator[]( int i ) const
	{ return (type &)(*(type *)QGArray::at(i*sizeof(type))); }
    type& at( uint i ) const
	{ return (type &)(*(type *)QGArray::at(i*sizeof(type))); }
	 operator const type*() const { return (const type *)QGArray::data(); }
    bool operator==( const QArray<type> &a ) const { return isEqual(a); }
    bool operator!=( const QArray<type> &a ) const { return !isEqual(a); }
    Iterator begin() { return data(); }
    Iterator end() { return data() + size(); }
    ConstIterator begin() const { return data(); }
    ConstIterator end() const { return data() + size(); }
};


#line 111 "c:\\qt\\include\\qarray.h"
#line 44 "c:\\qt\\include\\qcstring.h"
#line 45 "c:\\qt\\include\\qcstring.h"



#line 49 "c:\\qt\\include\\qcstring.h"

#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"















#pragma once
#line 18 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"






#line 25 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"



extern "C" {
#line 30 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"










#line 41 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"
#line 42 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"





#line 48 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"








#line 57 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"
#line 58 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"



typedef unsigned int size_t;

#line 64 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"




typedef unsigned short wchar_t;

#line 71 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"
#line 72 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"




#line 77 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"








#line 86 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"
#line 87 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"














        void *  __cdecl memcpy(void *, const void *, size_t);
        int     __cdecl memcmp(const void *, const void *, size_t);
        void *  __cdecl memset(void *, int, size_t);
        char *  __cdecl _strset(char *, int);
        char *  __cdecl strcpy(char *, const char *);
        char *  __cdecl strcat(char *, const char *);
        int     __cdecl strcmp(const char *, const char *);
        size_t  __cdecl strlen(const char *);
#line 110 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"
__declspec(dllimport) void *  __cdecl _memccpy(void *, const void *, int, unsigned int);
__declspec(dllimport) void *  __cdecl memchr(const void *, int, size_t);
__declspec(dllimport) int     __cdecl _memicmp(const void *, const void *, unsigned int);





__declspec(dllimport) void *  __cdecl memmove(void *, const void *, size_t);
#line 120 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"


__declspec(dllimport) char *  __cdecl strchr(const char *, int);
__declspec(dllimport) int     __cdecl _strcmpi(const char *, const char *);
__declspec(dllimport) int     __cdecl _stricmp(const char *, const char *);
__declspec(dllimport) int     __cdecl strcoll(const char *, const char *);
__declspec(dllimport) int     __cdecl _stricoll(const char *, const char *);
__declspec(dllimport) int     __cdecl _strncoll(const char *, const char *, size_t);
__declspec(dllimport) int     __cdecl _strnicoll(const char *, const char *, size_t);
__declspec(dllimport) size_t  __cdecl strcspn(const char *, const char *);
__declspec(dllimport) char *  __cdecl _strdup(const char *);
__declspec(dllimport) char *  __cdecl _strerror(const char *);
__declspec(dllimport) char *  __cdecl strerror(int);
__declspec(dllimport) char *  __cdecl _strlwr(char *);
__declspec(dllimport) char *  __cdecl strncat(char *, const char *, size_t);
__declspec(dllimport) int     __cdecl strncmp(const char *, const char *, size_t);
__declspec(dllimport) int     __cdecl _strnicmp(const char *, const char *, size_t);
__declspec(dllimport) char *  __cdecl strncpy(char *, const char *, size_t);
__declspec(dllimport) char *  __cdecl _strnset(char *, int, size_t);
__declspec(dllimport) char *  __cdecl strpbrk(const char *, const char *);
__declspec(dllimport) char *  __cdecl strrchr(const char *, int);
__declspec(dllimport) char *  __cdecl _strrev(char *);
__declspec(dllimport) size_t  __cdecl strspn(const char *, const char *);
__declspec(dllimport) char *  __cdecl strstr(const char *, const char *);
__declspec(dllimport) char *  __cdecl strtok(char *, const char *);
__declspec(dllimport) char *  __cdecl _strupr(char *);
__declspec(dllimport) size_t  __cdecl strxfrm (char *, const char *, size_t);














__declspec(dllimport) void * __cdecl memccpy(void *, const void *, int, unsigned int);
__declspec(dllimport) int __cdecl memicmp(const void *, const void *, unsigned int);
__declspec(dllimport) int __cdecl strcmpi(const char *, const char *);
__declspec(dllimport) int __cdecl stricmp(const char *, const char *);
__declspec(dllimport) char * __cdecl strdup(const char *);
__declspec(dllimport) char * __cdecl strlwr(char *);
__declspec(dllimport) int __cdecl strnicmp(const char *, const char *, size_t);
__declspec(dllimport) char * __cdecl strnset(char *, int, size_t);
__declspec(dllimport) char * __cdecl strrev(char *);
        char * __cdecl strset(char *, int);
__declspec(dllimport) char * __cdecl strupr(char *);

#line 174 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"







__declspec(dllimport) wchar_t * __cdecl wcscat(wchar_t *, const wchar_t *);
__declspec(dllimport) wchar_t * __cdecl wcschr(const wchar_t *, wchar_t);
__declspec(dllimport) int __cdecl wcscmp(const wchar_t *, const wchar_t *);
__declspec(dllimport) wchar_t * __cdecl wcscpy(wchar_t *, const wchar_t *);
__declspec(dllimport) size_t __cdecl wcscspn(const wchar_t *, const wchar_t *);
__declspec(dllimport) size_t __cdecl wcslen(const wchar_t *);
__declspec(dllimport) wchar_t * __cdecl wcsncat(wchar_t *, const wchar_t *, size_t);
__declspec(dllimport) int __cdecl wcsncmp(const wchar_t *, const wchar_t *, size_t);
__declspec(dllimport) wchar_t * __cdecl wcsncpy(wchar_t *, const wchar_t *, size_t);
__declspec(dllimport) wchar_t * __cdecl wcspbrk(const wchar_t *, const wchar_t *);
__declspec(dllimport) wchar_t * __cdecl wcsrchr(const wchar_t *, wchar_t);
__declspec(dllimport) size_t __cdecl wcsspn(const wchar_t *, const wchar_t *);
__declspec(dllimport) wchar_t * __cdecl wcsstr(const wchar_t *, const wchar_t *);
__declspec(dllimport) wchar_t * __cdecl wcstok(wchar_t *, const wchar_t *);

__declspec(dllimport) wchar_t * __cdecl _wcsdup(const wchar_t *);
__declspec(dllimport) int __cdecl _wcsicmp(const wchar_t *, const wchar_t *);
__declspec(dllimport) int __cdecl _wcsnicmp(const wchar_t *, const wchar_t *, size_t);
__declspec(dllimport) wchar_t * __cdecl _wcsnset(wchar_t *, wchar_t, size_t);
__declspec(dllimport) wchar_t * __cdecl _wcsrev(wchar_t *);
__declspec(dllimport) wchar_t * __cdecl _wcsset(wchar_t *, wchar_t);

__declspec(dllimport) wchar_t * __cdecl _wcslwr(wchar_t *);
__declspec(dllimport) wchar_t * __cdecl _wcsupr(wchar_t *);
__declspec(dllimport) size_t __cdecl wcsxfrm(wchar_t *, const wchar_t *, size_t);
__declspec(dllimport) int __cdecl wcscoll(const wchar_t *, const wchar_t *);
__declspec(dllimport) int __cdecl _wcsicoll(const wchar_t *, const wchar_t *);
__declspec(dllimport) int __cdecl _wcsncoll(const wchar_t *, const wchar_t *, size_t);
__declspec(dllimport) int __cdecl _wcsnicoll(const wchar_t *, const wchar_t *, size_t);







__declspec(dllimport) wchar_t * __cdecl wcsdup(const wchar_t *);
__declspec(dllimport) int __cdecl wcsicmp(const wchar_t *, const wchar_t *);
__declspec(dllimport) int __cdecl wcsnicmp(const wchar_t *, const wchar_t *, size_t);
__declspec(dllimport) wchar_t * __cdecl wcsnset(wchar_t *, wchar_t, size_t);
__declspec(dllimport) wchar_t * __cdecl wcsrev(wchar_t *);
__declspec(dllimport) wchar_t * __cdecl wcsset(wchar_t *, wchar_t);
__declspec(dllimport) wchar_t * __cdecl wcslwr(wchar_t *);
__declspec(dllimport) wchar_t * __cdecl wcsupr(wchar_t *);
__declspec(dllimport) int __cdecl wcsicoll(const wchar_t *, const wchar_t *);

#line 228 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"


#line 231 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"

#line 233 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"


}
#line 237 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"

#line 239 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"
#line 51 "c:\\qt\\include\\qcstring.h"




















#line 72 "c:\\qt\\include\\qcstring.h"






__declspec(dllimport) void *qmemmove( void *dst, const void *src, uint len );



#line 83 "c:\\qt\\include\\qcstring.h"

__declspec(dllimport) char *qstrdup( const char * );

__declspec(dllimport) inline uint cstrlen( const char *str )
{ return strlen(str); }

__declspec(dllimport) inline uint qstrlen( const char *str )
{ return str ? strlen(str) : 0; }

__declspec(dllimport) inline char *cstrcpy( char *dst, const char *src )
{ return strcpy(dst,src); }

__declspec(dllimport) inline char *qstrcpy( char *dst, const char *src )
{ return src ? strcpy(dst, src) : 0; }

__declspec(dllimport) char *qstrncpy( char *dst, const char *src, uint len );

__declspec(dllimport) inline int cstrcmp( const char *str1, const char *str2 )
{ return strcmp(str1,str2); }

__declspec(dllimport) inline int qstrcmp( const char *str1, const char *str2 )
{ return (str1 && str2) ? strcmp(str1,str2) : (int)((long)str2 - (long)str1); }

__declspec(dllimport) inline int cstrncmp( const char *str1, const char *str2, uint len )
{ return strncmp(str1,str2,len); }

__declspec(dllimport) inline int qstrncmp( const char *str1, const char *str2, uint len )
{ return (str1 && str2) ? strncmp(str1,str2,len) :
			  (int)((long)str2 - (long)str1); }

__declspec(dllimport) int qstricmp( const char *, const char * );

__declspec(dllimport) int qstrnicmp( const char *, const char *, uint len );


























#line 143 "c:\\qt\\include\\qcstring.h"




__declspec(dllimport) Q_UINT16 qChecksum( const char *s, uint len );






template class __declspec(dllimport) QArray<char>;
#line 156 "c:\\qt\\include\\qcstring.h"
typedef QArray<char> QByteArray;






__declspec(dllimport) QDataStream &operator<<( QDataStream &, const QByteArray & );
__declspec(dllimport) QDataStream &operator>>( QDataStream &, QByteArray & );
#line 166 "c:\\qt\\include\\qcstring.h"







class QRegExp;

class __declspec(dllimport) QCString : public QByteArray	
{
public:
    QCString() {}				
    QCString( int size );			
    QCString( const QCString &s ) : QByteArray( s ) {}
    QCString( const char *str );		
    QCString( const char *str, uint maxlen );	

    QCString    &operator=( const QCString &s );
    QCString    &operator=( const char *str );	

    bool	isNull()	const;
    bool	isEmpty()	const;
    uint	length()	const;
    bool	resize( uint newlen );
    bool	truncate( uint pos );
    bool	fill( char c, int len = -1 );

    QCString	copy()	const;

    QCString    &sprintf( const char *format, ... );

    int		find( char c, int index=0, bool cs=TRUE ) const;
    int		find( const char *str, int index=0, bool cs=TRUE ) const;
    int		find( const QRegExp &, int index=0 ) const;
    int		findRev( char c, int index=-1, bool cs=TRUE) const;
    int		findRev( const char *str, int index=-1, bool cs=TRUE) const;
    int		findRev( const QRegExp &, int index=-1 ) const;
    int		contains( char c, bool cs=TRUE ) const;
    int		contains( const char *str, bool cs=TRUE ) const;
    int		contains( const QRegExp & ) const;

    QCString	left( uint len )  const;
    QCString	right( uint len ) const;
    QCString	mid( uint index, uint len=0xffffffff) const;

    QCString	leftJustify( uint width, char fill=' ', bool trunc=FALSE)const;
    QCString	rightJustify( uint width, char fill=' ',bool trunc=FALSE)const;

    QCString	lower() const;
    QCString	upper() const;

    QCString	stripWhiteSpace()	const;
    QCString	simplifyWhiteSpace()	const;

    QCString    &insert( uint index, const char * );
    QCString    &insert( uint index, char );
    QCString    &append( const char * );
    QCString    &prepend( const char * );
    QCString    &remove( uint index, uint len );
    QCString    &replace( uint index, uint len, const char * );
    QCString    &replace( const QRegExp &, const char * );

    short	toShort( bool *ok=0 )	const;
    ushort	toUShort( bool *ok=0 )	const;
    int		toInt( bool *ok=0 )	const;
    uint	toUInt( bool *ok=0 )	const;
    long	toLong( bool *ok=0 )	const;
    ulong	toULong( bool *ok=0 )	const;
    float	toFloat( bool *ok=0 )	const;
    double	toDouble( bool *ok=0 )	const;

    QCString    &setStr( const char *s );
    QCString    &setNum( short );
    QCString    &setNum( ushort );
    QCString    &setNum( int );
    QCString    &setNum( uint );
    QCString    &setNum( long );
    QCString    &setNum( ulong );
    QCString    &setNum( float, char f='g', int prec=6 );
    QCString    &setNum( double, char f='g', int prec=6 );

    bool	setExpand( uint index, char c );

		operator const char *() const;
    QCString    &operator+=( const char *str );
    QCString    &operator+=( char c );
};






__declspec(dllimport) QDataStream &operator<<( QDataStream &, const QCString & );
__declspec(dllimport) QDataStream &operator>>( QDataStream &, QCString & );
#line 263 "c:\\qt\\include\\qcstring.h"





inline QCString &QCString::operator=( const QCString &s )
{ return (QCString&)assign( s ); }

inline QCString &QCString::operator=( const char *str )
{ return (QCString&)duplicate( str, qstrlen(str)+1 ); }

inline bool QCString::isNull() const
{ return data() == 0; }

inline bool QCString::isEmpty() const
{ return data() == 0 || *data() == '\0'; }

inline uint QCString::length() const
{ return qstrlen( data() ); }

inline bool QCString::truncate( uint pos )
{ return resize(pos+1); }

inline QCString QCString::copy() const
{ return QCString( data() ); }

inline QCString &QCString::prepend( const char *s )
{ return insert(0,s); }

inline QCString &QCString::append( const char *s )
{ return operator+=(s); }

inline QCString &QCString::setNum( short n )
{ return setNum((long)n); }

inline QCString &QCString::setNum( ushort n )
{ return setNum((ulong)n); }

inline QCString &QCString::setNum( int n )
{ return setNum((long)n); }

inline QCString &QCString::setNum( uint n )
{ return setNum((ulong)n); }

inline QCString &QCString::setNum( float n, char f, int prec )
{ return setNum((double)n,f,prec); }

inline QCString::operator const char *() const
{ return (const char *)data(); }






__declspec(dllimport) inline bool operator==( const QCString &s1, const QCString &s2 )
{ return qstrcmp(s1.data(),s2.data()) == 0; }

__declspec(dllimport) inline bool operator==( const QCString &s1, const char *s2 )
{ return qstrcmp(s1.data(),s2) == 0; }

__declspec(dllimport) inline bool operator==( const char *s1, const QCString &s2 )
{ return qstrcmp(s1,s2.data()) == 0; }

__declspec(dllimport) inline bool operator!=( const QCString &s1, const QCString &s2 )
{ return qstrcmp(s1.data(),s2.data()) != 0; }

__declspec(dllimport) inline bool operator!=( const QCString &s1, const char *s2 )
{ return qstrcmp(s1.data(),s2) != 0; }

__declspec(dllimport) inline bool operator!=( const char *s1, const QCString &s2 )
{ return qstrcmp(s1,s2.data()) != 0; }

__declspec(dllimport) inline bool operator<( const QCString &s1, const QCString& s2 )
{ return qstrcmp(s1.data(),s2.data()) < 0; }

__declspec(dllimport) inline bool operator<( const QCString &s1, const char *s2 )
{ return qstrcmp(s1.data(),s2) < 0; }

__declspec(dllimport) inline bool operator<( const char *s1, const QCString &s2 )
{ return qstrcmp(s1,s2.data()) < 0; }

__declspec(dllimport) inline bool operator<=( const QCString &s1, const char *s2 )
{ return qstrcmp(s1.data(),s2) <= 0; }

__declspec(dllimport) inline bool operator<=( const char *s1, const QCString &s2 )
{ return qstrcmp(s1,s2.data()) <= 0; }

__declspec(dllimport) inline bool operator>( const QCString &s1, const char *s2 )
{ return qstrcmp(s1.data(),s2) > 0; }

__declspec(dllimport) inline bool operator>( const char *s1, const QCString &s2 )
{ return qstrcmp(s1,s2.data()) > 0; }

__declspec(dllimport) inline bool operator>=( const QCString &s1, const char *s2 )
{ return qstrcmp(s1.data(),s2) >= 0; }

__declspec(dllimport) inline bool operator>=( const char *s1, const QCString &s2 )
{ return qstrcmp(s1,s2.data()) >= 0; }

__declspec(dllimport) inline QCString operator+( const QCString &s1, const QCString &s2 )
{
    QCString tmp( s1.data() );
    tmp += s2;
    return tmp;
}

__declspec(dllimport) inline QCString operator+( const QCString &s1, const char *s2 )
{
    QCString tmp( s1.data() );
    tmp += s2;
    return tmp;
}

__declspec(dllimport) inline QCString operator+( const char *s1, const QCString &s2 )
{
    QCString tmp( s1 );
    tmp += s2;
    return tmp;
}

__declspec(dllimport) inline QCString operator+( const QCString &s1, char c2 )
{
    QCString tmp( s1.data() );
    tmp += c2;
    return tmp;
}

__declspec(dllimport) inline QCString operator+( char c1, const QCString &s2 )
{
    QCString tmp;
    tmp += c1;
    tmp += s2;
    return tmp;
}

#line 400 "c:\\qt\\include\\qcstring.h"
#line 44 "c:\\qt\\include\\qstring.h"
#line 45 "c:\\qt\\include\\qstring.h"






class QRegExp;
class QString;
class QCharRef;

class __declspec(dllimport) QChar {
public:
    QChar();
    QChar( char c );
    QChar( uchar c );
    QChar( uchar c, uchar r );
    QChar( const QChar& c );
    QChar( ushort rc );
    QChar( short rc );
    QChar( uint rc );
    QChar( int rc );

    static QChar null;            
    static QChar replacement;     
    static QChar byteOrderMark;     
    static QChar byteOrderSwapped;     
    static QChar nbsp;            

    

    enum Category
    {
	NoCategory,

	Mark_NonSpacing,	  
	Mark_SpacingCombining,	  
	Mark_Enclosing,		  

	Number_DecimalDigit,	  
	Number_Letter,		  
	Number_Other,		  

	Separator_Space,	  
	Separator_Line,		  
	Separator_Paragraph,	  

	Other_Control,		  
	Other_Format,		  
	Other_Surrogate,	  
	Other_PrivateUse,	  
	Other_NotAssigned,	  

	Letter_Uppercase,	  
	Letter_Lowercase,	  
	Letter_Titlecase,	  
	Letter_Modifier,	  
	Letter_Other,		  

	Punctuation_Connector,	  
	Punctuation_Dask,	  
	Punctuation_Open,	  
	Punctuation_Close,	  
	Punctuation_InitialQuote, 
	Punctuation_FinalQuote,	  
	Punctuation_Other,	  

	Symbol_Math,		  
	Symbol_Currency,	  
	Symbol_Modifier,	  
	Symbol_Other		  
    };

    enum Direction
    {
	DirL, DirR, DirEN, DirES, DirET, DirAN, DirCS, DirB, DirS, DirWS, DirON,
	DirLRE, DirLRO, DirAL, DirRLE, DirRLO, DirPDF, DirNSM, DirBN
    };

    enum Decomposition
    {
        Single, Canonical, Font, NoBreak, Initial, Medial,
        Final, Isolated, Circle, Super, Sub, Vertical,
        Wide, Narrow, Small, Square, Compat, Fraction
    };

    enum Joining
    {
	OtherJoining, Dual, Right, Center
    };

    

    int digitValue() const;
    QChar lower() const;
    QChar upper() const;

    Category category() const;
    Direction direction() const;
    Joining joining() const;
    bool mirrored() const;
    QChar mirroredChar() const;
    QString decomposition() const;
    Decomposition decompositionTag() const;

    char latin1() const { return rw ? 0 : cl; }
    ushort unicode() const { return (rw << 8) | cl; }

    
    operator char() const { return latin1(); }
#line 155 "c:\\qt\\include\\qstring.h"

    bool isNull() const { return unicode()==0; }
    bool isPrint() const;
    bool isPunct() const;
    bool isSpace() const;
    bool isMark() const;
    bool isLetter() const;
    bool isNumber() const;
    bool isLetterOrNumber() const;
    bool isDigit() const;

    uchar& cell() { return cl; }
    uchar& row() { return rw; }
    uchar cell() const { return cl; }
    uchar row() const { return rw; }

    static bool networkOrdered() { return (int)net_ordered == 1; }

    friend inline int operator==( char ch, QChar c );
    friend inline int operator==( QChar c, char ch );
    friend inline int operator==( QChar c1, QChar c2 );
    friend inline int operator!=( QChar c1, QChar c2 );
    friend inline int operator!=( char ch, QChar c );
    friend inline int operator!=( QChar c, char ch );
    friend inline int operator<=( QChar c, char ch );
    friend inline int operator<=( char ch, QChar c );
    friend inline int operator<=( QChar c1, QChar c2 );

private:









#line 194 "c:\\qt\\include\\qstring.h"
    
    uchar cl;
    uchar rw;


#line 200 "c:\\qt\\include\\qstring.h"
    enum { net_ordered = 0 };
#line 202 "c:\\qt\\include\\qstring.h"
} ;

inline QChar::QChar()
{
    rw = 0; cl = 0;



}
inline QChar::QChar( char c )
{
    rw = 0; cl = (uchar)c;



}
inline QChar::QChar( uchar c )
{
    rw = 0; cl = c;



}
inline QChar::QChar( uchar c, uchar r )
{
    rw = r; cl = c;



}
inline QChar::QChar( const QChar& c )
{
    rw = c.rw; cl = c.cl;



}
inline QChar::QChar( ushort rc )
{
    rw = (uchar)((rc>>8)&0xff); cl = (uchar)(rc&0xff);



}
inline QChar::QChar( short rc )
{
    rw = (uchar)((rc>>8)&0xff); cl = (uchar)(rc&0xff);



}
inline QChar::QChar( uint rc )
{
    rw = (uchar)((rc>>8)&0xff); cl = (uchar)(rc&0xff);



}
inline QChar::QChar( int rc )
{
    rw = (uchar)((rc>>8)&0xff); cl = (uchar)(rc&0xff);



}


inline int operator==( char ch, QChar c )
{
    return ch == c.cl && !c.rw;
}

inline int operator==( QChar c, char ch )
{
    return ch == c.cl && !c.rw;
}

inline int operator==( QChar c1, QChar c2 )
{
    return c1.cl == c2.cl
	&& c1.rw == c2.rw;
}

inline int operator!=( QChar c1, QChar c2 )
{
    return c1.cl != c2.cl
	|| c1.rw != c2.rw;
}

inline int operator!=( char ch, QChar c )
{
    return ch != c.cl || c.rw;
}

inline int operator!=( QChar c, char ch )
{
    return ch != c.cl || c.rw;
}

inline int operator<=( QChar c, char ch )
{
    return !(ch < c.cl || c.rw);
}

inline int operator<=( char ch, QChar c )
{
    return ch <= c.cl || c.rw;
}

inline int operator<=( QChar c1, QChar c2 )
{
    return c1.rw > c2.rw
	? FALSE
	: c1.rw < c2.rw
	    ? TRUE
	    : c1.cl <= c2.cl;
}

inline int operator>=( QChar c, char ch ) { return ch <= c; }
inline int operator>=( char ch, QChar c ) { return c <= ch; }
inline int operator>=( QChar c1, QChar c2 ) { return c2 <= c1; }
inline int operator<( QChar c, char ch ) { return !(ch<=c); }
inline int operator<( char ch, QChar c ) { return !(c<=ch); }
inline int operator<( QChar c1, QChar c2 ) { return !(c2<=c1); }
inline int operator>( QChar c, char ch ) { return !(ch>=c); }
inline int operator>( char ch, QChar c ) { return !(c>=ch); }
inline int operator>( QChar c1, QChar c2 ) { return !(c2>=c1); }


struct __declspec(dllimport) QStringData : public QShared {
    QStringData() :
	unicode(0), ascii(0), len(0), maxl(0), dirtyascii(0) { ref(); }
    QStringData(QChar *u, uint l, uint m) :
	unicode(u), ascii(0), len(l), maxl(m), dirtyascii(0) { }

    ~QStringData() { if ( unicode ) delete[] ((char*)unicode);
                     if ( ascii ) delete[] ascii; }

    void deleteSelf();
    QChar *unicode;
    char *ascii;
    uint len;
    uint maxl:30;
    uint dirtyascii:1;
};


class __declspec(dllimport) QString
{
public:
    QString();					
    QString( QChar );				
    QString( const QString & );			
    QString( const QByteArray& );		
    QString( const QChar* unicode, uint length ); 

    QString( const char *str );			
#line 360 "c:\\qt\\include\\qstring.h"
    ~QString();

    QString    &operator=( const QString & );	

    QString    &operator=( const char * );	
#line 366 "c:\\qt\\include\\qstring.h"
    QString    &operator=( const QCString& );	
    QString    &operator=( QChar c );
    QString    &operator=( char c );

    static QString null;

    bool	isNull()	const;
    bool	isEmpty()	const;
    uint	length()	const;
    void	truncate( uint pos );



#line 380 "c:\\qt\\include\\qstring.h"
    void	fill( QChar c, int len = -1 );

    QString	copy()	const;

    QString arg(long a, int fieldwidth=0, int base=10) const;
    QString arg(ulong a, int fieldwidth=0, int base=10) const;
    QString arg(int a, int fieldwidth=0, int base=10) const;
    QString arg(uint a, int fieldwidth=0, int base=10) const;
    QString arg(short a, int fieldwidth=0, int base=10) const;
    QString arg(ushort a, int fieldwidth=0, int base=10) const;
    QString arg(char a, int fieldwidth=0) const;
    QString arg(QChar a, int fieldwidth=0) const;
    QString arg(const QString& a, int fieldwidth=0) const;
    QString arg(double a, int fieldwidth=0, char fmt='g', int prec=-1) const;

    QString    &sprintf( const char* format, ... )


#line 399 "c:\\qt\\include\\qstring.h"
	;

    int		find( QChar c, int index=0, bool cs=TRUE ) const;
    int		find( char c, int index=0, bool cs=TRUE ) const;
    int		find( const QString &str, int index=0, bool cs=TRUE ) const;
    int		find( const QRegExp &, int index=0 ) const;

    int		find( const char* str, int index=0 ) const;
#line 408 "c:\\qt\\include\\qstring.h"
    int		findRev( QChar c, int index=-1, bool cs=TRUE) const;
    int		findRev( char c, int index=-1, bool cs=TRUE) const;
    int		findRev( const QString &str, int index=-1, bool cs=TRUE) const;
    int		findRev( const QRegExp &, int index=-1 ) const;

    int		findRev( const char* str, int index=-1 ) const;
#line 415 "c:\\qt\\include\\qstring.h"
    int		contains( QChar c, bool cs=TRUE ) const;
    int		contains( char c, bool cs=TRUE ) const
		    { return contains(QChar(c), cs); }

    int		contains( const char* str, bool cs=TRUE ) const;
#line 421 "c:\\qt\\include\\qstring.h"
    int		contains( const QString &str, bool cs=TRUE ) const;
    int		contains( const QRegExp & ) const;

    QString	left( uint len )  const;
    QString	right( uint len ) const;
    QString	mid( uint index, uint len=0xffffffff) const;

    QString	leftJustify( uint width, QChar fill=' ', bool trunc=FALSE)const;
    QString	rightJustify( uint width, QChar fill=' ',bool trunc=FALSE)const;

    QString	lower() const;
    QString	upper() const;

    QString	stripWhiteSpace()	const;
    QString	simplifyWhiteSpace()	const;

    QString    &insert( uint index, const QString & );
    QString    &insert( uint index, const QChar*, uint len );
    QString    &insert( uint index, QChar );
    QString    &insert( uint index, char c ) { return insert(index,QChar(c)); }
    QString    &append( char );
    QString    &append( QChar );
    QString    &append( const QString & );
    QString    &prepend( char );
    QString    &prepend( QChar );
    QString    &prepend( const QString & );
    QString    &remove( uint index, uint len );
    QString    &replace( uint index, uint len, const QString & );
    QString    &replace( uint index, uint len, const QChar*, uint clen );
    QString    &replace( const QRegExp &, const QString & );

    short	toShort( bool *ok=0, int base=10 )	const;
    ushort	toUShort( bool *ok=0, int base=10 )	const;
    int		toInt( bool *ok=0, int base=10 )	const;
    uint	toUInt( bool *ok=0, int base=10 )	const;
    long	toLong( bool *ok=0, int base=10 )	const;
    ulong	toULong( bool *ok=0, int base=10 )	const;
    float	toFloat( bool *ok=0 )	const;
    double	toDouble( bool *ok=0 )	const;

    QString    &setNum( short, int base=10 );
    QString    &setNum( ushort, int base=10 );
    QString    &setNum( int, int base=10 );
    QString    &setNum( uint, int base=10 );
    QString    &setNum( long, int base=10 );
    QString    &setNum( ulong, int base=10 );
    QString    &setNum( float, char f='g', int prec=6 );
    QString    &setNum( double, char f='g', int prec=6 );

    static QString number( long, int base=10 );
    static QString number( ulong, int base=10);
    static QString number( int, int base=10 );
    static QString number( uint, int base=10);
    static QString number( double, char f='g', int prec=6 );

    void	setExpand( uint index, QChar c );

    QString    &operator+=( const QString &str );
    QString    &operator+=( QChar c );
    QString    &operator+=( char c );

    
    QChar at( uint i ) const
	{ return i<d->len ? d->unicode[i] : QChar::null; }
    QChar operator[]( int i ) const { return at((uint)i); }
    QCharRef at( uint i );
    QCharRef operator[]( int i );

    QChar constref(uint i) const
	{ return at(i); }
    QChar& ref(uint i)
	{ 
	    if (d->count!=1 || i>=d->len)
		subat(i);
	    d->dirtyascii=1;
	    return d->unicode[i];
	}

    const QChar* unicode() const { return d->unicode; }
    const char* ascii() const;
    const char* latin1() const;
    static QString fromLatin1(const char*, int len=-1);

    QCString utf8() const;
    static QString fromUtf8(const char*, int len=-1);
#line 507 "c:\\qt\\include\\qstring.h"
    QCString local8Bit() const;
    static QString fromLocal8Bit(const char*, int len=-1);
    bool operator!() const;

    operator const char *() const { return latin1(); }
#line 513 "c:\\qt\\include\\qstring.h"

    QString &setUnicode( const QChar* unicode, uint len );
    QString &setUnicodeCodes( const ushort* unicode_as_ushorts, uint len );
    QString &setLatin1( const char*, int len=-1 );

    int compare( const QString& s ) const;
    static int compare( const QString& s1, const QString& s2 )
	{ return s1.compare(s2); }


    friend __declspec(dllimport) QDataStream &operator>>( QDataStream &, QString & );
#line 525 "c:\\qt\\include\\qstring.h"
    
    void compose();
    QChar::Direction basicDirection();
    QString visual(int index = 0, int len = -1);


    const char* data() const { return latin1(); }
#line 533 "c:\\qt\\include\\qstring.h"

    bool startsWith( const QString& ) const;

private:
    QString( int size, bool dummy );		

    void deref();
    void real_detach();
    void setLength( uint pos );
    void subat( uint );
    bool findArg(int& pos, int& len) const;

    static QChar* asciiToUnicode( const char*, uint * len, uint maxlen=(uint)-1 );
    static QChar* asciiToUnicode( const QByteArray&, uint * len );
    static char* unicodeToAscii( const QChar*, uint len );

    QStringData *d;
    static QStringData* shared_null;
    static QStringData* makeSharedNull();

    friend class QConstString;
    QString(QStringData* dd, bool ) : d(dd) { }
};

class __declspec(dllimport) QCharRef {
    friend class QString;
    QString& s;
    uint p;
    QCharRef(QString* str, uint pos) : s(*str), p(pos) { }

public:
    

    

    ushort unicode() const { return s.constref(p).unicode(); }
    char latin1() const { return s.constref(p).latin1(); }

    
    QCharRef operator=(char c ) { s.ref(p)=c; return *this; }
    QCharRef operator=(uchar c ) { s.ref(p)=c; return *this; }
    QCharRef operator=(QChar c ) { s.ref(p)=c; return *this; }
    QCharRef operator=(const QCharRef& c ) { s.ref(p)=c.unicode(); return *this; }
    QCharRef operator=(ushort rc ) { s.ref(p)=rc; return *this; }
    QCharRef operator=(short rc ) { s.ref(p)=rc; return *this; }
    QCharRef operator=(uint rc ) { s.ref(p)=rc; return *this; }
    QCharRef operator=(int rc ) { s.ref(p)=rc; return *this; }

    operator QChar () const { return s.constref(p); }

    
    bool isNull() const { return unicode()==0; }
    bool isPrint() const { return s.constref(p).isPrint(); }
    bool isPunct() const { return s.constref(p).isPunct(); }
    bool isSpace() const { return s.constref(p).isSpace(); }
    bool isMark() const { return s.constref(p).isMark(); }
    bool isLetter() const { return s.constref(p).isLetter(); }
    bool isNumber() const { return s.constref(p).isNumber(); }
    bool isLetterOrNumber() { return s.constref(p).isLetterOrNumber(); }
    bool isDigit() const { return s.constref(p).isDigit(); }

    int digitValue() const { return s.constref(p).digitValue(); }
    QChar lower() { return s.constref(p).lower(); }
    QChar upper() { return s.constref(p).upper(); }

    QChar::Category category() const { return s.constref(p).category(); }
    QChar::Direction direction() const { return s.constref(p).direction(); }
    QChar::Joining joining() const { return s.constref(p).joining(); }
    bool mirrored() const { return s.constref(p).mirrored(); }
    QChar mirroredChar() const { return s.constref(p).mirroredChar(); }
    QString decomposition() const { return s.constref(p).decomposition(); }
    QChar::Decomposition decompositionTag() const { return s.constref(p).decompositionTag(); }

    
    uchar cell() const { return s.constref(p).cell(); }
    uchar row() const { return s.constref(p).row(); }
#line 610 "c:\\qt\\include\\qstring.h"
};

inline QCharRef QString::at( uint i ) { return QCharRef(this,i); }
inline QCharRef QString::operator[]( int i ) { return at((uint)i); }


class __declspec(dllimport) QConstString : private QString {
public:
    QConstString( QChar* unicode, uint length );
    ~QConstString();
    const QString& string() const { return *this; }
};






__declspec(dllimport) QDataStream &operator<<( QDataStream &, const QString & );
__declspec(dllimport) QDataStream &operator>>( QDataStream &, QString & );
#line 631 "c:\\qt\\include\\qstring.h"










inline QString::QString() :
    d(shared_null ? shared_null : makeSharedNull())
{
    d->ref();
}

inline QString::~QString()
{
    if ( d->deref() ) {
	if ( d == shared_null )
	    shared_null = 0;
	d->deleteSelf();
    }
}

inline QString &QString::operator=( QChar c )
{ return *this = QString(c); }

inline QString &QString::operator=( char c )
{ return *this = QString(QChar(c)); }

inline bool QString::isNull() const
{ return unicode() == 0; }

inline bool QString::operator!() const
{ return isNull(); }

inline uint QString::length() const
{ return d->len; }

inline bool QString::isEmpty() const
{ return length() == 0; }

inline QString QString::copy() const
{ return QString( *this ); }

inline QString &QString::prepend( const QString & s )
{ return insert(0,s); }

inline QString &QString::prepend( QChar c )
{ return insert(0,c); }

inline QString &QString::prepend( char c )
{ return insert(0,c); }

inline QString &QString::append( const QString & s )
{ return operator+=(s); }

inline QString &QString::append( QChar c )
{ return operator+=(c); }

inline QString &QString::append( char c )
{ return operator+=(c); }

inline QString &QString::setNum( short n, int base )
{ return setNum((long)n, base); }

inline QString &QString::setNum( ushort n, int base )
{ return setNum((ulong)n, base); }

inline QString &QString::setNum( int n, int base )
{ return setNum((long)n, base); }

inline QString &QString::setNum( uint n, int base )
{ return setNum((ulong)n, base); }

inline QString &QString::setNum( float n, char f, int prec )
{ return setNum((double)n,f,prec); }

inline QString QString::arg(int a, int fieldwidth, int base) const
{ return arg((long)a, fieldwidth, base); }

inline QString QString::arg(uint a, int fieldwidth, int base) const
{ return arg((ulong)a, fieldwidth, base); }

inline QString QString::arg(short a, int fieldwidth, int base) const
{ return arg((long)a, fieldwidth, base); }

inline QString QString::arg(ushort a, int fieldwidth, int base) const
{ return arg((ulong)a, fieldwidth, base); }

inline int QString::find( char c, int index, bool cs ) const
{ return find(QChar(c), index, cs); }

inline int QString::findRev( char c, int index, bool cs) const
{ return findRev( QChar(c), index, cs ); }



inline int QString::find( const char* str, int index ) const
{ return find(QString::fromLatin1(str), index); }

inline int QString::findRev( const char* str, int index ) const
{ return findRev(QString::fromLatin1(str), index); }
#line 736 "c:\\qt\\include\\qstring.h"






__declspec(dllimport) bool operator!=( const QString &s1, const QString &s2 );
__declspec(dllimport) bool operator<( const QString &s1, const QString &s2 );
__declspec(dllimport) bool operator<=( const QString &s1, const QString &s2 );
__declspec(dllimport) bool operator==( const QString &s1, const QString &s2 );
__declspec(dllimport) bool operator>( const QString &s1, const QString &s2 );
__declspec(dllimport) bool operator>=( const QString &s1, const QString &s2 );

__declspec(dllimport) bool operator!=( const QString &s1, const char *s2 );
__declspec(dllimport) bool operator<( const QString &s1, const char *s2 );
__declspec(dllimport) bool operator<=( const QString &s1, const char *s2 );
__declspec(dllimport) bool operator==( const QString &s1, const char *s2 );
__declspec(dllimport) bool operator>( const QString &s1, const char *s2 );
__declspec(dllimport) bool operator>=( const QString &s1, const char *s2 );
__declspec(dllimport) bool operator!=( const char *s1, const QString &s2 );
__declspec(dllimport) bool operator<( const char *s1, const QString &s2 );
__declspec(dllimport) bool operator<=( const char *s1, const QString &s2 );
__declspec(dllimport) bool operator==( const char *s1, const QString &s2 );

__declspec(dllimport) bool operator>=( const char *s1, const QString &s2 );
#line 762 "c:\\qt\\include\\qstring.h"

__declspec(dllimport) inline QString operator+( const QString &s1, const QString &s2 )
{
    QString tmp( s1 );
    tmp += s2;
    return tmp;
}


__declspec(dllimport) inline QString operator+( const QString &s1, const char *s2 )
{
    QString tmp( s1 );
    tmp += QString::fromLatin1(s2);
    return tmp;
}

__declspec(dllimport) inline QString operator+( const char *s1, const QString &s2 )
{
    QString tmp = QString::fromLatin1( s1 );
    tmp += s2;
    return tmp;
}
#line 785 "c:\\qt\\include\\qstring.h"

__declspec(dllimport) inline QString operator+( const QString &s1, QChar c2 )
{
    QString tmp( s1 );
    tmp += c2;
    return tmp;
}

__declspec(dllimport) inline QString operator+( const QString &s1, char c2 )
{
    QString tmp( s1 );
    tmp += c2;
    return tmp;
}

__declspec(dllimport) inline QString operator+( QChar c1, const QString &s2 )
{
    QString tmp;
    tmp += c1;
    tmp += s2;
    return tmp;
}

__declspec(dllimport) inline QString operator+( char c1, const QString &s2 )
{
    QString tmp;
    tmp += c1;
    tmp += s2;
    return tmp;
}


extern __declspec(dllimport) QString qt_winQString(void*);
extern __declspec(dllimport) const void* qt_winTchar(const QString& str, bool addnul);
extern __declspec(dllimport) void* qt_winTchar_new(const QString& str);
extern __declspec(dllimport) QCString qt_winQString2MB( const QString& s, int len=-1 );
extern __declspec(dllimport) QString qt_winMB2QString( const char* mb, int len=-1 );
#line 823 "c:\\qt\\include\\qstring.h"

#line 825 "c:\\qt\\include\\qstring.h"
#line 9 "h:\\c_projekte\\elansim\\preferences.h"
#line 1 "c:\\qt\\include\\qstringlist.h"









































#line 1 "c:\\qt\\include\\qvaluelist.h"









































#line 1 "c:\\qt\\include\\qshared.h"























































#line 43 "c:\\qt\\include\\qvaluelist.h"
#line 1 "c:\\qt\\include\\qdatastream.h"









































#line 1 "c:\\qt\\include\\qiodevice.h"









































#line 1 "c:\\qt\\include\\qglobal.h"


























































































































































































































































































































































































































































































































































































































































#line 43 "c:\\qt\\include\\qiodevice.h"
#line 1 "c:\\qt\\include\\qcstring.h"















































































































































































































































































































































































































#line 44 "c:\\qt\\include\\qiodevice.h"
#line 45 "c:\\qt\\include\\qiodevice.h"











































class __declspec(dllimport) QIODevice					
{
public:
    QIODevice();
    virtual ~QIODevice();

    int		 flags()  const { return ioMode; }
    int		 mode()	  const { return ioMode & 0x00ff; }
    int		 state()  const { return ioMode & 0xf000; }

    bool	 isDirectAccess()     const { return ((ioMode & 0x0100)     == 0x0100); }
    bool	 isSequentialAccess() const { return ((ioMode & 0x0200) == 0x0200); }
    bool	 isCombinedAccess()   const { return ((ioMode & 0x0300)   == 0x0300); }
    bool	 isBuffered()	      const { return ((ioMode & 0x0040)        != 0x0040); }
    bool	 isRaw()	      const { return ((ioMode & 0x0040)        == 0x0040); }
    bool	 isSynchronous()      const { return ((ioMode & 0x0080)      != 0x0080); }
    bool	 isAsynchronous()     const { return ((ioMode & 0x0080)      == 0x0080); }
    bool	 isTranslated()	      const { return ((ioMode & 0x0010)  == 0x0010); }
    bool	 isReadable()	      const { return ((ioMode & 0x0001)   == 0x0001); }
    bool	 isWritable()	      const { return ((ioMode & 0x0002)  == 0x0002); }
    bool	 isReadWrite()	      const { return ((ioMode & 0x0003)  == 0x0003); }
    bool	 isInactive()	      const { return state() == 0; }
    bool	 isOpen()	      const { return state() == 0x1000; }

    int		 status() const { return ioSt; }
    void	 resetStatus()	{ ioSt = 0; }

    virtual bool open( int mode ) = 0;
    virtual void close() = 0;
    virtual void flush() = 0;

    virtual uint size()	  const = 0;
    virtual int	 at()	  const;
    virtual bool at( int );
    virtual bool atEnd()  const;
    bool	 reset() { return at(0); }

    virtual int	 readBlock( char *data, uint maxlen ) = 0;
    virtual int	 writeBlock( const char *data, uint len ) = 0;
    virtual int	 readLine( char *data, uint maxlen );
    int writeBlock( const QByteArray& data );
    QByteArray readAll();

    virtual int	 getch() = 0;
    virtual int	 putch( int ) = 0;
    virtual int	 ungetch( int ) = 0;

protected:
    void	 setFlags( int f ) { ioMode = f; }
    void	 setType( int );
    void	 setMode( int );
    void	 setState( int );
    void	 setStatus( int );
    int		 ioIndex;

private:
    int		 ioMode;
    int		 ioSt;

private:	



#line 152 "c:\\qt\\include\\qiodevice.h"
};


#line 156 "c:\\qt\\include\\qiodevice.h"
#line 43 "c:\\qt\\include\\qdatastream.h"
#line 1 "c:\\qt\\include\\qstring.h"
























































































































































































































































































































































































































































































































































































































































































































































































































































#line 44 "c:\\qt\\include\\qdatastream.h"
#line 45 "c:\\qt\\include\\qdatastream.h"


class __declspec(dllimport) QDataStream				
{
public:
    QDataStream();
    QDataStream( QIODevice * );
    QDataStream( QByteArray, int mode );
    virtual ~QDataStream();

    QIODevice	*device() const;
    void	 setDevice( QIODevice * );
    void	 unsetDevice();

    bool	 atEnd() const;
    bool	 eof() const;

    enum ByteOrder { BigEndian, LittleEndian };
    int		 byteOrder()	const;
    void	 setByteOrder( int );

    bool	 isPrintableData() const;
    void	 setPrintableData( bool );

    int		 version() const;
    void	 setVersion( int );

    QDataStream &operator>>( Q_INT8 &i );
    QDataStream &operator>>( Q_UINT8 &i );
    QDataStream &operator>>( Q_INT16 &i );
    QDataStream &operator>>( Q_UINT16 &i );
    QDataStream &operator>>( Q_INT32 &i );
    QDataStream &operator>>( Q_UINT32 &i );
    QDataStream &operator>>( Q_INT64 &i );
    QDataStream &operator>>( Q_UINT64 &i );

    QDataStream &operator>>( float &f );
    QDataStream &operator>>( double &f );
    QDataStream &operator>>( char *&str );

    QDataStream &operator<<( Q_INT8 i );
    QDataStream &operator<<( Q_UINT8 i );
    QDataStream &operator<<( Q_INT16 i );
    QDataStream &operator<<( Q_UINT16 i );
    QDataStream &operator<<( Q_INT32 i );
    QDataStream &operator<<( Q_UINT32 i );
    QDataStream &operator<<( Q_INT64 i );
    QDataStream &operator<<( Q_UINT64 i );
    QDataStream &operator<<( float f );
    QDataStream &operator<<( double f );
    QDataStream &operator<<( const char *str );

    QDataStream &readBytes( char *&, uint &len );
    QDataStream &readRawBytes( char *, uint len );

    QDataStream &writeBytes( const char *, uint len );
    QDataStream &writeRawBytes( const char *, uint len );

private:
    QIODevice	*dev;
    bool	 owndev;
    int		 byteorder;
    bool	 printable;
    bool	 noswap;
    int		 ver;

private:	



#line 116 "c:\\qt\\include\\qdatastream.h"
};






inline QIODevice *QDataStream::device() const
{ return dev; }

inline bool QDataStream::atEnd() const
{ return dev ? dev->atEnd() : TRUE; }

inline bool QDataStream::eof() const
{ return atEnd(); }

inline int QDataStream::byteOrder() const
{ return byteorder; }

inline bool QDataStream::isPrintableData() const
{ return printable; }

inline void QDataStream::setPrintableData( bool p )
{ printable = p; }

inline int QDataStream::version() const
{ return ver; }

inline void QDataStream::setVersion( int v )
{ ver = v; }

inline QDataStream &QDataStream::operator>>( Q_UINT8 &i )
{ return *this >> (Q_INT8&)i; }

inline QDataStream &QDataStream::operator>>( Q_UINT16 &i )
{ return *this >> (Q_INT16&)i; }

inline QDataStream &QDataStream::operator>>( Q_UINT32 &i )
{ return *this >> (Q_INT32&)i; }

inline QDataStream &QDataStream::operator>>( Q_UINT64 &i )
{ return *this >> (Q_INT64&)i; }

inline QDataStream &QDataStream::operator<<( Q_UINT8 i )
{ return *this << (Q_INT8)i; }

inline QDataStream &QDataStream::operator<<( Q_UINT16 i )
{ return *this << (Q_INT16)i; }

inline QDataStream &QDataStream::operator<<( Q_UINT32 i )
{ return *this << (Q_INT32)i; }

inline QDataStream &QDataStream::operator<<( Q_UINT64 i )
{ return *this << (Q_INT64)i; }


#line 173 "c:\\qt\\include\\qdatastream.h"
#line 174 "c:\\qt\\include\\qdatastream.h"
#line 44 "c:\\qt\\include\\qvaluelist.h"
#line 45 "c:\\qt\\include\\qvaluelist.h"


#pragma warning(disable:4284) 
#line 49 "c:\\qt\\include\\qvaluelist.h"

template <class T>
class __declspec(dllimport) QValueListNode
{
public:
    QValueListNode( const T& t ) : data( t ) { }
    QValueListNode() { }

    
    virtual ~QValueListNode() { }
#line 60 "c:\\qt\\include\\qvaluelist.h"

    QValueListNode<T>* next;
    QValueListNode<T>* prev;
    T data;
};

template<class T>
class __declspec(dllimport) QValueListIterator
{
 public:
    


    typedef QValueListNode<T>* NodePtr;

    


    NodePtr node;

    


    QValueListIterator() : node( 0 ) {}
    QValueListIterator( NodePtr p ) : node( p ) {}
    QValueListIterator( const QValueListIterator<T>& it ) : node( it.node ) {}

    bool operator==( const QValueListIterator<T>& it ) const { return node == it.node; }
    bool operator!=( const QValueListIterator<T>& it ) const { return node != it.node; }
    const T& operator*() const { return node->data; }
    T& operator*() { return node->data; }

    
    

    QValueListIterator<T>& operator++() {
	node = node->next;
	return *this;
    }

    QValueListIterator<T> operator++(int) {
	QValueListIterator<T> tmp = *this;
	node = node->next;
	return tmp;
    }

    QValueListIterator<T>& operator--() {
	node = node->prev;
	return *this;
    }

    QValueListIterator<T> operator--(int) {
	QValueListIterator<T> tmp = *this;
	node = node->prev;
	return tmp;
    }
};

template<class T>
class __declspec(dllimport) QValueListConstIterator
{
 public:
    


    typedef QValueListNode<T>* NodePtr;

    


    NodePtr node;

    


    QValueListConstIterator() : node( 0 ) {}
    QValueListConstIterator( NodePtr p ) : node( p ) {}
    QValueListConstIterator( const QValueListConstIterator<T>& it ) : node( it.node ) {}
    QValueListConstIterator( const QValueListIterator<T>& it ) : node( it.node ) {}

    bool operator==( const QValueListConstIterator<T>& it ) const { return node == it.node; }
    bool operator!=( const QValueListConstIterator<T>& it ) const { return node != it.node; }
    const T& operator*() const { return node->data; }

    
    

    QValueListConstIterator<T>& operator++() {
	node = node->next;
	return *this;
    }

    QValueListConstIterator<T> operator++(int) {
	QValueListConstIterator<T> tmp = *this;
	node = node->next;
	return tmp;
    }

    QValueListConstIterator<T>& operator--() {
	node = node->prev;
	return *this;
    }

    QValueListConstIterator<T> operator--(int) {
	QValueListConstIterator<T> tmp = *this;
	node = node->prev;
	return tmp;
    }
};

template <class T>
class __declspec(dllimport) QValueListPrivate : public QShared
{
public:
    


    typedef QValueListIterator<T> Iterator;
    typedef QValueListConstIterator<T> ConstIterator;
    typedef QValueListNode<T> Node;
    typedef QValueListNode<T>* NodePtr;

    


    QValueListPrivate() { node = new Node; node->next = node->prev = node; nodes = 0; }
    QValueListPrivate( const QValueListPrivate<T>& _p ) : QShared() {
	node = new Node; node->next = node->prev = node; nodes = 0;
	Iterator b( _p.node->next );
	Iterator e( _p.node );
	Iterator i( node );
	while( b != e )
	    insert( i, *b++ );
    }

    void derefAndDelete() 
    {
	if ( deref() )
	    delete this;
    }


    
    virtual
#line 205 "c:\\qt\\include\\qvaluelist.h"
    ~QValueListPrivate() {
	NodePtr p = node->next;
	while( p != node ) {
	    NodePtr x = p->next;
	    delete p;
	    p = x;
	}
	delete node;
    }

    Iterator insert( Iterator it, const T& x ) {
	NodePtr p = new Node( x );
	p->next = it.node;
	p->prev = it.node->prev;
	it.node->prev->next = p;
	it.node->prev = p;
	nodes++;
	return p;
    }

    Iterator remove( Iterator it ) {
	if ( !(it.node != node) ) qWarning("ASSERT: \"%s\" in %s (%d)","it.node != node","c:\\qt\\include\\qvaluelist.h",226);
	NodePtr next = it.node->next;
	NodePtr prev = it.node->prev;
	prev->next = next;
	next->prev = prev;
	delete it.node;
	nodes--;
	return Iterator( next );
    }

    NodePtr find( NodePtr start, const T& x ) const {
	ConstIterator first( start );
	ConstIterator last( node );
	while( first != last) {
	    if ( *first == x )
		return first.node;
	    ++first;
	}
	return last.node;
    }

    int findIndex( NodePtr start, const T& x ) const {
	ConstIterator first( start );
	ConstIterator last( node );
	int pos = 0;
	while( first != last) {
	    if ( *first == x )
		return pos;
	    ++first;
	    ++pos;
	}
	return -1;
    }

    uint contains( const T& x ) const {
	uint result = 0;
	Iterator first = Iterator( node->next );
	Iterator last = Iterator( node );
	while( first != last) {
	    if ( *first == x )
		++result;
	    ++first;
	}
	return result;
    }

    void remove( const T& x ) {
	Iterator first = Iterator( node->next );
	Iterator last = Iterator( node );
	while( first != last) {
	    if ( *first == x )
		first = remove( first );
	    else
		++first;
	}
    }

    NodePtr at( uint i ) const {
	if ( !(i <= nodes) ) qWarning("ASSERT: \"%s\" in %s (%d)","i <= nodes","c:\\qt\\include\\qvaluelist.h",284);
	NodePtr p = node->next;
	for( uint x = 0; x < i; ++x )
	    p = p->next;
	return p;
    }

    void clear() {
	nodes = 0;
	NodePtr p = node->next;
	while( p != node ) {
	    NodePtr next = p->next;
	    delete p;
	    p = next;
	}
	node->next = node->prev = node;
    }

    NodePtr node;
    uint nodes;
};

template <class T>
class __declspec(dllimport) QValueList
{
public:
    


    typedef QValueListIterator<T> Iterator;
    typedef QValueListConstIterator<T> ConstIterator;
    typedef T ValueType;

    


    QValueList() { sh = new QValueListPrivate<T>; }
    QValueList( const QValueList<T>& l ) { sh = l.sh; sh->ref(); }
    ~QValueList() { sh->derefAndDelete(); }

    QValueList<T>& operator= ( const QValueList<T>& l )
    {
	l.sh->ref();
	sh->derefAndDelete();
	sh = l.sh;
	return *this;
    }

    QValueList<T> operator+ ( const QValueList<T>& l ) const
    {
	QValueList<T> l2( *this );
	for( ConstIterator it = l.begin(); it != l.end(); ++it )
	    l2.append( *it );
	return l2;
    }

    QValueList<T>& operator+= ( const QValueList<T>& l )
    {
	for( ConstIterator it = l.begin(); it != l.end(); ++it )
	    append( *it );
	return *this;
    }

    bool operator== ( const QValueList<T>& l ) const
    {
	if ( count() != l.count() )
	    return FALSE;
	ConstIterator it2 = begin();
	ConstIterator it = l.begin();
	for( ; it != l.end(); ++it, ++it2 )
	    if ( !( *it == *it2 ) )
		return FALSE;
	return TRUE;
    }

    bool operator!= ( const QValueList<T>& l ) const { return !( *this == l ); }

    Iterator begin() { detach(); return Iterator( sh->node->next ); }
    ConstIterator begin() const { return ConstIterator( sh->node->next ); }
    Iterator end() { detach(); return Iterator( sh->node ); }
    ConstIterator end() const { return ConstIterator( sh->node ); }
    Iterator fromLast() { detach(); return Iterator( sh->node->prev ); }
    ConstIterator fromLast() const { return ConstIterator( sh->node->prev ); }

    bool isEmpty() const { return ( sh->nodes == 0 ); }

    Iterator insert( Iterator it, const T& x ) { detach(); return sh->insert( it, x ); }

    Iterator append( const T& x ) { detach(); return sh->insert( end(), x ); }
    Iterator prepend( const T& x ) { detach(); return sh->insert( begin(), x ); }

    Iterator remove( Iterator it ) { detach(); return sh->remove( it ); }
    void remove( const T& x ) { detach(); sh->remove( x ); }

    T& first() { detach(); return sh->node->next->data; }
    const T& first() const { return sh->node->next->data; }
    T& last() { detach(); return sh->node->prev->data; }
    const T& last() const { return sh->node->prev->data; }

    T& operator[] ( uint i ) { detach(); return sh->at(i)->data; }
    const T& operator[] ( uint i ) const { return sh->at(i)->data; }
    Iterator at( uint i ) { detach(); return Iterator( sh->at(i) ); }
    ConstIterator at( uint i ) const { return ConstIterator( sh->at(i) ); }
    Iterator find ( const T& x ) { detach(); return Iterator( sh->find( sh->node->next, x) ); }
    ConstIterator find ( const T& x ) const { return ConstIterator( sh->find( sh->node->next, x) ); }
    Iterator find ( Iterator it, const T& x ) { detach(); return Iterator( sh->find( it.node, x ) ); }
    ConstIterator find ( ConstIterator it, const T& x ) const { return ConstIterator( sh->find( it.node, x ) ); }
    int findIndex( const T& x ) const { return sh->findIndex( sh->node->next, x) ; }
    uint contains( const T& x ) const { return sh->contains( x ); }

    uint count() const { return sh->nodes; }

    void clear() { if ( sh->count == 1 ) sh->clear(); else { sh->deref(); sh = new QValueListPrivate<T>; } }


    QValueList<T>& operator+= ( const T& x )
    {
	append( x );
	return *this;
    }
    QValueList<T>& operator<< ( const T& x )
    {
	append( x );
	return *this;
    }


protected:
    


    void detach() { if ( sh->count > 1 ) { sh->deref(); sh = new QValueListPrivate<T>( *sh ); } }

    


    QValueListPrivate<T>* sh;
};


template<class T>
inline QDataStream& operator>>( QDataStream& s, QValueList<T>& l )
{
    l.clear();
    Q_UINT32 c;
    s >> c;
    for( Q_UINT32 i = 0; i < c; ++i )
    {
	T t;
	s >> t;
	l.append( t );
    }
    return s;
}

template<class T>
inline QDataStream& operator<<( QDataStream& s, const QValueList<T>& l )
{
    s << (Q_UINT32)l.count();
    QValueListConstIterator<T> it = l.begin();
    for( ; it != l.end(); ++it )
	s << *it;
    return s;
}
#line 449 "c:\\qt\\include\\qvaluelist.h"
#line 450 "c:\\qt\\include\\qvaluelist.h"
#line 43 "c:\\qt\\include\\qstringlist.h"
#line 1 "c:\\qt\\include\\qstring.h"
























































































































































































































































































































































































































































































































































































































































































































































































































































#line 44 "c:\\qt\\include\\qstringlist.h"
#line 1 "c:\\qt\\include\\qregexp.h"









































#line 1 "c:\\qt\\include\\qstring.h"
























































































































































































































































































































































































































































































































































































































































































































































































































































#line 43 "c:\\qt\\include\\qregexp.h"
#line 44 "c:\\qt\\include\\qregexp.h"


class __declspec(dllimport) QRegExp
{
public:
    QRegExp();
    QRegExp( const QString &, bool caseSensitive=TRUE, bool wildcard=FALSE );
    QRegExp( const QRegExp & );
   ~QRegExp();
    QRegExp    &operator=( const QRegExp & );
    QRegExp    &operator=( const QString &pattern );

    bool	operator==( const QRegExp & )  const;
    bool	operator!=( const QRegExp &r ) const
					{ return !(this->operator==(r)); }

    bool	isEmpty()	const	{ return rxdata == 0; }
    bool	isValid()	const	{ return error == 0; }

    bool	caseSensitive() const	{ return cs; }
    void	setCaseSensitive( bool );

    bool	wildcard()	const	{ return wc; }
    void	setWildcard( bool );

    QString	pattern()	const	{ return rxstring; }
    
    void	setPattern( const QString& pattern )
					{ operator=( pattern ); }

    int		match( const QString &str, int index=0, int *len=0,
		       bool indexIsStart = TRUE ) const;
    int		find( const QString& str, int index )
					{ return match( str, index ); }

protected:
    void	compile();
    const QChar *matchstr( uint *, const QChar *, uint, const QChar * ) const;

private:
    QString	rxstring;			
    uint	*rxdata;			
    int		error;				
    bool	cs;				
    bool	wc;				
};


#line 93 "c:\\qt\\include\\qregexp.h"
#line 45 "c:\\qt\\include\\qstringlist.h"
#line 46 "c:\\qt\\include\\qstringlist.h"



class QStrList;

class __declspec(dllimport) QStringList : public QValueList<QString>
{
public:
    QStringList() { }
    QStringList( const QStringList& l ) : QValueList<QString>(l) { }
    QStringList( const QValueList<QString>& l ) : QValueList<QString>(l) { }
    QStringList( const QString& i ) { append(i); }

    QStringList( const char* i ) { append(i); }
#line 61 "c:\\qt\\include\\qstringlist.h"

    static QStringList fromStrList(const QStrList&);

    void sort();

    static QStringList split( const QString &sep, const QString &str, bool allowEmptyEntries = FALSE );
    static QStringList split(  const QChar &sep, const QString &str, bool allowEmptyEntries = FALSE );
    static QStringList split(  const QRegExp &sep, const QString &str, bool allowEmptyEntries = FALSE );
    QString join( const QString &sep ) const;

    QStringList grep( const QString &str, bool cs = TRUE ) const;
    QStringList grep( const QRegExp &expr ) const;
};


class QDataStream;
extern __declspec(dllimport) QDataStream &operator>>( QDataStream &, QStringList& );
extern __declspec(dllimport) QDataStream &operator<<( QDataStream &, const QStringList& );
#line 80 "c:\\qt\\include\\qstringlist.h"
#line 81 "c:\\qt\\include\\qstringlist.h"
#line 82 "c:\\qt\\include\\qstringlist.h"
#line 10 "h:\\c_projekte\\elansim\\preferences.h"
#line 1 "c:\\qt\\include\\qmap.h"









































#line 1 "c:\\qt\\include\\qshared.h"























































#line 43 "c:\\qt\\include\\qmap.h"
#line 1 "c:\\qt\\include\\qdatastream.h"













































































































































































#line 44 "c:\\qt\\include\\qmap.h"
#line 45 "c:\\qt\\include\\qmap.h"


struct QMapNodeBase
{
    enum Color { Red, Black };

    QMapNodeBase* left;
    QMapNodeBase* right;
    QMapNodeBase* parent;

    Color color;

    QMapNodeBase* minimum() {
	QMapNodeBase* x = this;
	while ( x->left )
	    x = x->left;
	return x;
    }

    QMapNodeBase* maximum() {
	QMapNodeBase* x = this;
	while ( x->right )
	    x = x->right;
	return x;
    }
};


template <class K, class T>
struct QMapNode : public QMapNodeBase
{
    QMapNode( const K& _key, const T& _data ) { data = _data; key = _key; }
    QMapNode( const K& _key )	   { key = _key; }
    QMapNode( const QMapNode<K,T>& _n ) { key = _n.key; data = _n.data; }
    QMapNode() { }
    T data;
    K key;
};


template<class K, class T>
class __declspec(dllimport) QMapIterator
{
 public:
    


    typedef QMapNode< K, T >* NodePtr;

    


    QMapNode<K,T>* node;

    


    QMapIterator() : node( 0 ) {}
    QMapIterator( QMapNode<K,T>* p ) : node( p ) {}
    QMapIterator( const QMapIterator<K,T>& it ) : node( it.node ) {}

    bool operator==( const QMapIterator<K,T>& it ) const { return node == it.node; }
    bool operator!=( const QMapIterator<K,T>& it ) const { return node != it.node; }
    T& operator*() { return node->data; }
    const T& operator*() const { return node->data; }

    
    

    const K& key() const { return node->key; }
    T& data() { return node->data; }
    const T& data() const { return node->data; }

private:
    int inc() {
	QMapNodeBase* tmp = node;
	if ( tmp->right ) {
	    tmp = tmp->right;
	    while ( tmp->left )
		tmp = tmp->left;
	} else {
	    QMapNodeBase* y = tmp->parent;
	    while (tmp == y->right) {
		tmp = y;
		y = y->parent;
	    }
	    if (tmp->right != y)
		tmp = y;
	}
	node = (NodePtr)tmp;
	return 0;
    }

    int dec() {
	QMapNodeBase* tmp = node;
	if (tmp->color == QMapNodeBase::Red &&
	    tmp->parent->parent == tmp ) {
	    tmp = tmp->right;
	} else if (tmp->left != 0) {
	    QMapNodeBase* y = tmp->left;
	    while ( y->right )
		y = y->right;
	    tmp = y;
	} else {
	    QMapNodeBase* y = tmp->parent;
	    while (tmp == y->left) {
		tmp = y;
		y = y->parent;
	    }
	    tmp = y;
	}
	node = (NodePtr)tmp;
	return 0;
    }

public:
    QMapIterator<K,T>& operator++() {
	inc();
	return *this;
    }

    QMapIterator<K,T> operator++(int) {
	QMapIterator<K,T> tmp = *this;
	inc();
	return tmp;
    }

    QMapIterator<K,T>& operator--() {
	dec();
	return *this;
    }

    QMapIterator<K,T> operator--(int) {
	QMapIterator<K,T> tmp = *this;
	dec();
	return tmp;
    }
};

template<class K, class T>
class __declspec(dllimport) QMapConstIterator
{
 public:
    


    typedef QMapNode< K, T >* NodePtr;

    


    QMapNode<K,T>* node;

    


    QMapConstIterator() : node( 0 ) {}
    QMapConstIterator( QMapNode<K,T>* p ) : node( p ) {}
    QMapConstIterator( const QMapConstIterator<K,T>& it ) : node( it.node ) {}
    QMapConstIterator( const QMapIterator<K,T>& it ) : node( it.node ) {}

    bool operator==( const QMapConstIterator<K,T>& it ) const { return node == it.node; }
    bool operator!=( const QMapConstIterator<K,T>& it ) const { return node != it.node; }
    const T& operator*()  const { return node->data; }

    
    

    const K& key() const { return node->key; }
    const T& data() const { return node->data; }

private:
    int inc() {
        QMapNodeBase* tmp = node;
	if ( tmp->right ) {
	    tmp = tmp->right;
	    while ( tmp->left )
		tmp = tmp->left;
	} else {
	    QMapNodeBase* y = tmp->parent;
	    while (tmp == y->right) {
		tmp = y;
		y = y->parent;
	    }
	    if (tmp->right != y)
		tmp = y;
	}
	node = (NodePtr)tmp;
	return 0;
    }

    int dec() {
	QMapNodeBase* tmp = node;
	if (tmp->color == QMapNodeBase::Red &&
	    tmp->parent->parent == tmp ) {
	    tmp = tmp->right;
	} else if (tmp->left != 0) {
	    QMapNodeBase* y = tmp->left;
	    while ( y->right )
		y = y->right;
	    tmp = y;
	} else {
	    QMapNodeBase* y = tmp->parent;
	    while (tmp == y->left) {
		tmp = y;
		y = y->parent;
	    }
	    tmp = y;
	}
	node = (NodePtr)tmp;
	return 0;
    }

public:
    QMapConstIterator<K,T>& operator++() {
	inc();
	return *this;
    }

    QMapConstIterator<K,T> operator++(int) {
	QMapConstIterator<K,T> tmp = *this;
	inc();
	return tmp;
    }

    QMapConstIterator<K,T>& operator--() {
	dec();
	return *this;
    }

    QMapConstIterator<K,T> operator--(int) {
	QMapConstIterator<K,T> tmp = *this;
	dec();
	return tmp;
    }
};


class __declspec(dllimport) QMapPrivateBase : public QShared
{
public:
    QMapPrivateBase() {
	node_count = 0;
    }
    QMapPrivateBase( const QMapPrivateBase* _map) {
	node_count = _map->node_count;
    }

    


    void rotateLeft( QMapNodeBase* x, QMapNodeBase*& root);
    void rotateRight( QMapNodeBase* x, QMapNodeBase*& root );
    void rebalance( QMapNodeBase* x, QMapNodeBase*& root );
    QMapNodeBase* removeAndRebalance( QMapNodeBase* z, QMapNodeBase*& root,
				      QMapNodeBase*& leftmost,
				      QMapNodeBase*& rightmost );

    


    int node_count;
};


template <class Key, class T>
class QMapPrivate : public QMapPrivateBase
{
public:
    


    typedef QMapIterator< Key, T > Iterator;
    typedef QMapConstIterator< Key, T > ConstIterator;
    typedef QMapNode< Key, T > Node;
    typedef QMapNode< Key, T >* NodePtr;

    


    QMapPrivate() {
	header = new Node;
	header->color = QMapNodeBase::Red; 
	header->parent = 0;
	header->left = header->right = header;
    }
    QMapPrivate( const QMapPrivate< Key, T >* _map ) : QMapPrivateBase( _map ) {
	header = new Node;
	header->color = QMapNodeBase::Red; 
	if ( _map->header->parent == 0 ) {
	    header->parent = 0;
	    header->left = header->right = header;
	} else {
	    header->parent = copy( (NodePtr)(_map->header->parent) );
	    header->parent->parent = header;
	    header->left = header->parent->minimum();
	    header->right = header->parent->maximum();
	}
    }
    ~QMapPrivate() { clear(); delete header; }

    NodePtr copy( NodePtr p ) {
	if ( !p )
	    return 0;
	NodePtr n = new Node( *p );
	n->color = p->color;
	if ( p->left ) {
	    n->left = copy( (NodePtr)(p->left) );
	    n->left->parent = n;
	} else {
	    n->left = 0;
	}
	if ( p->right ) {
	    n->right = copy( (NodePtr)(p->right) );
	    n->right->parent = n;
	} else {
	    n->right = 0;
	}
	return n;
    }

    void clear() {
	clear( (NodePtr)(header->parent) );
	header->color = QMapNodeBase::Red;
	header->parent = 0;
	header->left = header->right = header;
	node_count = 0;
    }

    void clear( NodePtr p ) {
	while ( p != 0 ) {
	    clear( (NodePtr)p->right );
	    NodePtr y = (NodePtr)p->left;
	    delete p;
	    p = y;
	}
    }

    Iterator begin()	{ return Iterator( (NodePtr)(header->left ) ); }
    Iterator end()	{ return Iterator( header ); }
    ConstIterator begin() const { return ConstIterator( (NodePtr)(header->left ) ); }
    ConstIterator end() const { return ConstIterator( header ); }

    ConstIterator find(const Key& k) const {
	QMapNodeBase* y = header;        
	QMapNodeBase* x = header->parent; 

	while ( x != 0 ) {
	    
	    if ( !( key(x) < k ) ) {
		y = x;
		x = x->left;
	    } else {
		x = x->right;
	    }
	}

	
	
	if ( y == header || k < key(y) )
	    return ConstIterator( header );
	return ConstIterator( (NodePtr)y );
    }

    void remove( Iterator it ) {
	NodePtr del = (NodePtr) removeAndRebalance( it.node, header->parent, header->left, header->right );
	delete del;
	--node_count;
    }













    Iterator insertMulti(const Key& v){
	QMapNodeBase* y = header;
	QMapNodeBase* x = header->parent;
	while (x != 0){
	    y = x;
	    x = ( v < key(x) ) ? x->left : x->right;
	}
	return insert(x, y, v);
    }

    Iterator insertSingle( const Key& k ) {
	
	QMapNodeBase* y = header;
	QMapNodeBase* x = header->parent;
	bool result = TRUE;
	while ( x != 0 ) {
	    result = ( k < key(x) );
	    y = x;
	    x = result ? x->left : x->right;
	}
	
	Iterator j( (NodePtr)y );
	if ( result ) {
	    
	    if ( j == begin() ) {
		return insert(x, y, k );
	    } else {
		
		--j;
	    }
	}
	
	if ( (j.node->key) < k )
	    return insert(x, y, k );
	
	return j;
    }

    Iterator insert( QMapNodeBase* x, QMapNodeBase* y, const Key& k ) {
	NodePtr z = new Node( k );
	if (y == header || x != 0 || k < key(y) ) {
	    y->left = z;                
	    if ( y == header ) {
		header->parent = z;
		header->right = z;
	    } else if ( y == header->left )
		header->left = z;           
	} else {
	    y->right = z;
	    if ( y == header->right )
		header->right = z;          
	}
	z->parent = y;
	z->left = 0;
	z->right = 0;
	rebalance( z, header->parent );
	++node_count;
	return Iterator(z);
    }

protected:
    


    const Key& key( QMapNodeBase* b ) const { return ((NodePtr)b)->key; }

    


    NodePtr header;
};


template<class Key, class T>
class __declspec(dllimport) QMap
{
public:
    


    typedef QMapIterator< Key, T > Iterator;
    typedef QMapConstIterator< Key, T > ConstIterator;
    typedef T ValueType;
    typedef QMapPrivate< Key, T > Priv;

    


    QMap() { sh = new QMapPrivate< Key, T >; }
    QMap( const QMap<Key,T>& m ) { sh = m.sh; sh->ref(); }
    ~QMap() { if ( sh->deref() ) delete sh; }

    QMap<Key,T>& operator= ( const QMap<Key,T>& m )
      { m.sh->ref(); if ( sh->deref() ) delete sh; sh = m.sh; return *this; }

    Iterator begin() { detach(); return sh->begin(); }
    Iterator end() { detach(); return sh->end(); }
    ConstIterator begin() const { return ((const Priv*)sh)->begin(); }
    ConstIterator end() const { return ((const Priv*)sh)->end(); }

    Iterator find ( const Key& k )
	{ detach(); return Iterator( sh->find( k ).node ); }
    ConstIterator find ( const Key& k ) const
	{ return sh->find( k ); }
    T& operator[] ( const Key& k ) {
	detach(); QMapNode<Key,T>* p = sh->find( k ).node;
	if ( p != sh->end().node ) return p->data;
	return insert( k, T() ).data(); }
    const T& operator[] ( const Key& k ) const
	{ return sh->find( k ).data(); }
    bool contains ( const Key& k ) const
	{ return find( k ) != end(); }
	

    uint count() const { return sh->node_count; }

    bool isEmpty() const { return sh->node_count == 0; }

    Iterator insert( const Key& key, const T& value ) {
        detach();
        Iterator it = sh->insertSingle( key );
        it.data() = value;
        return it;
    }

    void remove( Iterator it ) { detach(); sh->remove( it ); }
    void remove( const Key& k ) {
        detach();
        Iterator it( sh->find( k ).node );
        if ( it != end() )
            sh->remove( it );
    }

    Iterator replace( const Key& k, const T& v ) {
	remove( k );
	return insert( k, v );
    }

    void clear() { if ( sh->count == 1 ) sh->clear(); else { sh->deref(); sh = new QMapPrivate<Key,T>; } }



#line 570 "c:\\qt\\include\\qmap.h"

protected:
    


    void detach() { if ( sh->count > 1 ) { sh->deref(); sh = new QMapPrivate<Key,T>( sh ); } }

    Priv* sh;
};



template<class Key, class T>
inline QDataStream& operator>>( QDataStream& s, QMap<Key,T>& m ) {
    m.clear();
    Q_UINT32 c;
    s >> c;
    for( Q_UINT32 i = 0; i < c; ++i ) {
	Key k; T t;
	s >> k >> t;
	m.insert( k, t );
    }
    return s;
}


template<class Key, class T>
inline QDataStream& operator<<( QDataStream& s, const QMap<Key,T>& m ) {
    s << (Q_UINT32)m.count();
    QMapConstIterator<Key,T> it = m.begin();
    for( ; it != m.end(); ++it )
	s << it.key() << it.data();
    return s;
}
#line 605 "c:\\qt\\include\\qmap.h"

#line 607 "c:\\qt\\include\\qmap.h"
#line 11 "h:\\c_projekte\\elansim\\preferences.h"

class Preferences  
{
private:
	Preferences();
	~Preferences();

	struct Entrie {
		int id;
		QString key;
		QString val;
		Entrie* next;
	};

	struct Section {
		int id;
		bool touched;
		QString name;
		Section* next;
		Entrie* entrie_top;
	};

	static Section* top;
	static Entrie* c_e;
	static Section* c_s;
	static int entrie_count;
	static int found;

public:

	typedef QMap<QString, QString> Values;

	static int setFile(QString& name);

	static bool isKey(const char* name);
	static int getSection(const char* name);
	static int nextSection();
	static int nextEntrie();
	static const char* getKey();
	static const char* getValue();




};

#line 58 "h:\\c_projekte\\elansim\\preferences.h"
#line 6 "h:\\c_projekte\\elansim\\preferences.cpp"

#line 1 "c:\\qt\\include\\qfile.h"









































#line 1 "c:\\qt\\include\\qiodevice.h"



























































































































































#line 43 "c:\\qt\\include\\qfile.h"
#line 1 "c:\\qt\\include\\qstring.h"
























































































































































































































































































































































































































































































































































































































































































































































































































































#line 44 "c:\\qt\\include\\qfile.h"
#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"















#pragma once
#line 18 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"






#line 25 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"







#pragma pack(push,8)
#line 34 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"


extern "C" {
#line 38 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"


















#line 57 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"


























typedef wchar_t wint_t;
typedef wchar_t wctype_t;

#line 87 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"
#line 88 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"









typedef char *  va_list;
#line 99 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"

#line 101 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"






#line 108 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"

#line 110 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"






























#line 141 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"





struct _iobuf {
        char *_ptr;
        int   _cnt;
        char *_base;
        int   _flag;
        int   _file;
        int   _charbuf;
        int   _bufsiz;
        char *_tmpfname;
        };
typedef struct _iobuf FILE;

#line 159 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"












#line 172 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"












#line 185 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"



































__declspec(dllimport) extern FILE _iob[];
#line 222 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"









#line 232 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"


typedef __int64 fpos_t;







#line 243 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"
#line 244 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"


#line 247 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"




























__declspec(dllimport) int __cdecl _filbuf(FILE *);
__declspec(dllimport) int __cdecl _flsbuf(int, FILE *);




__declspec(dllimport) FILE * __cdecl _fsopen(const char *, const char *, int);
#line 283 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"

__declspec(dllimport) void __cdecl clearerr(FILE *);
__declspec(dllimport) int __cdecl fclose(FILE *);
__declspec(dllimport) int __cdecl _fcloseall(void);




__declspec(dllimport) FILE * __cdecl _fdopen(int, const char *);
#line 293 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"

__declspec(dllimport) int __cdecl feof(FILE *);
__declspec(dllimport) int __cdecl ferror(FILE *);
__declspec(dllimport) int __cdecl fflush(FILE *);
__declspec(dllimport) int __cdecl fgetc(FILE *);
__declspec(dllimport) int __cdecl _fgetchar(void);
__declspec(dllimport) int __cdecl fgetpos(FILE *, fpos_t *);
__declspec(dllimport) char * __cdecl fgets(char *, int, FILE *);




__declspec(dllimport) int __cdecl _fileno(FILE *);
#line 307 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"

__declspec(dllimport) int __cdecl _flushall(void);
__declspec(dllimport) FILE * __cdecl fopen(const char *, const char *);
__declspec(dllimport) int __cdecl fprintf(FILE *, const char *, ...);
__declspec(dllimport) int __cdecl fputc(int, FILE *);
__declspec(dllimport) int __cdecl _fputchar(int);
__declspec(dllimport) int __cdecl fputs(const char *, FILE *);
__declspec(dllimport) size_t __cdecl fread(void *, size_t, size_t, FILE *);
__declspec(dllimport) FILE * __cdecl freopen(const char *, const char *, FILE *);
__declspec(dllimport) int __cdecl fscanf(FILE *, const char *, ...);
__declspec(dllimport) int __cdecl fsetpos(FILE *, const fpos_t *);
__declspec(dllimport) int __cdecl fseek(FILE *, long, int);
__declspec(dllimport) long __cdecl ftell(FILE *);
__declspec(dllimport) size_t __cdecl fwrite(const void *, size_t, size_t, FILE *);
__declspec(dllimport) int __cdecl getc(FILE *);
__declspec(dllimport) int __cdecl getchar(void);
__declspec(dllimport) int __cdecl _getmaxstdio(void);
__declspec(dllimport) char * __cdecl gets(char *);
__declspec(dllimport) int __cdecl _getw(FILE *);
__declspec(dllimport) void __cdecl perror(const char *);
__declspec(dllimport) int __cdecl _pclose(FILE *);
__declspec(dllimport) FILE * __cdecl _popen(const char *, const char *);
__declspec(dllimport) int __cdecl printf(const char *, ...);
__declspec(dllimport) int __cdecl putc(int, FILE *);
__declspec(dllimport) int __cdecl putchar(int);
__declspec(dllimport) int __cdecl puts(const char *);
__declspec(dllimport) int __cdecl _putw(int, FILE *);
__declspec(dllimport) int __cdecl remove(const char *);
__declspec(dllimport) int __cdecl rename(const char *, const char *);
__declspec(dllimport) void __cdecl rewind(FILE *);
__declspec(dllimport) int __cdecl _rmtmp(void);
__declspec(dllimport) int __cdecl scanf(const char *, ...);
__declspec(dllimport) void __cdecl setbuf(FILE *, char *);
__declspec(dllimport) int __cdecl _setmaxstdio(int);
__declspec(dllimport) int __cdecl setvbuf(FILE *, char *, int, size_t);
__declspec(dllimport) int __cdecl _snprintf(char *, size_t, const char *, ...);
__declspec(dllimport) int __cdecl sprintf(char *, const char *, ...);
__declspec(dllimport) int __cdecl sscanf(const char *, const char *, ...);
__declspec(dllimport) char * __cdecl _tempnam(const char *, const char *);
__declspec(dllimport) FILE * __cdecl tmpfile(void);
__declspec(dllimport) char * __cdecl tmpnam(char *);
__declspec(dllimport) int __cdecl ungetc(int, FILE *);
__declspec(dllimport) int __cdecl _unlink(const char *);
__declspec(dllimport) int __cdecl vfprintf(FILE *, const char *, va_list);
__declspec(dllimport) int __cdecl vprintf(const char *, va_list);
__declspec(dllimport) int __cdecl _vsnprintf(char *, size_t, const char *, va_list);
__declspec(dllimport) int __cdecl vsprintf(char *, const char *, va_list);








#line 363 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"




__declspec(dllimport) FILE * __cdecl _wfsopen(const wchar_t *, const wchar_t *, int);
#line 369 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"

__declspec(dllimport) wint_t __cdecl fgetwc(FILE *);
__declspec(dllimport) wint_t __cdecl _fgetwchar(void);
__declspec(dllimport) wint_t __cdecl fputwc(wint_t, FILE *);
__declspec(dllimport) wint_t __cdecl _fputwchar(wint_t);
__declspec(dllimport) wint_t __cdecl getwc(FILE *);
__declspec(dllimport) wint_t __cdecl getwchar(void);
__declspec(dllimport) wint_t __cdecl putwc(wint_t, FILE *);
__declspec(dllimport) wint_t __cdecl putwchar(wint_t);
__declspec(dllimport) wint_t __cdecl ungetwc(wint_t, FILE *);

__declspec(dllimport) wchar_t * __cdecl fgetws(wchar_t *, int, FILE *);
__declspec(dllimport) int __cdecl fputws(const wchar_t *, FILE *);
__declspec(dllimport) wchar_t * __cdecl _getws(wchar_t *);
__declspec(dllimport) int __cdecl _putws(const wchar_t *);

__declspec(dllimport) int __cdecl fwprintf(FILE *, const wchar_t *, ...);
__declspec(dllimport) int __cdecl wprintf(const wchar_t *, ...);
__declspec(dllimport) int __cdecl _snwprintf(wchar_t *, size_t, const wchar_t *, ...);
__declspec(dllimport) int __cdecl swprintf(wchar_t *, const wchar_t *, ...);
__declspec(dllimport) int __cdecl vfwprintf(FILE *, const wchar_t *, va_list);
__declspec(dllimport) int __cdecl vwprintf(const wchar_t *, va_list);
__declspec(dllimport) int __cdecl _vsnwprintf(wchar_t *, size_t, const wchar_t *, va_list);
__declspec(dllimport) int __cdecl vswprintf(wchar_t *, const wchar_t *, va_list);
__declspec(dllimport) int __cdecl fwscanf(FILE *, const wchar_t *, ...);
__declspec(dllimport) int __cdecl swscanf(const wchar_t *, const wchar_t *, ...);
__declspec(dllimport) int __cdecl wscanf(const wchar_t *, ...);






__declspec(dllimport) FILE * __cdecl _wfdopen(int, const wchar_t *);
__declspec(dllimport) FILE * __cdecl _wfopen(const wchar_t *, const wchar_t *);
__declspec(dllimport) FILE * __cdecl _wfreopen(const wchar_t *, const wchar_t *, FILE *);
__declspec(dllimport) void __cdecl _wperror(const wchar_t *);
__declspec(dllimport) FILE * __cdecl _wpopen(const wchar_t *, const wchar_t *);
__declspec(dllimport) int __cdecl _wremove(const wchar_t *);
__declspec(dllimport) wchar_t * __cdecl _wtempnam(const wchar_t *, const wchar_t *);
__declspec(dllimport) wchar_t * __cdecl _wtmpnam(wchar_t *);



#line 414 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"
#line 415 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"


#line 418 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"





















#line 440 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"










__declspec(dllimport) int __cdecl fcloseall(void);
__declspec(dllimport) FILE * __cdecl fdopen(int, const char *);
__declspec(dllimport) int __cdecl fgetchar(void);
__declspec(dllimport) int __cdecl fileno(FILE *);
__declspec(dllimport) int __cdecl flushall(void);
__declspec(dllimport) int __cdecl fputchar(int);
__declspec(dllimport) int __cdecl getw(FILE *);
__declspec(dllimport) int __cdecl putw(int, FILE *);
__declspec(dllimport) int __cdecl rmtmp(void);
__declspec(dllimport) char * __cdecl tempnam(const char *, const char *);
__declspec(dllimport) int __cdecl unlink(const char *);

#line 463 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"


}
#line 467 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"


#pragma pack(pop)
#line 471 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"

#line 473 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"
#line 45 "c:\\qt\\include\\qfile.h"
#line 46 "c:\\qt\\include\\qfile.h"

class QDir;


class __declspec(dllimport) QFile : public QIODevice			
{
public:
    QFile();
    QFile( const QString &name );
   ~QFile();

    QString	name()	const;
    void	setName( const QString &name );

    typedef QCString (*EncoderFn)( const QString &fileName );
    typedef QString (*DecoderFn)( const QCString &localfileName );
    static QCString encodeName( const QString &fileName );
    static QString decodeName( const QCString &localFileName );
    static void setEncodingFunction( EncoderFn );
    static void setDecodingFunction( DecoderFn );

    bool	exists()   const;
    static bool exists( const QString &fileName );

    bool	remove();
    static bool remove( const QString &fileName );

    bool	open( int );
    bool	open( int, FILE * );
    bool	open( int, int );
    void	close();
    void	flush();

    uint	size()	const;
    int		at()	const;
    bool	at( int );
    bool	atEnd() const;

    int		readBlock( char *data, uint len );
    int		writeBlock( const char *data, uint len );
    int		writeBlock( const QByteArray& data )
		    { return QIODevice::writeBlock(data); }
    int		readLine( char *data, uint maxlen );
    int		readLine( QString &, uint maxlen );

    int		getch();
    int		putch( int );
    int		ungetch( int );

    int		handle() const;

protected:
    QString	fn;
    FILE       *fh;
    int		fd;
    int		length;
    bool	ext_f;
    void * 	d;

private:
    void	init();
    QCString ungetchBuffer;

private:	



#line 114 "c:\\qt\\include\\qfile.h"
};


inline QString QFile::name() const
{ return fn; }

inline int QFile::at() const
{ return ioIndex; }


#line 125 "c:\\qt\\include\\qfile.h"
#line 8 "h:\\c_projekte\\elansim\\preferences.cpp"
#line 1 "c:\\qt\\include\\qtextstream.h"









































#line 1 "c:\\qt\\include\\qiodevice.h"



























































































































































#line 43 "c:\\qt\\include\\qtextstream.h"
#line 1 "c:\\qt\\include\\qstring.h"
























































































































































































































































































































































































































































































































































































































































































































































































































































#line 44 "c:\\qt\\include\\qtextstream.h"

#line 46 "c:\\qt\\include\\qtextstream.h"


class QTextCodec;
class QTextDecoder;

class QTextStreamPrivate;

class __declspec(dllimport) QTextStream				
{
public:
    enum Encoding { Locale, Latin1, Unicode, UnicodeNetworkOrder,
		    UnicodeReverse, RawUnicode, UnicodeUTF8 };

    void	setEncoding( Encoding );

    void	setCodec( QTextCodec* );
#line 63 "c:\\qt\\include\\qtextstream.h"

    

    QTextStream();
    QTextStream( QIODevice * );
    QTextStream( QString*, int mode );
    QTextStream( QString&, int mode );		
    QTextStream( QByteArray, int mode );
    QTextStream( FILE *, int mode );
    virtual ~QTextStream();

    QIODevice	*device() const;
    void	 setDevice( QIODevice * );
    void	 unsetDevice();

    bool	 atEnd() const;
    bool	 eof() const;

    QTextStream &operator>>( QChar & );
    QTextStream &operator>>( char & );
    QTextStream &operator>>( signed short & );
    QTextStream &operator>>( unsigned short & );
    QTextStream &operator>>( signed int & );
    QTextStream &operator>>( unsigned int & );
    QTextStream &operator>>( signed long & );
    QTextStream &operator>>( unsigned long & );
    QTextStream &operator>>( float & );
    QTextStream &operator>>( double & );
    QTextStream &operator>>( char * );
    QTextStream &operator>>( QString & );
    QTextStream &operator>>( QCString & );

    QTextStream &operator<<( QChar );
    QTextStream &operator<<( char );
    QTextStream &operator<<( signed short );
    QTextStream &operator<<( unsigned short );
    QTextStream &operator<<( signed int );
    QTextStream &operator<<( unsigned int );
    QTextStream &operator<<( signed long );
    QTextStream &operator<<( unsigned long );
    QTextStream &operator<<( float );
    QTextStream &operator<<( double );
    QTextStream &operator<<( const char* );
    QTextStream &operator<<( const QString & );
    QTextStream &operator<<( const QCString & );
    QTextStream &operator<<( void * );		

    QTextStream &readRawBytes( char *, uint len );
    QTextStream &writeRawBytes( const char* , uint len );

    QString	readLine();
    QString	read();
    void	skipWhiteSpace();

    enum {
	skipws	  = 0x0001,			
	left	  = 0x0002,			
	right	  = 0x0004,			
	internal  = 0x0008,			
	bin	  = 0x0010,			
	oct	  = 0x0020,			
	dec	  = 0x0040,			
	hex	  = 0x0080,			
	showbase  = 0x0100,			
	showpoint = 0x0200,			
	uppercase = 0x0400,			
	showpos	  = 0x0800,			
	scientific= 0x1000,			
	fixed	  = 0x2000			
    };

    static const int basefield;			
    static const int adjustfield;		
    static const int floatfield;		

    int	  flags() const;
    int	  flags( int f );
    int	  setf( int bits );
    int	  setf( int bits, int mask );
    int	  unsetf( int bits );

    void  reset();

    int	  width()	const;
    int	  width( int );
    int	  fill()	const;
    int	  fill( int );
    int	  precision()	const;
    int	  precision( int );

private:
    long	 input_int();
    void	init();
    QTextStream &output_int( int, ulong, bool );
    QIODevice	*dev;
    bool	isNetworkOrder() { return internalOrder == QChar::networkOrdered(); }

    int		 fflags;
    int		 fwidth;
    int		 fillchar;
    int		 fprec;
    bool	 fstrm;
    bool	 owndev;
    QTextCodec 	*mapper;
    QTextStreamPrivate * d;
    QChar	ungetcBuf;
    bool	latin1;
    bool 	internalOrder;
    bool	doUnicodeHeader;
    void	*reserved_ptr;

    QChar	eat_ws();
    void	ts_ungetc( QChar );
    QChar	ts_getc();
    uint	ts_getbuf( QChar*, uint );
    void	ts_putc(int);
    void	ts_putc(QChar);
    bool	ts_isspace(QChar);
    bool	ts_isdigit(QChar);
    ulong	input_bin();
    ulong	input_oct();
    ulong	input_dec();
    ulong	input_hex();
    double	input_double();
    QTextStream &writeBlock( const char* p, uint len );
    QTextStream &writeBlock( const QChar* p, uint len );

private:	



#line 195 "c:\\qt\\include\\qtextstream.h"
};

typedef QTextStream QTS;

class __declspec(dllimport) QTextIStream : public QTextStream {
public:
    QTextIStream( QString* s ) :
	QTextStream(s,0x0001) { }
    QTextIStream( QByteArray ba ) :
	QTextStream(ba,0x0001) { }
    QTextIStream( FILE *f ) :
	QTextStream(f,0x0001) { }
};

class __declspec(dllimport) QTextOStream : public QTextStream {
public:
    QTextOStream( QString* s ) :
	QTextStream(s,0x0002) { }
    QTextOStream( QByteArray ba ) :
	QTextStream(ba,0x0002) { }
    QTextOStream( FILE *f ) :
	QTextStream(f,0x0002) { }
};





inline QIODevice *QTextStream::device() const
{ return dev; }

inline bool QTextStream::atEnd() const
{ return dev ? dev->atEnd() : FALSE; }

inline bool QTextStream::eof() const
{ return atEnd(); }

inline int QTextStream::flags() const
{ return fflags; }

inline int QTextStream::flags( int f )
{ int oldf = fflags;  fflags = f;  return oldf; }

inline int QTextStream::setf( int bits )
{ int oldf = fflags;  fflags |= bits;  return oldf; }

inline int QTextStream::setf( int bits, int mask )
{ int oldf = fflags;  fflags = (fflags & ~mask) | (bits & mask); return oldf; }

inline int QTextStream::unsetf( int bits )
{ int oldf = fflags;  fflags &= ~bits;	return oldf; }

inline int QTextStream::width() const
{ return fwidth; }

inline int QTextStream::width( int w )
{ int oldw = fwidth;  fwidth = w;  return oldw;	 }

inline int QTextStream::fill() const
{ return fillchar; }

inline int QTextStream::fill( int f )
{ int oldc = fillchar;	fillchar = f;  return oldc;  }

inline int QTextStream::precision() const
{ return fprec; }

inline int QTextStream::precision( int p )
{ int oldp = fprec;  fprec = p;	 return oldp;  }




inline QChar QTextStream::ts_getc()
{ QChar r; return ( ts_getbuf( &r,1 ) == 1 ? r : QChar((ushort)0xffff) ); }





typedef QTextStream & (*QTSFUNC)(QTextStream &);
typedef int (QTextStream::*QTSMFI)(int);	

class __declspec(dllimport) QTSManip {			
public:
    QTSManip( QTSMFI m, int a ) { mf=m; arg=a; }
    void exec( QTextStream &s ) { (s.*mf)(arg); }
private:
    QTSMFI mf;					
    int	   arg;					
};

__declspec(dllimport) inline QTextStream &operator>>( QTextStream &s, QTSFUNC f )
{ return (*f)( s ); }

__declspec(dllimport) inline QTextStream &operator<<( QTextStream &s, QTSFUNC f )
{ return (*f)( s ); }

__declspec(dllimport) inline QTextStream &operator<<( QTextStream &s, QTSManip m )
{ m.exec(s); return s; }

__declspec(dllimport) QTextStream &bin( QTextStream &s );	
__declspec(dllimport) QTextStream &oct( QTextStream &s );	
__declspec(dllimport) QTextStream &dec( QTextStream &s );	
__declspec(dllimport) QTextStream &hex( QTextStream &s );	
__declspec(dllimport) QTextStream &endl( QTextStream &s );	
__declspec(dllimport) QTextStream &flush( QTextStream &s );	
__declspec(dllimport) QTextStream &ws( QTextStream &s );	
__declspec(dllimport) QTextStream &reset( QTextStream &s );	

__declspec(dllimport) inline QTSManip qSetW( int w )
{
    QTSMFI func = &QTextStream::width;
    return QTSManip(func,w);
}

__declspec(dllimport) inline QTSManip qSetFill( int f )
{
    QTSMFI func = &QTextStream::fill;
    return QTSManip(func,f);
}

__declspec(dllimport) inline QTSManip qSetPrecision( int p )
{
    QTSMFI func = &QTextStream::precision;
    return QTSManip(func,p);
}









__declspec(dllimport) inline QTSManip setw( int w )
{
    QTSMFI func = &QTextStream::width;
    return QTSManip(func,w);
}

__declspec(dllimport) inline QTSManip setfill( int f )
{
    QTSMFI func = &QTextStream::fill;
    return QTSManip(func,f);
}

__declspec(dllimport) inline QTSManip setprecision( int p )
{
    QTSMFI func = &QTextStream::precision;
    return QTSManip(func,p);
}
#line 349 "c:\\qt\\include\\qtextstream.h"

#line 351 "c:\\qt\\include\\qtextstream.h"
#line 352 "c:\\qt\\include\\qtextstream.h"
#line 9 "h:\\c_projekte\\elansim\\preferences.cpp"
#line 1 "c:\\qt\\include\\qregexp.h"




























































































#line 10 "h:\\c_projekte\\elansim\\preferences.cpp"
#line 1 "c:\\qt\\include\\qcstring.h"















































































































































































































































































































































































































#line 11 "h:\\c_projekte\\elansim\\preferences.cpp"

Preferences::Section* Preferences::top = 0;
Preferences::Entrie* Preferences::c_e = 0;
Preferences::Section* Preferences::c_s = 0;
int Preferences::entrie_count = 0;
int Preferences::found = 0;





Preferences::Preferences() {}

int Preferences::setFile(QString& name)
{
	top = 0; 
	c_e = 0;  
	c_s = 0;

	int section_id = 1;
	int entrie_id = 1;
	QFile f(name);
	QString file_string;

	if (f.open(0x0001)) {
		QTextStream fts(&f);

		file_string = fts.read();
		file_string.stripWhiteSpace();

		QTextStream tts(&file_string, 0x0001);
		QRegExp regex("\\[.+\\]");

		QString token;
		QString old_token;
		QString name;
		QStringList* n = 0;
		QStringList* e = 0;

		while (!tts.eof()) {

			old_token = token;

			tts >> token;
			
			if (regex.match(token) >= 0) {
				name = token.mid(1,token.length()-2);
				Section* new_section = new Section;
				new_section->id = section_id++;
				new_section->name = name;
				new_section->next = top;
				new_section->touched = false;
				new_section->entrie_top = 0;
				top = new_section;
				entrie_id = 0; 
			}

			if (token == "=") {
				tts >> token;
				Entrie* new_entrie = new Entrie;
				new_entrie->id = entrie_id++;
				new_entrie->key = old_token;
				new_entrie->val = token;
				new_entrie->next = top->entrie_top;
				top->entrie_top = new_entrie;
			}

		}
		
		f.close();
		return 1;
		
	} else {
		f.close();
		return 0;
	}
}

bool Preferences::isKey(const char* name)
{
	return c_e->key == QString(name);
}


int Preferences::getSection(const char* name)
{
	found = 0;
	Section* s;
	for (s = top; s != 0; s = s->next) {
		if (s->name == QString(name)) {
			found++;
			s->touched = true;
		}
	}

	return found;
}

int Preferences::nextSection()
{
	Section* s = top;
	entrie_count = 0;
	while( s!= 0 && s->touched != true)
		s = s->next;

	if (s) {
		s->touched = false;
		c_s = s;
		return c_s->id;
	}

	c_s = 0;
	return 0;
}

int Preferences::nextEntrie()
{
	if (!c_s) return 0;

	Entrie* e = c_s->entrie_top;
	while ( e != 0 && e->id != entrie_count ) 
			e = e->next;

	if (!e) return 0;

	c_e = e;
	entrie_count++;
	found--;
	
	return 1;
}

const char* Preferences::getKey()
{
	if (c_e == 0) return 0;
	return c_e->key.ascii();
}

const char* Preferences::getValue()
{
	if (c_e == 0) return 0;
	return c_e->val.ascii();
}

