#line 1 "h:\\c_projekte\\elansim\\headview.cpp"








#line 1 "h:\\c_projekte\\elansim\\headview.h"











#line 1 "c:\\qt\\include\\qvariant.h"









































#line 1 "c:\\qt\\include\\qstring.h"










































#line 1 "c:\\qt\\include\\qcstring.h"










































#line 1 "c:\\qt\\include\\qarray.h"









































#line 1 "c:\\qt\\include\\qgarray.h"









































#line 1 "c:\\qt\\include\\qshared.h"









































#line 1 "c:\\qt\\include\\qglobal.h"











































































#line 77 "c:\\qt\\include\\qglobal.h"

#line 79 "c:\\qt\\include\\qglobal.h"





#line 85 "c:\\qt\\include\\qglobal.h"



















































#line 137 "c:\\qt\\include\\qglobal.h"











#line 149 "c:\\qt\\include\\qglobal.h"



























#line 177 "c:\\qt\\include\\qglobal.h"

#line 179 "c:\\qt\\include\\qglobal.h"


#line 182 "c:\\qt\\include\\qglobal.h"

























































































#line 272 "c:\\qt\\include\\qglobal.h"









#line 282 "c:\\qt\\include\\qglobal.h"




#line 287 "c:\\qt\\include\\qglobal.h"
















#line 304 "c:\\qt\\include\\qglobal.h"


#line 307 "c:\\qt\\include\\qglobal.h"


#line 310 "c:\\qt\\include\\qglobal.h"












#line 323 "c:\\qt\\include\\qglobal.h"




#line 328 "c:\\qt\\include\\qglobal.h"


















#line 347 "c:\\qt\\include\\qglobal.h"

#line 349 "c:\\qt\\include\\qglobal.h"



#line 353 "c:\\qt\\include\\qglobal.h"



#line 357 "c:\\qt\\include\\qglobal.h"








#line 366 "c:\\qt\\include\\qglobal.h"

typedef unsigned char	uchar;
typedef unsigned short	ushort;
typedef unsigned	uint;
typedef unsigned long	ulong;
typedef char	       *pchar;
typedef uchar	       *puchar;
typedef const char     *pcchar;







const bool FALSE = 0;
const bool TRUE = !0;
#line 384 "c:\\qt\\include\\qglobal.h"









#line 394 "c:\\qt\\include\\qglobal.h"











inline int qRound( double d )
{
    return d > 0.0 ? int(d+0.5) : int(d-0.5);
}









typedef signed char	INT8;			
typedef unsigned char	UINT8;			
typedef short		INT16;			
typedef unsigned short	UINT16;			
typedef int		INT32;			
typedef unsigned int	UINT32;			
#line 425 "c:\\qt\\include\\qglobal.h"

typedef signed char	Q_INT8;			
typedef unsigned char	Q_UINT8;		
typedef short		Q_INT16;		
typedef unsigned short	Q_UINT16;		
typedef int		Q_INT32;		
typedef unsigned int	Q_UINT32;		
typedef long		Q_INT64;		
typedef unsigned long	Q_UINT64;		





class QDataStream;




extern bool qt_winunicode;
#line 446 "c:\\qt\\include\\qglobal.h"


#line 1 "c:\\qt\\include\\qfeatures.h"



















































#line 53 "c:\\qt\\include\\qfeatures.h"
#line 1 "c:\\qt\\include\\qconfig.h"


#line 4 "c:\\qt\\include\\qconfig.h"






#line 54 "c:\\qt\\include\\qfeatures.h"
#line 55 "c:\\qt\\include\\qfeatures.h"













#line 69 "c:\\qt\\include\\qfeatures.h"







#line 77 "c:\\qt\\include\\qfeatures.h"






























#line 108 "c:\\qt\\include\\qfeatures.h"
























#line 133 "c:\\qt\\include\\qfeatures.h"







































#line 173 "c:\\qt\\include\\qfeatures.h"
















#line 190 "c:\\qt\\include\\qfeatures.h"





#line 196 "c:\\qt\\include\\qfeatures.h"








#line 205 "c:\\qt\\include\\qfeatures.h"












#line 218 "c:\\qt\\include\\qfeatures.h"






#line 225 "c:\\qt\\include\\qfeatures.h"






#line 232 "c:\\qt\\include\\qfeatures.h"





#line 238 "c:\\qt\\include\\qfeatures.h"






#line 245 "c:\\qt\\include\\qfeatures.h"






#line 252 "c:\\qt\\include\\qfeatures.h"












#line 265 "c:\\qt\\include\\qfeatures.h"















#line 281 "c:\\qt\\include\\qfeatures.h"





#line 287 "c:\\qt\\include\\qfeatures.h"









#line 297 "c:\\qt\\include\\qfeatures.h"














#line 312 "c:\\qt\\include\\qfeatures.h"






#line 319 "c:\\qt\\include\\qfeatures.h"











#line 331 "c:\\qt\\include\\qfeatures.h"




















                                        












#line 365 "c:\\qt\\include\\qfeatures.h"





















































#line 419 "c:\\qt\\include\\qfeatures.h"























#line 443 "c:\\qt\\include\\qfeatures.h"






#line 450 "c:\\qt\\include\\qfeatures.h"






#line 457 "c:\\qt\\include\\qfeatures.h"







#line 465 "c:\\qt\\include\\qfeatures.h"



















#line 485 "c:\\qt\\include\\qfeatures.h"






#line 492 "c:\\qt\\include\\qfeatures.h"




















#line 513 "c:\\qt\\include\\qfeatures.h"






#line 520 "c:\\qt\\include\\qfeatures.h"













#line 534 "c:\\qt\\include\\qfeatures.h"















































#line 582 "c:\\qt\\include\\qfeatures.h"





#line 588 "c:\\qt\\include\\qfeatures.h"





















#line 610 "c:\\qt\\include\\qfeatures.h"





#line 616 "c:\\qt\\include\\qfeatures.h"





#line 622 "c:\\qt\\include\\qfeatures.h"





#line 628 "c:\\qt\\include\\qfeatures.h"











#line 640 "c:\\qt\\include\\qfeatures.h"





#line 646 "c:\\qt\\include\\qfeatures.h"





#line 652 "c:\\qt\\include\\qfeatures.h"





#line 658 "c:\\qt\\include\\qfeatures.h"









#line 668 "c:\\qt\\include\\qfeatures.h"





#line 674 "c:\\qt\\include\\qfeatures.h"



























#line 702 "c:\\qt\\include\\qfeatures.h"







#line 710 "c:\\qt\\include\\qfeatures.h"









#line 720 "c:\\qt\\include\\qfeatures.h"






#line 727 "c:\\qt\\include\\qfeatures.h"





#line 733 "c:\\qt\\include\\qfeatures.h"


















#line 752 "c:\\qt\\include\\qfeatures.h"





#line 758 "c:\\qt\\include\\qfeatures.h"





#line 764 "c:\\qt\\include\\qfeatures.h"









#line 774 "c:\\qt\\include\\qfeatures.h"












#line 787 "c:\\qt\\include\\qfeatures.h"






#line 794 "c:\\qt\\include\\qfeatures.h"










#line 805 "c:\\qt\\include\\qfeatures.h"










#line 816 "c:\\qt\\include\\qfeatures.h"







#line 824 "c:\\qt\\include\\qfeatures.h"








































#line 865 "c:\\qt\\include\\qfeatures.h"






#line 872 "c:\\qt\\include\\qfeatures.h"






#line 879 "c:\\qt\\include\\qfeatures.h"






#line 886 "c:\\qt\\include\\qfeatures.h"










#line 897 "c:\\qt\\include\\qfeatures.h"





#line 903 "c:\\qt\\include\\qfeatures.h"






#line 910 "c:\\qt\\include\\qfeatures.h"





#line 916 "c:\\qt\\include\\qfeatures.h"





#line 922 "c:\\qt\\include\\qfeatures.h"






#line 929 "c:\\qt\\include\\qfeatures.h"






#line 936 "c:\\qt\\include\\qfeatures.h"






#line 943 "c:\\qt\\include\\qfeatures.h"






#line 950 "c:\\qt\\include\\qfeatures.h"






#line 957 "c:\\qt\\include\\qfeatures.h"





#line 963 "c:\\qt\\include\\qfeatures.h"






#line 970 "c:\\qt\\include\\qfeatures.h"

#line 972 "c:\\qt\\include\\qfeatures.h"
#line 449 "c:\\qt\\include\\qglobal.h"
#line 450 "c:\\qt\\include\\qglobal.h"









#line 460 "c:\\qt\\include\\qglobal.h"






#line 467 "c:\\qt\\include\\qglobal.h"
#line 468 "c:\\qt\\include\\qglobal.h"




#line 473 "c:\\qt\\include\\qglobal.h"



#line 477 "c:\\qt\\include\\qglobal.h"









__declspec(dllimport) const char *qVersion();
__declspec(dllimport) bool qSysInfo( int *wordSize, bool *bigEndian );











#line 500 "c:\\qt\\include\\qglobal.h"



#line 504 "c:\\qt\\include\\qglobal.h"









#line 514 "c:\\qt\\include\\qglobal.h"


#pragma warning(disable: 4244)
#pragma warning(disable: 4275)
#pragma warning(disable: 4514)
#pragma warning(disable: 4800)
#pragma warning(disable: 4097)
#pragma warning(disable: 4706)










#line 533 "c:\\qt\\include\\qglobal.h"
#line 534 "c:\\qt\\include\\qglobal.h"







#line 542 "c:\\qt\\include\\qglobal.h"








__declspec(dllimport) void qDebug( const char *, ... )	


#line 554 "c:\\qt\\include\\qglobal.h"
;

__declspec(dllimport) void qWarning( const char *, ... )	


#line 560 "c:\\qt\\include\\qglobal.h"
;

__declspec(dllimport) void qFatal( const char *, ... )	


#line 566 "c:\\qt\\include\\qglobal.h"
;







__declspec(dllimport) void debug( const char *, ... )	


#line 578 "c:\\qt\\include\\qglobal.h"
;

__declspec(dllimport) void warning( const char *, ... )	


#line 584 "c:\\qt\\include\\qglobal.h"
;

__declspec(dllimport) void fatal( const char *, ... )	


#line 590 "c:\\qt\\include\\qglobal.h"
;


#line 594 "c:\\qt\\include\\qglobal.h"






#line 601 "c:\\qt\\include\\qglobal.h"


#line 604 "c:\\qt\\include\\qglobal.h"


#line 607 "c:\\qt\\include\\qglobal.h"
#line 608 "c:\\qt\\include\\qglobal.h"

__declspec(dllimport) bool qt_check_pointer( bool c, const char *, int );





#line 616 "c:\\qt\\include\\qglobal.h"

enum QtMsgType { QtDebugMsg, QtWarningMsg, QtFatalMsg };

typedef void (*msg_handler)(QtMsgType, const char *);
__declspec(dllimport) msg_handler qInstallMsgHandler( msg_handler );


__declspec(dllimport) void qSuppressObsoleteWarnings( bool = TRUE );



__declspec(dllimport) void qObsolete( const char *obj, const char *oldfunc,
			 const char *newfunc );
__declspec(dllimport) void qObsolete( const char *obj, const char *oldfunc );
__declspec(dllimport) void qObsolete( const char *message );
#line 632 "c:\\qt\\include\\qglobal.h"

#line 634 "c:\\qt\\include\\qglobal.h"

#line 43 "c:\\qt\\include\\qshared.h"
#line 44 "c:\\qt\\include\\qshared.h"


struct QShared
{
    QShared()		{ count = 1; }
    void ref()		{ count++; }
    bool deref()	{ return !--count; }
    uint count;
};


#line 56 "c:\\qt\\include\\qshared.h"
#line 43 "c:\\qt\\include\\qgarray.h"
#line 44 "c:\\qt\\include\\qgarray.h"


class __declspec(dllimport) QGArray					
{
friend class QBuffer;
public:
    
    struct array_data : public QShared {	
	array_data()	{ data=0; len=0; }
	char *data;				
	uint  len;
    };
    QGArray();
protected:
    QGArray( int, int );			
    QGArray( int size );			
    QGArray( const QGArray &a );		
    virtual ~QGArray();

    QGArray    &operator=( const QGArray &a ) { return assign( a ); }

    virtual void detach()	{ duplicate(*this); }

    char       *data()	 const	{ return shd->data; }
    uint	nrefs()	 const	{ return shd->count; }
    uint	size()	 const	{ return shd->len; }
    bool	isEqual( const QGArray &a ) const;

    bool	resize( uint newsize );

    bool	fill( const char *d, int len, uint sz );

    QGArray    &assign( const QGArray &a );
    QGArray    &assign( const char *d, uint len );
    QGArray    &duplicate( const QGArray &a );
    QGArray    &duplicate( const char *d, uint len );
    void	store( const char *d, uint len );

    array_data *sharedBlock()	const		{ return shd; }
    void	setSharedBlock( array_data *p ) { shd=(array_data*)p; }

    QGArray    &setRawData( const char *d, uint len );
    void	resetRawData( const char *d, uint len );

    int		find( const char *d, uint index, uint sz ) const;
    int		contains( const char *d, uint sz ) const;
    
    void	sort( uint sz );
    int		bsearch( const char *d, uint sz ) const;

    char       *at( uint index ) const;

    bool	setExpand( uint index, const char *d, uint sz );

protected:
    virtual array_data *newData();
    virtual void deleteData( array_data *p );

private:
    static void msg_index( uint );
    array_data *shd;
};


inline char *QGArray::at( uint index ) const
{

    if ( index >= size() ) {
	msg_index( index );
	index = 0;
    }
#line 116 "c:\\qt\\include\\qgarray.h"
    return &shd->data[index];
}


#line 121 "c:\\qt\\include\\qgarray.h"
#line 43 "c:\\qt\\include\\qarray.h"
#line 44 "c:\\qt\\include\\qarray.h"


template<class type> class __declspec(dllimport) QArray : public QGArray
{
public:
    typedef type* Iterator;
    typedef const type* ConstIterator;
    typedef type ValueType;

protected:
    QArray( int, int ) : QGArray( 0, 0 ) {}

public:
    QArray() {}
    QArray( int size ) : QGArray(size*sizeof(type)) {}
    QArray( const QArray<type> &a ) : QGArray(a) {}
   ~QArray() {}
    QArray<type> &operator=(const QArray<type> &a)
				{ return (QArray<type>&)QGArray::assign(a); }
    type *data()    const	{ return (type *)QGArray::data(); }
    uint  nrefs()   const	{ return QGArray::nrefs(); }
    uint  size()    const	{ return QGArray::size()/sizeof(type); }
    uint  count()   const 	{ return size(); }
    bool  isEmpty() const	{ return QGArray::size() == 0; }
    bool  isNull()  const	{ return QGArray::data() == 0; }
    bool  resize( uint size )	{ return QGArray::resize(size*sizeof(type)); }
    bool  truncate( uint pos )	{ return QGArray::resize(pos*sizeof(type)); }
    bool  fill( const type &d, int size = -1 )
	{ return QGArray::fill((char*)&d,size,sizeof(type) ); }
    void  detach()		{ QGArray::detach(); }
    QArray<type>   copy() const
	{ QArray<type> tmp; return tmp.duplicate(*this); }
    QArray<type>& assign( const QArray<type>& a )
	{ return (QArray<type>&)QGArray::assign(a); }
    QArray<type>& assign( const type *a, uint n )
	{ return (QArray<type>&)QGArray::assign((char*)a,n*sizeof(type)); }
    QArray<type>& duplicate( const QArray<type>& a )
	{ return (QArray<type>&)QGArray::duplicate(a); }
    QArray<type>& duplicate( const type *a, uint n )
	{ return (QArray<type>&)QGArray::duplicate((char*)a,n*sizeof(type)); }
    QArray<type>& setRawData( const type *a, uint n )
	{ return (QArray<type>&)QGArray::setRawData((char*)a,
						     n*sizeof(type)); }
    void resetRawData( const type *a, uint n )
	{ QGArray::resetRawData((char*)a,n*sizeof(type)); }
    int	 find( const type &d, uint i=0 ) const
	{ return QGArray::find((char*)&d,i,sizeof(type)); }
    int	 contains( const type &d ) const
	{ return QGArray::contains((char*)&d,sizeof(type)); }
    void sort() { QGArray::sort(sizeof(type)); }
    int  bsearch( const type &d ) const
	{ return QGArray::bsearch((const char*)&d,sizeof(type)); }
    type& operator[]( int i ) const
	{ return (type &)(*(type *)QGArray::at(i*sizeof(type))); }
    type& at( uint i ) const
	{ return (type &)(*(type *)QGArray::at(i*sizeof(type))); }
	 operator const type*() const { return (const type *)QGArray::data(); }
    bool operator==( const QArray<type> &a ) const { return isEqual(a); }
    bool operator!=( const QArray<type> &a ) const { return !isEqual(a); }
    Iterator begin() { return data(); }
    Iterator end() { return data() + size(); }
    ConstIterator begin() const { return data(); }
    ConstIterator end() const { return data() + size(); }
};


#line 111 "c:\\qt\\include\\qarray.h"
#line 44 "c:\\qt\\include\\qcstring.h"
#line 45 "c:\\qt\\include\\qcstring.h"



#line 49 "c:\\qt\\include\\qcstring.h"

#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"















#pragma once
#line 18 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"






#line 25 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"



extern "C" {
#line 30 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"










#line 41 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"
#line 42 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"





#line 48 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"








#line 57 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"
#line 58 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"



typedef unsigned int size_t;

#line 64 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"




typedef unsigned short wchar_t;

#line 71 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"
#line 72 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"




#line 77 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"








#line 86 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"
#line 87 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"














        void *  __cdecl memcpy(void *, const void *, size_t);
        int     __cdecl memcmp(const void *, const void *, size_t);
        void *  __cdecl memset(void *, int, size_t);
        char *  __cdecl _strset(char *, int);
        char *  __cdecl strcpy(char *, const char *);
        char *  __cdecl strcat(char *, const char *);
        int     __cdecl strcmp(const char *, const char *);
        size_t  __cdecl strlen(const char *);
#line 110 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"
__declspec(dllimport) void *  __cdecl _memccpy(void *, const void *, int, unsigned int);
__declspec(dllimport) void *  __cdecl memchr(const void *, int, size_t);
__declspec(dllimport) int     __cdecl _memicmp(const void *, const void *, unsigned int);





__declspec(dllimport) void *  __cdecl memmove(void *, const void *, size_t);
#line 120 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"


__declspec(dllimport) char *  __cdecl strchr(const char *, int);
__declspec(dllimport) int     __cdecl _strcmpi(const char *, const char *);
__declspec(dllimport) int     __cdecl _stricmp(const char *, const char *);
__declspec(dllimport) int     __cdecl strcoll(const char *, const char *);
__declspec(dllimport) int     __cdecl _stricoll(const char *, const char *);
__declspec(dllimport) int     __cdecl _strncoll(const char *, const char *, size_t);
__declspec(dllimport) int     __cdecl _strnicoll(const char *, const char *, size_t);
__declspec(dllimport) size_t  __cdecl strcspn(const char *, const char *);
__declspec(dllimport) char *  __cdecl _strdup(const char *);
__declspec(dllimport) char *  __cdecl _strerror(const char *);
__declspec(dllimport) char *  __cdecl strerror(int);
__declspec(dllimport) char *  __cdecl _strlwr(char *);
__declspec(dllimport) char *  __cdecl strncat(char *, const char *, size_t);
__declspec(dllimport) int     __cdecl strncmp(const char *, const char *, size_t);
__declspec(dllimport) int     __cdecl _strnicmp(const char *, const char *, size_t);
__declspec(dllimport) char *  __cdecl strncpy(char *, const char *, size_t);
__declspec(dllimport) char *  __cdecl _strnset(char *, int, size_t);
__declspec(dllimport) char *  __cdecl strpbrk(const char *, const char *);
__declspec(dllimport) char *  __cdecl strrchr(const char *, int);
__declspec(dllimport) char *  __cdecl _strrev(char *);
__declspec(dllimport) size_t  __cdecl strspn(const char *, const char *);
__declspec(dllimport) char *  __cdecl strstr(const char *, const char *);
__declspec(dllimport) char *  __cdecl strtok(char *, const char *);
__declspec(dllimport) char *  __cdecl _strupr(char *);
__declspec(dllimport) size_t  __cdecl strxfrm (char *, const char *, size_t);














__declspec(dllimport) void * __cdecl memccpy(void *, const void *, int, unsigned int);
__declspec(dllimport) int __cdecl memicmp(const void *, const void *, unsigned int);
__declspec(dllimport) int __cdecl strcmpi(const char *, const char *);
__declspec(dllimport) int __cdecl stricmp(const char *, const char *);
__declspec(dllimport) char * __cdecl strdup(const char *);
__declspec(dllimport) char * __cdecl strlwr(char *);
__declspec(dllimport) int __cdecl strnicmp(const char *, const char *, size_t);
__declspec(dllimport) char * __cdecl strnset(char *, int, size_t);
__declspec(dllimport) char * __cdecl strrev(char *);
        char * __cdecl strset(char *, int);
__declspec(dllimport) char * __cdecl strupr(char *);

#line 174 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"







__declspec(dllimport) wchar_t * __cdecl wcscat(wchar_t *, const wchar_t *);
__declspec(dllimport) wchar_t * __cdecl wcschr(const wchar_t *, wchar_t);
__declspec(dllimport) int __cdecl wcscmp(const wchar_t *, const wchar_t *);
__declspec(dllimport) wchar_t * __cdecl wcscpy(wchar_t *, const wchar_t *);
__declspec(dllimport) size_t __cdecl wcscspn(const wchar_t *, const wchar_t *);
__declspec(dllimport) size_t __cdecl wcslen(const wchar_t *);
__declspec(dllimport) wchar_t * __cdecl wcsncat(wchar_t *, const wchar_t *, size_t);
__declspec(dllimport) int __cdecl wcsncmp(const wchar_t *, const wchar_t *, size_t);
__declspec(dllimport) wchar_t * __cdecl wcsncpy(wchar_t *, const wchar_t *, size_t);
__declspec(dllimport) wchar_t * __cdecl wcspbrk(const wchar_t *, const wchar_t *);
__declspec(dllimport) wchar_t * __cdecl wcsrchr(const wchar_t *, wchar_t);
__declspec(dllimport) size_t __cdecl wcsspn(const wchar_t *, const wchar_t *);
__declspec(dllimport) wchar_t * __cdecl wcsstr(const wchar_t *, const wchar_t *);
__declspec(dllimport) wchar_t * __cdecl wcstok(wchar_t *, const wchar_t *);

__declspec(dllimport) wchar_t * __cdecl _wcsdup(const wchar_t *);
__declspec(dllimport) int __cdecl _wcsicmp(const wchar_t *, const wchar_t *);
__declspec(dllimport) int __cdecl _wcsnicmp(const wchar_t *, const wchar_t *, size_t);
__declspec(dllimport) wchar_t * __cdecl _wcsnset(wchar_t *, wchar_t, size_t);
__declspec(dllimport) wchar_t * __cdecl _wcsrev(wchar_t *);
__declspec(dllimport) wchar_t * __cdecl _wcsset(wchar_t *, wchar_t);

__declspec(dllimport) wchar_t * __cdecl _wcslwr(wchar_t *);
__declspec(dllimport) wchar_t * __cdecl _wcsupr(wchar_t *);
__declspec(dllimport) size_t __cdecl wcsxfrm(wchar_t *, const wchar_t *, size_t);
__declspec(dllimport) int __cdecl wcscoll(const wchar_t *, const wchar_t *);
__declspec(dllimport) int __cdecl _wcsicoll(const wchar_t *, const wchar_t *);
__declspec(dllimport) int __cdecl _wcsncoll(const wchar_t *, const wchar_t *, size_t);
__declspec(dllimport) int __cdecl _wcsnicoll(const wchar_t *, const wchar_t *, size_t);







__declspec(dllimport) wchar_t * __cdecl wcsdup(const wchar_t *);
__declspec(dllimport) int __cdecl wcsicmp(const wchar_t *, const wchar_t *);
__declspec(dllimport) int __cdecl wcsnicmp(const wchar_t *, const wchar_t *, size_t);
__declspec(dllimport) wchar_t * __cdecl wcsnset(wchar_t *, wchar_t, size_t);
__declspec(dllimport) wchar_t * __cdecl wcsrev(wchar_t *);
__declspec(dllimport) wchar_t * __cdecl wcsset(wchar_t *, wchar_t);
__declspec(dllimport) wchar_t * __cdecl wcslwr(wchar_t *);
__declspec(dllimport) wchar_t * __cdecl wcsupr(wchar_t *);
__declspec(dllimport) int __cdecl wcsicoll(const wchar_t *, const wchar_t *);

#line 228 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"


#line 231 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"

#line 233 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"


}
#line 237 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"

#line 239 "c:\\programme\\microsoft visual studio\\vc98\\include\\string.h"
#line 51 "c:\\qt\\include\\qcstring.h"




















#line 72 "c:\\qt\\include\\qcstring.h"






__declspec(dllimport) void *qmemmove( void *dst, const void *src, uint len );



#line 83 "c:\\qt\\include\\qcstring.h"

__declspec(dllimport) char *qstrdup( const char * );

__declspec(dllimport) inline uint cstrlen( const char *str )
{ return strlen(str); }

__declspec(dllimport) inline uint qstrlen( const char *str )
{ return str ? strlen(str) : 0; }

__declspec(dllimport) inline char *cstrcpy( char *dst, const char *src )
{ return strcpy(dst,src); }

__declspec(dllimport) inline char *qstrcpy( char *dst, const char *src )
{ return src ? strcpy(dst, src) : 0; }

__declspec(dllimport) char *qstrncpy( char *dst, const char *src, uint len );

__declspec(dllimport) inline int cstrcmp( const char *str1, const char *str2 )
{ return strcmp(str1,str2); }

__declspec(dllimport) inline int qstrcmp( const char *str1, const char *str2 )
{ return (str1 && str2) ? strcmp(str1,str2) : (int)((long)str2 - (long)str1); }

__declspec(dllimport) inline int cstrncmp( const char *str1, const char *str2, uint len )
{ return strncmp(str1,str2,len); }

__declspec(dllimport) inline int qstrncmp( const char *str1, const char *str2, uint len )
{ return (str1 && str2) ? strncmp(str1,str2,len) :
			  (int)((long)str2 - (long)str1); }

__declspec(dllimport) int qstricmp( const char *, const char * );

__declspec(dllimport) int qstrnicmp( const char *, const char *, uint len );


























#line 143 "c:\\qt\\include\\qcstring.h"




__declspec(dllimport) Q_UINT16 qChecksum( const char *s, uint len );






template class __declspec(dllimport) QArray<char>;
#line 156 "c:\\qt\\include\\qcstring.h"
typedef QArray<char> QByteArray;






__declspec(dllimport) QDataStream &operator<<( QDataStream &, const QByteArray & );
__declspec(dllimport) QDataStream &operator>>( QDataStream &, QByteArray & );
#line 166 "c:\\qt\\include\\qcstring.h"







class QRegExp;

class __declspec(dllimport) QCString : public QByteArray	
{
public:
    QCString() {}				
    QCString( int size );			
    QCString( const QCString &s ) : QByteArray( s ) {}
    QCString( const char *str );		
    QCString( const char *str, uint maxlen );	

    QCString    &operator=( const QCString &s );
    QCString    &operator=( const char *str );	

    bool	isNull()	const;
    bool	isEmpty()	const;
    uint	length()	const;
    bool	resize( uint newlen );
    bool	truncate( uint pos );
    bool	fill( char c, int len = -1 );

    QCString	copy()	const;

    QCString    &sprintf( const char *format, ... );

    int		find( char c, int index=0, bool cs=TRUE ) const;
    int		find( const char *str, int index=0, bool cs=TRUE ) const;
    int		find( const QRegExp &, int index=0 ) const;
    int		findRev( char c, int index=-1, bool cs=TRUE) const;
    int		findRev( const char *str, int index=-1, bool cs=TRUE) const;
    int		findRev( const QRegExp &, int index=-1 ) const;
    int		contains( char c, bool cs=TRUE ) const;
    int		contains( const char *str, bool cs=TRUE ) const;
    int		contains( const QRegExp & ) const;

    QCString	left( uint len )  const;
    QCString	right( uint len ) const;
    QCString	mid( uint index, uint len=0xffffffff) const;

    QCString	leftJustify( uint width, char fill=' ', bool trunc=FALSE)const;
    QCString	rightJustify( uint width, char fill=' ',bool trunc=FALSE)const;

    QCString	lower() const;
    QCString	upper() const;

    QCString	stripWhiteSpace()	const;
    QCString	simplifyWhiteSpace()	const;

    QCString    &insert( uint index, const char * );
    QCString    &insert( uint index, char );
    QCString    &append( const char * );
    QCString    &prepend( const char * );
    QCString    &remove( uint index, uint len );
    QCString    &replace( uint index, uint len, const char * );
    QCString    &replace( const QRegExp &, const char * );

    short	toShort( bool *ok=0 )	const;
    ushort	toUShort( bool *ok=0 )	const;
    int		toInt( bool *ok=0 )	const;
    uint	toUInt( bool *ok=0 )	const;
    long	toLong( bool *ok=0 )	const;
    ulong	toULong( bool *ok=0 )	const;
    float	toFloat( bool *ok=0 )	const;
    double	toDouble( bool *ok=0 )	const;

    QCString    &setStr( const char *s );
    QCString    &setNum( short );
    QCString    &setNum( ushort );
    QCString    &setNum( int );
    QCString    &setNum( uint );
    QCString    &setNum( long );
    QCString    &setNum( ulong );
    QCString    &setNum( float, char f='g', int prec=6 );
    QCString    &setNum( double, char f='g', int prec=6 );

    bool	setExpand( uint index, char c );

		operator const char *() const;
    QCString    &operator+=( const char *str );
    QCString    &operator+=( char c );
};






__declspec(dllimport) QDataStream &operator<<( QDataStream &, const QCString & );
__declspec(dllimport) QDataStream &operator>>( QDataStream &, QCString & );
#line 263 "c:\\qt\\include\\qcstring.h"





inline QCString &QCString::operator=( const QCString &s )
{ return (QCString&)assign( s ); }

inline QCString &QCString::operator=( const char *str )
{ return (QCString&)duplicate( str, qstrlen(str)+1 ); }

inline bool QCString::isNull() const
{ return data() == 0; }

inline bool QCString::isEmpty() const
{ return data() == 0 || *data() == '\0'; }

inline uint QCString::length() const
{ return qstrlen( data() ); }

inline bool QCString::truncate( uint pos )
{ return resize(pos+1); }

inline QCString QCString::copy() const
{ return QCString( data() ); }

inline QCString &QCString::prepend( const char *s )
{ return insert(0,s); }

inline QCString &QCString::append( const char *s )
{ return operator+=(s); }

inline QCString &QCString::setNum( short n )
{ return setNum((long)n); }

inline QCString &QCString::setNum( ushort n )
{ return setNum((ulong)n); }

inline QCString &QCString::setNum( int n )
{ return setNum((long)n); }

inline QCString &QCString::setNum( uint n )
{ return setNum((ulong)n); }

inline QCString &QCString::setNum( float n, char f, int prec )
{ return setNum((double)n,f,prec); }

inline QCString::operator const char *() const
{ return (const char *)data(); }






__declspec(dllimport) inline bool operator==( const QCString &s1, const QCString &s2 )
{ return qstrcmp(s1.data(),s2.data()) == 0; }

__declspec(dllimport) inline bool operator==( const QCString &s1, const char *s2 )
{ return qstrcmp(s1.data(),s2) == 0; }

__declspec(dllimport) inline bool operator==( const char *s1, const QCString &s2 )
{ return qstrcmp(s1,s2.data()) == 0; }

__declspec(dllimport) inline bool operator!=( const QCString &s1, const QCString &s2 )
{ return qstrcmp(s1.data(),s2.data()) != 0; }

__declspec(dllimport) inline bool operator!=( const QCString &s1, const char *s2 )
{ return qstrcmp(s1.data(),s2) != 0; }

__declspec(dllimport) inline bool operator!=( const char *s1, const QCString &s2 )
{ return qstrcmp(s1,s2.data()) != 0; }

__declspec(dllimport) inline bool operator<( const QCString &s1, const QCString& s2 )
{ return qstrcmp(s1.data(),s2.data()) < 0; }

__declspec(dllimport) inline bool operator<( const QCString &s1, const char *s2 )
{ return qstrcmp(s1.data(),s2) < 0; }

__declspec(dllimport) inline bool operator<( const char *s1, const QCString &s2 )
{ return qstrcmp(s1,s2.data()) < 0; }

__declspec(dllimport) inline bool operator<=( const QCString &s1, const char *s2 )
{ return qstrcmp(s1.data(),s2) <= 0; }

__declspec(dllimport) inline bool operator<=( const char *s1, const QCString &s2 )
{ return qstrcmp(s1,s2.data()) <= 0; }

__declspec(dllimport) inline bool operator>( const QCString &s1, const char *s2 )
{ return qstrcmp(s1.data(),s2) > 0; }

__declspec(dllimport) inline bool operator>( const char *s1, const QCString &s2 )
{ return qstrcmp(s1,s2.data()) > 0; }

__declspec(dllimport) inline bool operator>=( const QCString &s1, const char *s2 )
{ return qstrcmp(s1.data(),s2) >= 0; }

__declspec(dllimport) inline bool operator>=( const char *s1, const QCString &s2 )
{ return qstrcmp(s1,s2.data()) >= 0; }

__declspec(dllimport) inline QCString operator+( const QCString &s1, const QCString &s2 )
{
    QCString tmp( s1.data() );
    tmp += s2;
    return tmp;
}

__declspec(dllimport) inline QCString operator+( const QCString &s1, const char *s2 )
{
    QCString tmp( s1.data() );
    tmp += s2;
    return tmp;
}

__declspec(dllimport) inline QCString operator+( const char *s1, const QCString &s2 )
{
    QCString tmp( s1 );
    tmp += s2;
    return tmp;
}

__declspec(dllimport) inline QCString operator+( const QCString &s1, char c2 )
{
    QCString tmp( s1.data() );
    tmp += c2;
    return tmp;
}

__declspec(dllimport) inline QCString operator+( char c1, const QCString &s2 )
{
    QCString tmp;
    tmp += c1;
    tmp += s2;
    return tmp;
}

#line 400 "c:\\qt\\include\\qcstring.h"
#line 44 "c:\\qt\\include\\qstring.h"
#line 45 "c:\\qt\\include\\qstring.h"






class QRegExp;
class QString;
class QCharRef;

class __declspec(dllimport) QChar {
public:
    QChar();
    QChar( char c );
    QChar( uchar c );
    QChar( uchar c, uchar r );
    QChar( const QChar& c );
    QChar( ushort rc );
    QChar( short rc );
    QChar( uint rc );
    QChar( int rc );

    static QChar null;            
    static QChar replacement;     
    static QChar byteOrderMark;     
    static QChar byteOrderSwapped;     
    static QChar nbsp;            

    

    enum Category
    {
	NoCategory,

	Mark_NonSpacing,	  
	Mark_SpacingCombining,	  
	Mark_Enclosing,		  

	Number_DecimalDigit,	  
	Number_Letter,		  
	Number_Other,		  

	Separator_Space,	  
	Separator_Line,		  
	Separator_Paragraph,	  

	Other_Control,		  
	Other_Format,		  
	Other_Surrogate,	  
	Other_PrivateUse,	  
	Other_NotAssigned,	  

	Letter_Uppercase,	  
	Letter_Lowercase,	  
	Letter_Titlecase,	  
	Letter_Modifier,	  
	Letter_Other,		  

	Punctuation_Connector,	  
	Punctuation_Dask,	  
	Punctuation_Open,	  
	Punctuation_Close,	  
	Punctuation_InitialQuote, 
	Punctuation_FinalQuote,	  
	Punctuation_Other,	  

	Symbol_Math,		  
	Symbol_Currency,	  
	Symbol_Modifier,	  
	Symbol_Other		  
    };

    enum Direction
    {
	DirL, DirR, DirEN, DirES, DirET, DirAN, DirCS, DirB, DirS, DirWS, DirON,
	DirLRE, DirLRO, DirAL, DirRLE, DirRLO, DirPDF, DirNSM, DirBN
    };

    enum Decomposition
    {
        Single, Canonical, Font, NoBreak, Initial, Medial,
        Final, Isolated, Circle, Super, Sub, Vertical,
        Wide, Narrow, Small, Square, Compat, Fraction
    };

    enum Joining
    {
	OtherJoining, Dual, Right, Center
    };

    

    int digitValue() const;
    QChar lower() const;
    QChar upper() const;

    Category category() const;
    Direction direction() const;
    Joining joining() const;
    bool mirrored() const;
    QChar mirroredChar() const;
    QString decomposition() const;
    Decomposition decompositionTag() const;

    char latin1() const { return rw ? 0 : cl; }
    ushort unicode() const { return (rw << 8) | cl; }

    
    operator char() const { return latin1(); }
#line 155 "c:\\qt\\include\\qstring.h"

    bool isNull() const { return unicode()==0; }
    bool isPrint() const;
    bool isPunct() const;
    bool isSpace() const;
    bool isMark() const;
    bool isLetter() const;
    bool isNumber() const;
    bool isLetterOrNumber() const;
    bool isDigit() const;

    uchar& cell() { return cl; }
    uchar& row() { return rw; }
    uchar cell() const { return cl; }
    uchar row() const { return rw; }

    static bool networkOrdered() { return (int)net_ordered == 1; }

    friend inline int operator==( char ch, QChar c );
    friend inline int operator==( QChar c, char ch );
    friend inline int operator==( QChar c1, QChar c2 );
    friend inline int operator!=( QChar c1, QChar c2 );
    friend inline int operator!=( char ch, QChar c );
    friend inline int operator!=( QChar c, char ch );
    friend inline int operator<=( QChar c, char ch );
    friend inline int operator<=( char ch, QChar c );
    friend inline int operator<=( QChar c1, QChar c2 );

private:









#line 194 "c:\\qt\\include\\qstring.h"
    
    uchar cl;
    uchar rw;


#line 200 "c:\\qt\\include\\qstring.h"
    enum { net_ordered = 0 };
#line 202 "c:\\qt\\include\\qstring.h"
} ;

inline QChar::QChar()
{
    rw = 0; cl = 0;



}
inline QChar::QChar( char c )
{
    rw = 0; cl = (uchar)c;



}
inline QChar::QChar( uchar c )
{
    rw = 0; cl = c;



}
inline QChar::QChar( uchar c, uchar r )
{
    rw = r; cl = c;



}
inline QChar::QChar( const QChar& c )
{
    rw = c.rw; cl = c.cl;



}
inline QChar::QChar( ushort rc )
{
    rw = (uchar)((rc>>8)&0xff); cl = (uchar)(rc&0xff);



}
inline QChar::QChar( short rc )
{
    rw = (uchar)((rc>>8)&0xff); cl = (uchar)(rc&0xff);



}
inline QChar::QChar( uint rc )
{
    rw = (uchar)((rc>>8)&0xff); cl = (uchar)(rc&0xff);



}
inline QChar::QChar( int rc )
{
    rw = (uchar)((rc>>8)&0xff); cl = (uchar)(rc&0xff);



}


inline int operator==( char ch, QChar c )
{
    return ch == c.cl && !c.rw;
}

inline int operator==( QChar c, char ch )
{
    return ch == c.cl && !c.rw;
}

inline int operator==( QChar c1, QChar c2 )
{
    return c1.cl == c2.cl
	&& c1.rw == c2.rw;
}

inline int operator!=( QChar c1, QChar c2 )
{
    return c1.cl != c2.cl
	|| c1.rw != c2.rw;
}

inline int operator!=( char ch, QChar c )
{
    return ch != c.cl || c.rw;
}

inline int operator!=( QChar c, char ch )
{
    return ch != c.cl || c.rw;
}

inline int operator<=( QChar c, char ch )
{
    return !(ch < c.cl || c.rw);
}

inline int operator<=( char ch, QChar c )
{
    return ch <= c.cl || c.rw;
}

inline int operator<=( QChar c1, QChar c2 )
{
    return c1.rw > c2.rw
	? FALSE
	: c1.rw < c2.rw
	    ? TRUE
	    : c1.cl <= c2.cl;
}

inline int operator>=( QChar c, char ch ) { return ch <= c; }
inline int operator>=( char ch, QChar c ) { return c <= ch; }
inline int operator>=( QChar c1, QChar c2 ) { return c2 <= c1; }
inline int operator<( QChar c, char ch ) { return !(ch<=c); }
inline int operator<( char ch, QChar c ) { return !(c<=ch); }
inline int operator<( QChar c1, QChar c2 ) { return !(c2<=c1); }
inline int operator>( QChar c, char ch ) { return !(ch>=c); }
inline int operator>( char ch, QChar c ) { return !(c>=ch); }
inline int operator>( QChar c1, QChar c2 ) { return !(c2>=c1); }


struct __declspec(dllimport) QStringData : public QShared {
    QStringData() :
	unicode(0), ascii(0), len(0), maxl(0), dirtyascii(0) { ref(); }
    QStringData(QChar *u, uint l, uint m) :
	unicode(u), ascii(0), len(l), maxl(m), dirtyascii(0) { }

    ~QStringData() { if ( unicode ) delete[] ((char*)unicode);
                     if ( ascii ) delete[] ascii; }

    void deleteSelf();
    QChar *unicode;
    char *ascii;
    uint len;
    uint maxl:30;
    uint dirtyascii:1;
};


class __declspec(dllimport) QString
{
public:
    QString();					
    QString( QChar );				
    QString( const QString & );			
    QString( const QByteArray& );		
    QString( const QChar* unicode, uint length ); 

    QString( const char *str );			
#line 360 "c:\\qt\\include\\qstring.h"
    ~QString();

    QString    &operator=( const QString & );	

    QString    &operator=( const char * );	
#line 366 "c:\\qt\\include\\qstring.h"
    QString    &operator=( const QCString& );	
    QString    &operator=( QChar c );
    QString    &operator=( char c );

    static QString null;

    bool	isNull()	const;
    bool	isEmpty()	const;
    uint	length()	const;
    void	truncate( uint pos );



#line 380 "c:\\qt\\include\\qstring.h"
    void	fill( QChar c, int len = -1 );

    QString	copy()	const;

    QString arg(long a, int fieldwidth=0, int base=10) const;
    QString arg(ulong a, int fieldwidth=0, int base=10) const;
    QString arg(int a, int fieldwidth=0, int base=10) const;
    QString arg(uint a, int fieldwidth=0, int base=10) const;
    QString arg(short a, int fieldwidth=0, int base=10) const;
    QString arg(ushort a, int fieldwidth=0, int base=10) const;
    QString arg(char a, int fieldwidth=0) const;
    QString arg(QChar a, int fieldwidth=0) const;
    QString arg(const QString& a, int fieldwidth=0) const;
    QString arg(double a, int fieldwidth=0, char fmt='g', int prec=-1) const;

    QString    &sprintf( const char* format, ... )


#line 399 "c:\\qt\\include\\qstring.h"
	;

    int		find( QChar c, int index=0, bool cs=TRUE ) const;
    int		find( char c, int index=0, bool cs=TRUE ) const;
    int		find( const QString &str, int index=0, bool cs=TRUE ) const;
    int		find( const QRegExp &, int index=0 ) const;

    int		find( const char* str, int index=0 ) const;
#line 408 "c:\\qt\\include\\qstring.h"
    int		findRev( QChar c, int index=-1, bool cs=TRUE) const;
    int		findRev( char c, int index=-1, bool cs=TRUE) const;
    int		findRev( const QString &str, int index=-1, bool cs=TRUE) const;
    int		findRev( const QRegExp &, int index=-1 ) const;

    int		findRev( const char* str, int index=-1 ) const;
#line 415 "c:\\qt\\include\\qstring.h"
    int		contains( QChar c, bool cs=TRUE ) const;
    int		contains( char c, bool cs=TRUE ) const
		    { return contains(QChar(c), cs); }

    int		contains( const char* str, bool cs=TRUE ) const;
#line 421 "c:\\qt\\include\\qstring.h"
    int		contains( const QString &str, bool cs=TRUE ) const;
    int		contains( const QRegExp & ) const;

    QString	left( uint len )  const;
    QString	right( uint len ) const;
    QString	mid( uint index, uint len=0xffffffff) const;

    QString	leftJustify( uint width, QChar fill=' ', bool trunc=FALSE)const;
    QString	rightJustify( uint width, QChar fill=' ',bool trunc=FALSE)const;

    QString	lower() const;
    QString	upper() const;

    QString	stripWhiteSpace()	const;
    QString	simplifyWhiteSpace()	const;

    QString    &insert( uint index, const QString & );
    QString    &insert( uint index, const QChar*, uint len );
    QString    &insert( uint index, QChar );
    QString    &insert( uint index, char c ) { return insert(index,QChar(c)); }
    QString    &append( char );
    QString    &append( QChar );
    QString    &append( const QString & );
    QString    &prepend( char );
    QString    &prepend( QChar );
    QString    &prepend( const QString & );
    QString    &remove( uint index, uint len );
    QString    &replace( uint index, uint len, const QString & );
    QString    &replace( uint index, uint len, const QChar*, uint clen );
    QString    &replace( const QRegExp &, const QString & );

    short	toShort( bool *ok=0, int base=10 )	const;
    ushort	toUShort( bool *ok=0, int base=10 )	const;
    int		toInt( bool *ok=0, int base=10 )	const;
    uint	toUInt( bool *ok=0, int base=10 )	const;
    long	toLong( bool *ok=0, int base=10 )	const;
    ulong	toULong( bool *ok=0, int base=10 )	const;
    float	toFloat( bool *ok=0 )	const;
    double	toDouble( bool *ok=0 )	const;

    QString    &setNum( short, int base=10 );
    QString    &setNum( ushort, int base=10 );
    QString    &setNum( int, int base=10 );
    QString    &setNum( uint, int base=10 );
    QString    &setNum( long, int base=10 );
    QString    &setNum( ulong, int base=10 );
    QString    &setNum( float, char f='g', int prec=6 );
    QString    &setNum( double, char f='g', int prec=6 );

    static QString number( long, int base=10 );
    static QString number( ulong, int base=10);
    static QString number( int, int base=10 );
    static QString number( uint, int base=10);
    static QString number( double, char f='g', int prec=6 );

    void	setExpand( uint index, QChar c );

    QString    &operator+=( const QString &str );
    QString    &operator+=( QChar c );
    QString    &operator+=( char c );

    
    QChar at( uint i ) const
	{ return i<d->len ? d->unicode[i] : QChar::null; }
    QChar operator[]( int i ) const { return at((uint)i); }
    QCharRef at( uint i );
    QCharRef operator[]( int i );

    QChar constref(uint i) const
	{ return at(i); }
    QChar& ref(uint i)
	{ 
	    if (d->count!=1 || i>=d->len)
		subat(i);
	    d->dirtyascii=1;
	    return d->unicode[i];
	}

    const QChar* unicode() const { return d->unicode; }
    const char* ascii() const;
    const char* latin1() const;
    static QString fromLatin1(const char*, int len=-1);

    QCString utf8() const;
    static QString fromUtf8(const char*, int len=-1);
#line 507 "c:\\qt\\include\\qstring.h"
    QCString local8Bit() const;
    static QString fromLocal8Bit(const char*, int len=-1);
    bool operator!() const;

    operator const char *() const { return latin1(); }
#line 513 "c:\\qt\\include\\qstring.h"

    QString &setUnicode( const QChar* unicode, uint len );
    QString &setUnicodeCodes( const ushort* unicode_as_ushorts, uint len );
    QString &setLatin1( const char*, int len=-1 );

    int compare( const QString& s ) const;
    static int compare( const QString& s1, const QString& s2 )
	{ return s1.compare(s2); }


    friend __declspec(dllimport) QDataStream &operator>>( QDataStream &, QString & );
#line 525 "c:\\qt\\include\\qstring.h"
    
    void compose();
    QChar::Direction basicDirection();
    QString visual(int index = 0, int len = -1);


    const char* data() const { return latin1(); }
#line 533 "c:\\qt\\include\\qstring.h"

    bool startsWith( const QString& ) const;

private:
    QString( int size, bool dummy );		

    void deref();
    void real_detach();
    void setLength( uint pos );
    void subat( uint );
    bool findArg(int& pos, int& len) const;

    static QChar* asciiToUnicode( const char*, uint * len, uint maxlen=(uint)-1 );
    static QChar* asciiToUnicode( const QByteArray&, uint * len );
    static char* unicodeToAscii( const QChar*, uint len );

    QStringData *d;
    static QStringData* shared_null;
    static QStringData* makeSharedNull();

    friend class QConstString;
    QString(QStringData* dd, bool ) : d(dd) { }
};

class __declspec(dllimport) QCharRef {
    friend class QString;
    QString& s;
    uint p;
    QCharRef(QString* str, uint pos) : s(*str), p(pos) { }

public:
    

    

    ushort unicode() const { return s.constref(p).unicode(); }
    char latin1() const { return s.constref(p).latin1(); }

    
    QCharRef operator=(char c ) { s.ref(p)=c; return *this; }
    QCharRef operator=(uchar c ) { s.ref(p)=c; return *this; }
    QCharRef operator=(QChar c ) { s.ref(p)=c; return *this; }
    QCharRef operator=(const QCharRef& c ) { s.ref(p)=c.unicode(); return *this; }
    QCharRef operator=(ushort rc ) { s.ref(p)=rc; return *this; }
    QCharRef operator=(short rc ) { s.ref(p)=rc; return *this; }
    QCharRef operator=(uint rc ) { s.ref(p)=rc; return *this; }
    QCharRef operator=(int rc ) { s.ref(p)=rc; return *this; }

    operator QChar () const { return s.constref(p); }

    
    bool isNull() const { return unicode()==0; }
    bool isPrint() const { return s.constref(p).isPrint(); }
    bool isPunct() const { return s.constref(p).isPunct(); }
    bool isSpace() const { return s.constref(p).isSpace(); }
    bool isMark() const { return s.constref(p).isMark(); }
    bool isLetter() const { return s.constref(p).isLetter(); }
    bool isNumber() const { return s.constref(p).isNumber(); }
    bool isLetterOrNumber() { return s.constref(p).isLetterOrNumber(); }
    bool isDigit() const { return s.constref(p).isDigit(); }

    int digitValue() const { return s.constref(p).digitValue(); }
    QChar lower() { return s.constref(p).lower(); }
    QChar upper() { return s.constref(p).upper(); }

    QChar::Category category() const { return s.constref(p).category(); }
    QChar::Direction direction() const { return s.constref(p).direction(); }
    QChar::Joining joining() const { return s.constref(p).joining(); }
    bool mirrored() const { return s.constref(p).mirrored(); }
    QChar mirroredChar() const { return s.constref(p).mirroredChar(); }
    QString decomposition() const { return s.constref(p).decomposition(); }
    QChar::Decomposition decompositionTag() const { return s.constref(p).decompositionTag(); }

    
    uchar cell() const { return s.constref(p).cell(); }
    uchar row() const { return s.constref(p).row(); }
#line 610 "c:\\qt\\include\\qstring.h"
};

inline QCharRef QString::at( uint i ) { return QCharRef(this,i); }
inline QCharRef QString::operator[]( int i ) { return at((uint)i); }


class __declspec(dllimport) QConstString : private QString {
public:
    QConstString( QChar* unicode, uint length );
    ~QConstString();
    const QString& string() const { return *this; }
};






__declspec(dllimport) QDataStream &operator<<( QDataStream &, const QString & );
__declspec(dllimport) QDataStream &operator>>( QDataStream &, QString & );
#line 631 "c:\\qt\\include\\qstring.h"










inline QString::QString() :
    d(shared_null ? shared_null : makeSharedNull())
{
    d->ref();
}

inline QString::~QString()
{
    if ( d->deref() ) {
	if ( d == shared_null )
	    shared_null = 0;
	d->deleteSelf();
    }
}

inline QString &QString::operator=( QChar c )
{ return *this = QString(c); }

inline QString &QString::operator=( char c )
{ return *this = QString(QChar(c)); }

inline bool QString::isNull() const
{ return unicode() == 0; }

inline bool QString::operator!() const
{ return isNull(); }

inline uint QString::length() const
{ return d->len; }

inline bool QString::isEmpty() const
{ return length() == 0; }

inline QString QString::copy() const
{ return QString( *this ); }

inline QString &QString::prepend( const QString & s )
{ return insert(0,s); }

inline QString &QString::prepend( QChar c )
{ return insert(0,c); }

inline QString &QString::prepend( char c )
{ return insert(0,c); }

inline QString &QString::append( const QString & s )
{ return operator+=(s); }

inline QString &QString::append( QChar c )
{ return operator+=(c); }

inline QString &QString::append( char c )
{ return operator+=(c); }

inline QString &QString::setNum( short n, int base )
{ return setNum((long)n, base); }

inline QString &QString::setNum( ushort n, int base )
{ return setNum((ulong)n, base); }

inline QString &QString::setNum( int n, int base )
{ return setNum((long)n, base); }

inline QString &QString::setNum( uint n, int base )
{ return setNum((ulong)n, base); }

inline QString &QString::setNum( float n, char f, int prec )
{ return setNum((double)n,f,prec); }

inline QString QString::arg(int a, int fieldwidth, int base) const
{ return arg((long)a, fieldwidth, base); }

inline QString QString::arg(uint a, int fieldwidth, int base) const
{ return arg((ulong)a, fieldwidth, base); }

inline QString QString::arg(short a, int fieldwidth, int base) const
{ return arg((long)a, fieldwidth, base); }

inline QString QString::arg(ushort a, int fieldwidth, int base) const
{ return arg((ulong)a, fieldwidth, base); }

inline int QString::find( char c, int index, bool cs ) const
{ return find(QChar(c), index, cs); }

inline int QString::findRev( char c, int index, bool cs) const
{ return findRev( QChar(c), index, cs ); }



inline int QString::find( const char* str, int index ) const
{ return find(QString::fromLatin1(str), index); }

inline int QString::findRev( const char* str, int index ) const
{ return findRev(QString::fromLatin1(str), index); }
#line 736 "c:\\qt\\include\\qstring.h"






__declspec(dllimport) bool operator!=( const QString &s1, const QString &s2 );
__declspec(dllimport) bool operator<( const QString &s1, const QString &s2 );
__declspec(dllimport) bool operator<=( const QString &s1, const QString &s2 );
__declspec(dllimport) bool operator==( const QString &s1, const QString &s2 );
__declspec(dllimport) bool operator>( const QString &s1, const QString &s2 );
__declspec(dllimport) bool operator>=( const QString &s1, const QString &s2 );

__declspec(dllimport) bool operator!=( const QString &s1, const char *s2 );
__declspec(dllimport) bool operator<( const QString &s1, const char *s2 );
__declspec(dllimport) bool operator<=( const QString &s1, const char *s2 );
__declspec(dllimport) bool operator==( const QString &s1, const char *s2 );
__declspec(dllimport) bool operator>( const QString &s1, const char *s2 );
__declspec(dllimport) bool operator>=( const QString &s1, const char *s2 );
__declspec(dllimport) bool operator!=( const char *s1, const QString &s2 );
__declspec(dllimport) bool operator<( const char *s1, const QString &s2 );
__declspec(dllimport) bool operator<=( const char *s1, const QString &s2 );
__declspec(dllimport) bool operator==( const char *s1, const QString &s2 );

__declspec(dllimport) bool operator>=( const char *s1, const QString &s2 );
#line 762 "c:\\qt\\include\\qstring.h"

__declspec(dllimport) inline QString operator+( const QString &s1, const QString &s2 )
{
    QString tmp( s1 );
    tmp += s2;
    return tmp;
}


__declspec(dllimport) inline QString operator+( const QString &s1, const char *s2 )
{
    QString tmp( s1 );
    tmp += QString::fromLatin1(s2);
    return tmp;
}

__declspec(dllimport) inline QString operator+( const char *s1, const QString &s2 )
{
    QString tmp = QString::fromLatin1( s1 );
    tmp += s2;
    return tmp;
}
#line 785 "c:\\qt\\include\\qstring.h"

__declspec(dllimport) inline QString operator+( const QString &s1, QChar c2 )
{
    QString tmp( s1 );
    tmp += c2;
    return tmp;
}

__declspec(dllimport) inline QString operator+( const QString &s1, char c2 )
{
    QString tmp( s1 );
    tmp += c2;
    return tmp;
}

__declspec(dllimport) inline QString operator+( QChar c1, const QString &s2 )
{
    QString tmp;
    tmp += c1;
    tmp += s2;
    return tmp;
}

__declspec(dllimport) inline QString operator+( char c1, const QString &s2 )
{
    QString tmp;
    tmp += c1;
    tmp += s2;
    return tmp;
}


extern __declspec(dllimport) QString qt_winQString(void*);
extern __declspec(dllimport) const void* qt_winTchar(const QString& str, bool addnul);
extern __declspec(dllimport) void* qt_winTchar_new(const QString& str);
extern __declspec(dllimport) QCString qt_winQString2MB( const QString& s, int len=-1 );
extern __declspec(dllimport) QString qt_winMB2QString( const char* mb, int len=-1 );
#line 823 "c:\\qt\\include\\qstring.h"

#line 825 "c:\\qt\\include\\qstring.h"
#line 43 "c:\\qt\\include\\qvariant.h"
#line 44 "c:\\qt\\include\\qvariant.h"



class QString;
class QCString;
class QFont;
class QPixmap;
class QBrush;
class QRect;
class QPoint;
class QImage;
class QSize;
class QColor;
class QPalette;
class QColorGroup;
class QIconSet;
class QDataStream;
class QPointArray;
class QRegion;
class QBitmap;
class QCursor;
class QStringList;
class QSizePolicy;


class QVariant;
class QVariantPrivate;
template <class T> class QValueList;
template <class T> class QValueListConstIterator;
template <class T> class QValueListNode;
template <class Key, class T> class QMap;
template <class Key, class T> class QMapConstIterator;


class __declspec(dllimport) QVariant
{
public:
    enum Type {
	Invalid,
	Map,
	List,
	String,
	StringList,
	Font,
	Pixmap,
	Brush,
	Rect,
	Size,
	Color,
	Palette,
	ColorGroup,
	IconSet,
	Point,
	Image,
	Int,
	UInt,
	Bool,
	Double,
	CString,
	PointArray,
	Region,
	Bitmap,
	Cursor,
	SizePolicy
    };

    QVariant();
    ~QVariant();
    QVariant( const QVariant& );
    QVariant( QDataStream& s );

    QVariant( const QString& );
    QVariant( const QCString& );
    QVariant( const char* );
    QVariant( const QStringList& );
    QVariant( const QFont& );
    QVariant( const QPixmap& );
    QVariant( const QImage& );
    QVariant( const QBrush& );
    QVariant( const QPoint& );
    QVariant( const QRect& );
    QVariant( const QSize& );
    QVariant( const QColor& );
    QVariant( const QPalette& );
    QVariant( const QColorGroup& );
    QVariant( const QIconSet& );
    QVariant( const QPointArray& );
    QVariant( const QRegion& );
    QVariant( const QBitmap& );
    QVariant( const QCursor& );
    QVariant( const QValueList<QVariant>& );
    QVariant( const QMap<QString,QVariant>& );
    QVariant( int );
    QVariant( uint );
    
    QVariant( bool, int );
    QVariant( double );
    QVariant( QSizePolicy );

    QVariant& operator= ( const QVariant& );
    bool operator==( const QVariant& ) const;
    bool operator!=( const QVariant& ) const;

    Type type() const;
    const char* typeName() const;

    bool canCast( Type ) const;

    bool isValid() const;

    void clear();

    const QString toString() const;
    const QCString toCString() const;
    const QStringList toStringList() const;
    const QFont toFont() const;
    const QPixmap toPixmap() const;
    const QImage toImage() const;
    const QBrush toBrush() const;
    const QPoint toPoint() const;
    const QRect toRect() const;
    const QSize toSize() const;
    const QColor toColor() const;
    const QPalette toPalette() const;
    const QColorGroup toColorGroup() const;
    const QIconSet toIconSet() const;
    const QPointArray toPointArray() const;
    const QBitmap toBitmap() const;
    const QRegion toRegion() const;
    const QCursor toCursor() const;
    int toInt() const;
    uint toUInt() const;
    bool toBool() const;
    double toDouble() const;
    const QValueList<QVariant> toList() const;
    const QMap<QString,QVariant> toMap() const;
    QSizePolicy toSizePolicy() const;

    QValueListConstIterator<QVariant> listBegin() const;
    QValueListConstIterator<QVariant> listEnd() const;
    QValueListConstIterator<QString> stringListBegin() const;
    QValueListConstIterator<QString> stringListEnd() const;
    QMapConstIterator<QString,QVariant> mapBegin() const;
    QMapConstIterator<QString,QVariant> mapEnd() const;
    QMapConstIterator<QString,QVariant> mapFind( const QString& ) const;

    QString& asString();
    QCString& asCString();
    QStringList& asStringList();
    QFont& asFont();
    QPixmap& asPixmap();
    QImage& asImage();
    QBrush& asBrush();
    QPoint& asPoint();
    QRect& asRect();
    QSize& asSize();
    QColor& asColor();
    QPalette& asPalette();
    QColorGroup& asColorGroup();
    QIconSet& asIconSet();
    QPointArray& asPointArray();
    QBitmap& asBitmap();
    QRegion& asRegion();
    QCursor& asCursor();
    int& asInt();
    uint& asUInt();
    bool& asBool();
    double& asDouble();
    QValueList<QVariant>& asList();
    QMap<QString,QVariant>& asMap();
    QSizePolicy& asSizePolicy();

    void load( QDataStream& );
    void save( QDataStream& ) const;

    static const char* typeToName( Type typ );
    static Type nameToType( const char* name );

private:
    void detach();

    QVariantPrivate* d;
};

class QVariantPrivate : public QShared
{
public:
    QVariantPrivate();
    QVariantPrivate( QVariantPrivate* );
    ~QVariantPrivate();

    void clear();

    QVariant::Type typ;
    union
    {
	uint u;
	int i;
	bool b;
	double d;
	void *ptr;
    } value;
};



#line 1 "c:\\qt\\include\\qvaluelist.h"









































#line 1 "c:\\qt\\include\\qshared.h"























































#line 43 "c:\\qt\\include\\qvaluelist.h"
#line 1 "c:\\qt\\include\\qdatastream.h"









































#line 1 "c:\\qt\\include\\qiodevice.h"









































#line 1 "c:\\qt\\include\\qglobal.h"


























































































































































































































































































































































































































































































































































































































































#line 43 "c:\\qt\\include\\qiodevice.h"
#line 1 "c:\\qt\\include\\qcstring.h"















































































































































































































































































































































































































#line 44 "c:\\qt\\include\\qiodevice.h"
#line 45 "c:\\qt\\include\\qiodevice.h"











































class __declspec(dllimport) QIODevice					
{
public:
    QIODevice();
    virtual ~QIODevice();

    int		 flags()  const { return ioMode; }
    int		 mode()	  const { return ioMode & 0x00ff; }
    int		 state()  const { return ioMode & 0xf000; }

    bool	 isDirectAccess()     const { return ((ioMode & 0x0100)     == 0x0100); }
    bool	 isSequentialAccess() const { return ((ioMode & 0x0200) == 0x0200); }
    bool	 isCombinedAccess()   const { return ((ioMode & 0x0300)   == 0x0300); }
    bool	 isBuffered()	      const { return ((ioMode & 0x0040)        != 0x0040); }
    bool	 isRaw()	      const { return ((ioMode & 0x0040)        == 0x0040); }
    bool	 isSynchronous()      const { return ((ioMode & 0x0080)      != 0x0080); }
    bool	 isAsynchronous()     const { return ((ioMode & 0x0080)      == 0x0080); }
    bool	 isTranslated()	      const { return ((ioMode & 0x0010)  == 0x0010); }
    bool	 isReadable()	      const { return ((ioMode & 0x0001)   == 0x0001); }
    bool	 isWritable()	      const { return ((ioMode & 0x0002)  == 0x0002); }
    bool	 isReadWrite()	      const { return ((ioMode & 0x0003)  == 0x0003); }
    bool	 isInactive()	      const { return state() == 0; }
    bool	 isOpen()	      const { return state() == 0x1000; }

    int		 status() const { return ioSt; }
    void	 resetStatus()	{ ioSt = 0; }

    virtual bool open( int mode ) = 0;
    virtual void close() = 0;
    virtual void flush() = 0;

    virtual uint size()	  const = 0;
    virtual int	 at()	  const;
    virtual bool at( int );
    virtual bool atEnd()  const;
    bool	 reset() { return at(0); }

    virtual int	 readBlock( char *data, uint maxlen ) = 0;
    virtual int	 writeBlock( const char *data, uint len ) = 0;
    virtual int	 readLine( char *data, uint maxlen );
    int writeBlock( const QByteArray& data );
    QByteArray readAll();

    virtual int	 getch() = 0;
    virtual int	 putch( int ) = 0;
    virtual int	 ungetch( int ) = 0;

protected:
    void	 setFlags( int f ) { ioMode = f; }
    void	 setType( int );
    void	 setMode( int );
    void	 setState( int );
    void	 setStatus( int );
    int		 ioIndex;

private:
    int		 ioMode;
    int		 ioSt;

private:	



#line 152 "c:\\qt\\include\\qiodevice.h"
};


#line 156 "c:\\qt\\include\\qiodevice.h"
#line 43 "c:\\qt\\include\\qdatastream.h"
#line 1 "c:\\qt\\include\\qstring.h"
























































































































































































































































































































































































































































































































































































































































































































































































































































#line 44 "c:\\qt\\include\\qdatastream.h"
#line 45 "c:\\qt\\include\\qdatastream.h"


class __declspec(dllimport) QDataStream				
{
public:
    QDataStream();
    QDataStream( QIODevice * );
    QDataStream( QByteArray, int mode );
    virtual ~QDataStream();

    QIODevice	*device() const;
    void	 setDevice( QIODevice * );
    void	 unsetDevice();

    bool	 atEnd() const;
    bool	 eof() const;

    enum ByteOrder { BigEndian, LittleEndian };
    int		 byteOrder()	const;
    void	 setByteOrder( int );

    bool	 isPrintableData() const;
    void	 setPrintableData( bool );

    int		 version() const;
    void	 setVersion( int );

    QDataStream &operator>>( Q_INT8 &i );
    QDataStream &operator>>( Q_UINT8 &i );
    QDataStream &operator>>( Q_INT16 &i );
    QDataStream &operator>>( Q_UINT16 &i );
    QDataStream &operator>>( Q_INT32 &i );
    QDataStream &operator>>( Q_UINT32 &i );
    QDataStream &operator>>( Q_INT64 &i );
    QDataStream &operator>>( Q_UINT64 &i );

    QDataStream &operator>>( float &f );
    QDataStream &operator>>( double &f );
    QDataStream &operator>>( char *&str );

    QDataStream &operator<<( Q_INT8 i );
    QDataStream &operator<<( Q_UINT8 i );
    QDataStream &operator<<( Q_INT16 i );
    QDataStream &operator<<( Q_UINT16 i );
    QDataStream &operator<<( Q_INT32 i );
    QDataStream &operator<<( Q_UINT32 i );
    QDataStream &operator<<( Q_INT64 i );
    QDataStream &operator<<( Q_UINT64 i );
    QDataStream &operator<<( float f );
    QDataStream &operator<<( double f );
    QDataStream &operator<<( const char *str );

    QDataStream &readBytes( char *&, uint &len );
    QDataStream &readRawBytes( char *, uint len );

    QDataStream &writeBytes( const char *, uint len );
    QDataStream &writeRawBytes( const char *, uint len );

private:
    QIODevice	*dev;
    bool	 owndev;
    int		 byteorder;
    bool	 printable;
    bool	 noswap;
    int		 ver;

private:	



#line 116 "c:\\qt\\include\\qdatastream.h"
};






inline QIODevice *QDataStream::device() const
{ return dev; }

inline bool QDataStream::atEnd() const
{ return dev ? dev->atEnd() : TRUE; }

inline bool QDataStream::eof() const
{ return atEnd(); }

inline int QDataStream::byteOrder() const
{ return byteorder; }

inline bool QDataStream::isPrintableData() const
{ return printable; }

inline void QDataStream::setPrintableData( bool p )
{ printable = p; }

inline int QDataStream::version() const
{ return ver; }

inline void QDataStream::setVersion( int v )
{ ver = v; }

inline QDataStream &QDataStream::operator>>( Q_UINT8 &i )
{ return *this >> (Q_INT8&)i; }

inline QDataStream &QDataStream::operator>>( Q_UINT16 &i )
{ return *this >> (Q_INT16&)i; }

inline QDataStream &QDataStream::operator>>( Q_UINT32 &i )
{ return *this >> (Q_INT32&)i; }

inline QDataStream &QDataStream::operator>>( Q_UINT64 &i )
{ return *this >> (Q_INT64&)i; }

inline QDataStream &QDataStream::operator<<( Q_UINT8 i )
{ return *this << (Q_INT8)i; }

inline QDataStream &QDataStream::operator<<( Q_UINT16 i )
{ return *this << (Q_INT16)i; }

inline QDataStream &QDataStream::operator<<( Q_UINT32 i )
{ return *this << (Q_INT32)i; }

inline QDataStream &QDataStream::operator<<( Q_UINT64 i )
{ return *this << (Q_INT64)i; }


#line 173 "c:\\qt\\include\\qdatastream.h"
#line 174 "c:\\qt\\include\\qdatastream.h"
#line 44 "c:\\qt\\include\\qvaluelist.h"
#line 45 "c:\\qt\\include\\qvaluelist.h"


#pragma warning(disable:4284) 
#line 49 "c:\\qt\\include\\qvaluelist.h"

template <class T>
class __declspec(dllimport) QValueListNode
{
public:
    QValueListNode( const T& t ) : data( t ) { }
    QValueListNode() { }

    
    virtual ~QValueListNode() { }
#line 60 "c:\\qt\\include\\qvaluelist.h"

    QValueListNode<T>* next;
    QValueListNode<T>* prev;
    T data;
};

template<class T>
class __declspec(dllimport) QValueListIterator
{
 public:
    


    typedef QValueListNode<T>* NodePtr;

    


    NodePtr node;

    


    QValueListIterator() : node( 0 ) {}
    QValueListIterator( NodePtr p ) : node( p ) {}
    QValueListIterator( const QValueListIterator<T>& it ) : node( it.node ) {}

    bool operator==( const QValueListIterator<T>& it ) const { return node == it.node; }
    bool operator!=( const QValueListIterator<T>& it ) const { return node != it.node; }
    const T& operator*() const { return node->data; }
    T& operator*() { return node->data; }

    
    

    QValueListIterator<T>& operator++() {
	node = node->next;
	return *this;
    }

    QValueListIterator<T> operator++(int) {
	QValueListIterator<T> tmp = *this;
	node = node->next;
	return tmp;
    }

    QValueListIterator<T>& operator--() {
	node = node->prev;
	return *this;
    }

    QValueListIterator<T> operator--(int) {
	QValueListIterator<T> tmp = *this;
	node = node->prev;
	return tmp;
    }
};

template<class T>
class __declspec(dllimport) QValueListConstIterator
{
 public:
    


    typedef QValueListNode<T>* NodePtr;

    


    NodePtr node;

    


    QValueListConstIterator() : node( 0 ) {}
    QValueListConstIterator( NodePtr p ) : node( p ) {}
    QValueListConstIterator( const QValueListConstIterator<T>& it ) : node( it.node ) {}
    QValueListConstIterator( const QValueListIterator<T>& it ) : node( it.node ) {}

    bool operator==( const QValueListConstIterator<T>& it ) const { return node == it.node; }
    bool operator!=( const QValueListConstIterator<T>& it ) const { return node != it.node; }
    const T& operator*() const { return node->data; }

    
    

    QValueListConstIterator<T>& operator++() {
	node = node->next;
	return *this;
    }

    QValueListConstIterator<T> operator++(int) {
	QValueListConstIterator<T> tmp = *this;
	node = node->next;
	return tmp;
    }

    QValueListConstIterator<T>& operator--() {
	node = node->prev;
	return *this;
    }

    QValueListConstIterator<T> operator--(int) {
	QValueListConstIterator<T> tmp = *this;
	node = node->prev;
	return tmp;
    }
};

template <class T>
class __declspec(dllimport) QValueListPrivate : public QShared
{
public:
    


    typedef QValueListIterator<T> Iterator;
    typedef QValueListConstIterator<T> ConstIterator;
    typedef QValueListNode<T> Node;
    typedef QValueListNode<T>* NodePtr;

    


    QValueListPrivate() { node = new Node; node->next = node->prev = node; nodes = 0; }
    QValueListPrivate( const QValueListPrivate<T>& _p ) : QShared() {
	node = new Node; node->next = node->prev = node; nodes = 0;
	Iterator b( _p.node->next );
	Iterator e( _p.node );
	Iterator i( node );
	while( b != e )
	    insert( i, *b++ );
    }

    void derefAndDelete() 
    {
	if ( deref() )
	    delete this;
    }


    
    virtual
#line 205 "c:\\qt\\include\\qvaluelist.h"
    ~QValueListPrivate() {
	NodePtr p = node->next;
	while( p != node ) {
	    NodePtr x = p->next;
	    delete p;
	    p = x;
	}
	delete node;
    }

    Iterator insert( Iterator it, const T& x ) {
	NodePtr p = new Node( x );
	p->next = it.node;
	p->prev = it.node->prev;
	it.node->prev->next = p;
	it.node->prev = p;
	nodes++;
	return p;
    }

    Iterator remove( Iterator it ) {
	if ( !(it.node != node) ) qWarning("ASSERT: \"%s\" in %s (%d)","it.node != node","c:\\qt\\include\\qvaluelist.h",226);
	NodePtr next = it.node->next;
	NodePtr prev = it.node->prev;
	prev->next = next;
	next->prev = prev;
	delete it.node;
	nodes--;
	return Iterator( next );
    }

    NodePtr find( NodePtr start, const T& x ) const {
	ConstIterator first( start );
	ConstIterator last( node );
	while( first != last) {
	    if ( *first == x )
		return first.node;
	    ++first;
	}
	return last.node;
    }

    int findIndex( NodePtr start, const T& x ) const {
	ConstIterator first( start );
	ConstIterator last( node );
	int pos = 0;
	while( first != last) {
	    if ( *first == x )
		return pos;
	    ++first;
	    ++pos;
	}
	return -1;
    }

    uint contains( const T& x ) const {
	uint result = 0;
	Iterator first = Iterator( node->next );
	Iterator last = Iterator( node );
	while( first != last) {
	    if ( *first == x )
		++result;
	    ++first;
	}
	return result;
    }

    void remove( const T& x ) {
	Iterator first = Iterator( node->next );
	Iterator last = Iterator( node );
	while( first != last) {
	    if ( *first == x )
		first = remove( first );
	    else
		++first;
	}
    }

    NodePtr at( uint i ) const {
	if ( !(i <= nodes) ) qWarning("ASSERT: \"%s\" in %s (%d)","i <= nodes","c:\\qt\\include\\qvaluelist.h",284);
	NodePtr p = node->next;
	for( uint x = 0; x < i; ++x )
	    p = p->next;
	return p;
    }

    void clear() {
	nodes = 0;
	NodePtr p = node->next;
	while( p != node ) {
	    NodePtr next = p->next;
	    delete p;
	    p = next;
	}
	node->next = node->prev = node;
    }

    NodePtr node;
    uint nodes;
};

template <class T>
class __declspec(dllimport) QValueList
{
public:
    


    typedef QValueListIterator<T> Iterator;
    typedef QValueListConstIterator<T> ConstIterator;
    typedef T ValueType;

    


    QValueList() { sh = new QValueListPrivate<T>; }
    QValueList( const QValueList<T>& l ) { sh = l.sh; sh->ref(); }
    ~QValueList() { sh->derefAndDelete(); }

    QValueList<T>& operator= ( const QValueList<T>& l )
    {
	l.sh->ref();
	sh->derefAndDelete();
	sh = l.sh;
	return *this;
    }

    QValueList<T> operator+ ( const QValueList<T>& l ) const
    {
	QValueList<T> l2( *this );
	for( ConstIterator it = l.begin(); it != l.end(); ++it )
	    l2.append( *it );
	return l2;
    }

    QValueList<T>& operator+= ( const QValueList<T>& l )
    {
	for( ConstIterator it = l.begin(); it != l.end(); ++it )
	    append( *it );
	return *this;
    }

    bool operator== ( const QValueList<T>& l ) const
    {
	if ( count() != l.count() )
	    return FALSE;
	ConstIterator it2 = begin();
	ConstIterator it = l.begin();
	for( ; it != l.end(); ++it, ++it2 )
	    if ( !( *it == *it2 ) )
		return FALSE;
	return TRUE;
    }

    bool operator!= ( const QValueList<T>& l ) const { return !( *this == l ); }

    Iterator begin() { detach(); return Iterator( sh->node->next ); }
    ConstIterator begin() const { return ConstIterator( sh->node->next ); }
    Iterator end() { detach(); return Iterator( sh->node ); }
    ConstIterator end() const { return ConstIterator( sh->node ); }
    Iterator fromLast() { detach(); return Iterator( sh->node->prev ); }
    ConstIterator fromLast() const { return ConstIterator( sh->node->prev ); }

    bool isEmpty() const { return ( sh->nodes == 0 ); }

    Iterator insert( Iterator it, const T& x ) { detach(); return sh->insert( it, x ); }

    Iterator append( const T& x ) { detach(); return sh->insert( end(), x ); }
    Iterator prepend( const T& x ) { detach(); return sh->insert( begin(), x ); }

    Iterator remove( Iterator it ) { detach(); return sh->remove( it ); }
    void remove( const T& x ) { detach(); sh->remove( x ); }

    T& first() { detach(); return sh->node->next->data; }
    const T& first() const { return sh->node->next->data; }
    T& last() { detach(); return sh->node->prev->data; }
    const T& last() const { return sh->node->prev->data; }

    T& operator[] ( uint i ) { detach(); return sh->at(i)->data; }
    const T& operator[] ( uint i ) const { return sh->at(i)->data; }
    Iterator at( uint i ) { detach(); return Iterator( sh->at(i) ); }
    ConstIterator at( uint i ) const { return ConstIterator( sh->at(i) ); }
    Iterator find ( const T& x ) { detach(); return Iterator( sh->find( sh->node->next, x) ); }
    ConstIterator find ( const T& x ) const { return ConstIterator( sh->find( sh->node->next, x) ); }
    Iterator find ( Iterator it, const T& x ) { detach(); return Iterator( sh->find( it.node, x ) ); }
    ConstIterator find ( ConstIterator it, const T& x ) const { return ConstIterator( sh->find( it.node, x ) ); }
    int findIndex( const T& x ) const { return sh->findIndex( sh->node->next, x) ; }
    uint contains( const T& x ) const { return sh->contains( x ); }

    uint count() const { return sh->nodes; }

    void clear() { if ( sh->count == 1 ) sh->clear(); else { sh->deref(); sh = new QValueListPrivate<T>; } }


    QValueList<T>& operator+= ( const T& x )
    {
	append( x );
	return *this;
    }
    QValueList<T>& operator<< ( const T& x )
    {
	append( x );
	return *this;
    }


protected:
    


    void detach() { if ( sh->count > 1 ) { sh->deref(); sh = new QValueListPrivate<T>( *sh ); } }

    


    QValueListPrivate<T>* sh;
};


template<class T>
inline QDataStream& operator>>( QDataStream& s, QValueList<T>& l )
{
    l.clear();
    Q_UINT32 c;
    s >> c;
    for( Q_UINT32 i = 0; i < c; ++i )
    {
	T t;
	s >> t;
	l.append( t );
    }
    return s;
}

template<class T>
inline QDataStream& operator<<( QDataStream& s, const QValueList<T>& l )
{
    s << (Q_UINT32)l.count();
    QValueListConstIterator<T> it = l.begin();
    for( ; it != l.end(); ++it )
	s << *it;
    return s;
}
#line 449 "c:\\qt\\include\\qvaluelist.h"
#line 450 "c:\\qt\\include\\qvaluelist.h"
#line 251 "c:\\qt\\include\\qvariant.h"
#line 1 "c:\\qt\\include\\qstringlist.h"









































#line 1 "c:\\qt\\include\\qvaluelist.h"

































































































































































































































































































































































































































































#line 43 "c:\\qt\\include\\qstringlist.h"
#line 1 "c:\\qt\\include\\qstring.h"
























































































































































































































































































































































































































































































































































































































































































































































































































































#line 44 "c:\\qt\\include\\qstringlist.h"
#line 1 "c:\\qt\\include\\qregexp.h"









































#line 1 "c:\\qt\\include\\qstring.h"
























































































































































































































































































































































































































































































































































































































































































































































































































































#line 43 "c:\\qt\\include\\qregexp.h"
#line 44 "c:\\qt\\include\\qregexp.h"


class __declspec(dllimport) QRegExp
{
public:
    QRegExp();
    QRegExp( const QString &, bool caseSensitive=TRUE, bool wildcard=FALSE );
    QRegExp( const QRegExp & );
   ~QRegExp();
    QRegExp    &operator=( const QRegExp & );
    QRegExp    &operator=( const QString &pattern );

    bool	operator==( const QRegExp & )  const;
    bool	operator!=( const QRegExp &r ) const
					{ return !(this->operator==(r)); }

    bool	isEmpty()	const	{ return rxdata == 0; }
    bool	isValid()	const	{ return error == 0; }

    bool	caseSensitive() const	{ return cs; }
    void	setCaseSensitive( bool );

    bool	wildcard()	const	{ return wc; }
    void	setWildcard( bool );

    QString	pattern()	const	{ return rxstring; }
    
    void	setPattern( const QString& pattern )
					{ operator=( pattern ); }

    int		match( const QString &str, int index=0, int *len=0,
		       bool indexIsStart = TRUE ) const;
    int		find( const QString& str, int index )
					{ return match( str, index ); }

protected:
    void	compile();
    const QChar *matchstr( uint *, const QChar *, uint, const QChar * ) const;

private:
    QString	rxstring;			
    uint	*rxdata;			
    int		error;				
    bool	cs;				
    bool	wc;				
};


#line 93 "c:\\qt\\include\\qregexp.h"
#line 45 "c:\\qt\\include\\qstringlist.h"
#line 46 "c:\\qt\\include\\qstringlist.h"



class QStrList;

class __declspec(dllimport) QStringList : public QValueList<QString>
{
public:
    QStringList() { }
    QStringList( const QStringList& l ) : QValueList<QString>(l) { }
    QStringList( const QValueList<QString>& l ) : QValueList<QString>(l) { }
    QStringList( const QString& i ) { append(i); }

    QStringList( const char* i ) { append(i); }
#line 61 "c:\\qt\\include\\qstringlist.h"

    static QStringList fromStrList(const QStrList&);

    void sort();

    static QStringList split( const QString &sep, const QString &str, bool allowEmptyEntries = FALSE );
    static QStringList split(  const QChar &sep, const QString &str, bool allowEmptyEntries = FALSE );
    static QStringList split(  const QRegExp &sep, const QString &str, bool allowEmptyEntries = FALSE );
    QString join( const QString &sep ) const;

    QStringList grep( const QString &str, bool cs = TRUE ) const;
    QStringList grep( const QRegExp &expr ) const;
};


class QDataStream;
extern __declspec(dllimport) QDataStream &operator>>( QDataStream &, QStringList& );
extern __declspec(dllimport) QDataStream &operator<<( QDataStream &, const QStringList& );
#line 80 "c:\\qt\\include\\qstringlist.h"
#line 81 "c:\\qt\\include\\qstringlist.h"
#line 82 "c:\\qt\\include\\qstringlist.h"
#line 252 "c:\\qt\\include\\qvariant.h"
#line 1 "c:\\qt\\include\\qmap.h"









































#line 1 "c:\\qt\\include\\qshared.h"























































#line 43 "c:\\qt\\include\\qmap.h"
#line 1 "c:\\qt\\include\\qdatastream.h"













































































































































































#line 44 "c:\\qt\\include\\qmap.h"
#line 45 "c:\\qt\\include\\qmap.h"


struct QMapNodeBase
{
    enum Color { Red, Black };

    QMapNodeBase* left;
    QMapNodeBase* right;
    QMapNodeBase* parent;

    Color color;

    QMapNodeBase* minimum() {
	QMapNodeBase* x = this;
	while ( x->left )
	    x = x->left;
	return x;
    }

    QMapNodeBase* maximum() {
	QMapNodeBase* x = this;
	while ( x->right )
	    x = x->right;
	return x;
    }
};


template <class K, class T>
struct QMapNode : public QMapNodeBase
{
    QMapNode( const K& _key, const T& _data ) { data = _data; key = _key; }
    QMapNode( const K& _key )	   { key = _key; }
    QMapNode( const QMapNode<K,T>& _n ) { key = _n.key; data = _n.data; }
    QMapNode() { }
    T data;
    K key;
};


template<class K, class T>
class __declspec(dllimport) QMapIterator
{
 public:
    


    typedef QMapNode< K, T >* NodePtr;

    


    QMapNode<K,T>* node;

    


    QMapIterator() : node( 0 ) {}
    QMapIterator( QMapNode<K,T>* p ) : node( p ) {}
    QMapIterator( const QMapIterator<K,T>& it ) : node( it.node ) {}

    bool operator==( const QMapIterator<K,T>& it ) const { return node == it.node; }
    bool operator!=( const QMapIterator<K,T>& it ) const { return node != it.node; }
    T& operator*() { return node->data; }
    const T& operator*() const { return node->data; }

    
    

    const K& key() const { return node->key; }
    T& data() { return node->data; }
    const T& data() const { return node->data; }

private:
    int inc() {
	QMapNodeBase* tmp = node;
	if ( tmp->right ) {
	    tmp = tmp->right;
	    while ( tmp->left )
		tmp = tmp->left;
	} else {
	    QMapNodeBase* y = tmp->parent;
	    while (tmp == y->right) {
		tmp = y;
		y = y->parent;
	    }
	    if (tmp->right != y)
		tmp = y;
	}
	node = (NodePtr)tmp;
	return 0;
    }

    int dec() {
	QMapNodeBase* tmp = node;
	if (tmp->color == QMapNodeBase::Red &&
	    tmp->parent->parent == tmp ) {
	    tmp = tmp->right;
	} else if (tmp->left != 0) {
	    QMapNodeBase* y = tmp->left;
	    while ( y->right )
		y = y->right;
	    tmp = y;
	} else {
	    QMapNodeBase* y = tmp->parent;
	    while (tmp == y->left) {
		tmp = y;
		y = y->parent;
	    }
	    tmp = y;
	}
	node = (NodePtr)tmp;
	return 0;
    }

public:
    QMapIterator<K,T>& operator++() {
	inc();
	return *this;
    }

    QMapIterator<K,T> operator++(int) {
	QMapIterator<K,T> tmp = *this;
	inc();
	return tmp;
    }

    QMapIterator<K,T>& operator--() {
	dec();
	return *this;
    }

    QMapIterator<K,T> operator--(int) {
	QMapIterator<K,T> tmp = *this;
	dec();
	return tmp;
    }
};

template<class K, class T>
class __declspec(dllimport) QMapConstIterator
{
 public:
    


    typedef QMapNode< K, T >* NodePtr;

    


    QMapNode<K,T>* node;

    


    QMapConstIterator() : node( 0 ) {}
    QMapConstIterator( QMapNode<K,T>* p ) : node( p ) {}
    QMapConstIterator( const QMapConstIterator<K,T>& it ) : node( it.node ) {}
    QMapConstIterator( const QMapIterator<K,T>& it ) : node( it.node ) {}

    bool operator==( const QMapConstIterator<K,T>& it ) const { return node == it.node; }
    bool operator!=( const QMapConstIterator<K,T>& it ) const { return node != it.node; }
    const T& operator*()  const { return node->data; }

    
    

    const K& key() const { return node->key; }
    const T& data() const { return node->data; }

private:
    int inc() {
        QMapNodeBase* tmp = node;
	if ( tmp->right ) {
	    tmp = tmp->right;
	    while ( tmp->left )
		tmp = tmp->left;
	} else {
	    QMapNodeBase* y = tmp->parent;
	    while (tmp == y->right) {
		tmp = y;
		y = y->parent;
	    }
	    if (tmp->right != y)
		tmp = y;
	}
	node = (NodePtr)tmp;
	return 0;
    }

    int dec() {
	QMapNodeBase* tmp = node;
	if (tmp->color == QMapNodeBase::Red &&
	    tmp->parent->parent == tmp ) {
	    tmp = tmp->right;
	} else if (tmp->left != 0) {
	    QMapNodeBase* y = tmp->left;
	    while ( y->right )
		y = y->right;
	    tmp = y;
	} else {
	    QMapNodeBase* y = tmp->parent;
	    while (tmp == y->left) {
		tmp = y;
		y = y->parent;
	    }
	    tmp = y;
	}
	node = (NodePtr)tmp;
	return 0;
    }

public:
    QMapConstIterator<K,T>& operator++() {
	inc();
	return *this;
    }

    QMapConstIterator<K,T> operator++(int) {
	QMapConstIterator<K,T> tmp = *this;
	inc();
	return tmp;
    }

    QMapConstIterator<K,T>& operator--() {
	dec();
	return *this;
    }

    QMapConstIterator<K,T> operator--(int) {
	QMapConstIterator<K,T> tmp = *this;
	dec();
	return tmp;
    }
};


class __declspec(dllimport) QMapPrivateBase : public QShared
{
public:
    QMapPrivateBase() {
	node_count = 0;
    }
    QMapPrivateBase( const QMapPrivateBase* _map) {
	node_count = _map->node_count;
    }

    


    void rotateLeft( QMapNodeBase* x, QMapNodeBase*& root);
    void rotateRight( QMapNodeBase* x, QMapNodeBase*& root );
    void rebalance( QMapNodeBase* x, QMapNodeBase*& root );
    QMapNodeBase* removeAndRebalance( QMapNodeBase* z, QMapNodeBase*& root,
				      QMapNodeBase*& leftmost,
				      QMapNodeBase*& rightmost );

    


    int node_count;
};


template <class Key, class T>
class QMapPrivate : public QMapPrivateBase
{
public:
    


    typedef QMapIterator< Key, T > Iterator;
    typedef QMapConstIterator< Key, T > ConstIterator;
    typedef QMapNode< Key, T > Node;
    typedef QMapNode< Key, T >* NodePtr;

    


    QMapPrivate() {
	header = new Node;
	header->color = QMapNodeBase::Red; 
	header->parent = 0;
	header->left = header->right = header;
    }
    QMapPrivate( const QMapPrivate< Key, T >* _map ) : QMapPrivateBase( _map ) {
	header = new Node;
	header->color = QMapNodeBase::Red; 
	if ( _map->header->parent == 0 ) {
	    header->parent = 0;
	    header->left = header->right = header;
	} else {
	    header->parent = copy( (NodePtr)(_map->header->parent) );
	    header->parent->parent = header;
	    header->left = header->parent->minimum();
	    header->right = header->parent->maximum();
	}
    }
    ~QMapPrivate() { clear(); delete header; }

    NodePtr copy( NodePtr p ) {
	if ( !p )
	    return 0;
	NodePtr n = new Node( *p );
	n->color = p->color;
	if ( p->left ) {
	    n->left = copy( (NodePtr)(p->left) );
	    n->left->parent = n;
	} else {
	    n->left = 0;
	}
	if ( p->right ) {
	    n->right = copy( (NodePtr)(p->right) );
	    n->right->parent = n;
	} else {
	    n->right = 0;
	}
	return n;
    }

    void clear() {
	clear( (NodePtr)(header->parent) );
	header->color = QMapNodeBase::Red;
	header->parent = 0;
	header->left = header->right = header;
	node_count = 0;
    }

    void clear( NodePtr p ) {
	while ( p != 0 ) {
	    clear( (NodePtr)p->right );
	    NodePtr y = (NodePtr)p->left;
	    delete p;
	    p = y;
	}
    }

    Iterator begin()	{ return Iterator( (NodePtr)(header->left ) ); }
    Iterator end()	{ return Iterator( header ); }
    ConstIterator begin() const { return ConstIterator( (NodePtr)(header->left ) ); }
    ConstIterator end() const { return ConstIterator( header ); }

    ConstIterator find(const Key& k) const {
	QMapNodeBase* y = header;        
	QMapNodeBase* x = header->parent; 

	while ( x != 0 ) {
	    
	    if ( !( key(x) < k ) ) {
		y = x;
		x = x->left;
	    } else {
		x = x->right;
	    }
	}

	
	
	if ( y == header || k < key(y) )
	    return ConstIterator( header );
	return ConstIterator( (NodePtr)y );
    }

    void remove( Iterator it ) {
	NodePtr del = (NodePtr) removeAndRebalance( it.node, header->parent, header->left, header->right );
	delete del;
	--node_count;
    }













    Iterator insertMulti(const Key& v){
	QMapNodeBase* y = header;
	QMapNodeBase* x = header->parent;
	while (x != 0){
	    y = x;
	    x = ( v < key(x) ) ? x->left : x->right;
	}
	return insert(x, y, v);
    }

    Iterator insertSingle( const Key& k ) {
	
	QMapNodeBase* y = header;
	QMapNodeBase* x = header->parent;
	bool result = TRUE;
	while ( x != 0 ) {
	    result = ( k < key(x) );
	    y = x;
	    x = result ? x->left : x->right;
	}
	
	Iterator j( (NodePtr)y );
	if ( result ) {
	    
	    if ( j == begin() ) {
		return insert(x, y, k );
	    } else {
		
		--j;
	    }
	}
	
	if ( (j.node->key) < k )
	    return insert(x, y, k );
	
	return j;
    }

    Iterator insert( QMapNodeBase* x, QMapNodeBase* y, const Key& k ) {
	NodePtr z = new Node( k );
	if (y == header || x != 0 || k < key(y) ) {
	    y->left = z;                
	    if ( y == header ) {
		header->parent = z;
		header->right = z;
	    } else if ( y == header->left )
		header->left = z;           
	} else {
	    y->right = z;
	    if ( y == header->right )
		header->right = z;          
	}
	z->parent = y;
	z->left = 0;
	z->right = 0;
	rebalance( z, header->parent );
	++node_count;
	return Iterator(z);
    }

protected:
    


    const Key& key( QMapNodeBase* b ) const { return ((NodePtr)b)->key; }

    


    NodePtr header;
};


template<class Key, class T>
class __declspec(dllimport) QMap
{
public:
    


    typedef QMapIterator< Key, T > Iterator;
    typedef QMapConstIterator< Key, T > ConstIterator;
    typedef T ValueType;
    typedef QMapPrivate< Key, T > Priv;

    


    QMap() { sh = new QMapPrivate< Key, T >; }
    QMap( const QMap<Key,T>& m ) { sh = m.sh; sh->ref(); }
    ~QMap() { if ( sh->deref() ) delete sh; }

    QMap<Key,T>& operator= ( const QMap<Key,T>& m )
      { m.sh->ref(); if ( sh->deref() ) delete sh; sh = m.sh; return *this; }

    Iterator begin() { detach(); return sh->begin(); }
    Iterator end() { detach(); return sh->end(); }
    ConstIterator begin() const { return ((const Priv*)sh)->begin(); }
    ConstIterator end() const { return ((const Priv*)sh)->end(); }

    Iterator find ( const Key& k )
	{ detach(); return Iterator( sh->find( k ).node ); }
    ConstIterator find ( const Key& k ) const
	{ return sh->find( k ); }
    T& operator[] ( const Key& k ) {
	detach(); QMapNode<Key,T>* p = sh->find( k ).node;
	if ( p != sh->end().node ) return p->data;
	return insert( k, T() ).data(); }
    const T& operator[] ( const Key& k ) const
	{ return sh->find( k ).data(); }
    bool contains ( const Key& k ) const
	{ return find( k ) != end(); }
	

    uint count() const { return sh->node_count; }

    bool isEmpty() const { return sh->node_count == 0; }

    Iterator insert( const Key& key, const T& value ) {
        detach();
        Iterator it = sh->insertSingle( key );
        it.data() = value;
        return it;
    }

    void remove( Iterator it ) { detach(); sh->remove( it ); }
    void remove( const Key& k ) {
        detach();
        Iterator it( sh->find( k ).node );
        if ( it != end() )
            sh->remove( it );
    }

    Iterator replace( const Key& k, const T& v ) {
	remove( k );
	return insert( k, v );
    }

    void clear() { if ( sh->count == 1 ) sh->clear(); else { sh->deref(); sh = new QMapPrivate<Key,T>; } }



#line 570 "c:\\qt\\include\\qmap.h"

protected:
    


    void detach() { if ( sh->count > 1 ) { sh->deref(); sh = new QMapPrivate<Key,T>( sh ); } }

    Priv* sh;
};



template<class Key, class T>
inline QDataStream& operator>>( QDataStream& s, QMap<Key,T>& m ) {
    m.clear();
    Q_UINT32 c;
    s >> c;
    for( Q_UINT32 i = 0; i < c; ++i ) {
	Key k; T t;
	s >> k >> t;
	m.insert( k, t );
    }
    return s;
}


template<class Key, class T>
inline QDataStream& operator<<( QDataStream& s, const QMap<Key,T>& m ) {
    s << (Q_UINT32)m.count();
    QMapConstIterator<Key,T> it = m.begin();
    for( ; it != m.end(); ++it )
	s << it.key() << it.data();
    return s;
}
#line 605 "c:\\qt\\include\\qmap.h"

#line 607 "c:\\qt\\include\\qmap.h"
#line 253 "c:\\qt\\include\\qvariant.h"
#line 254 "c:\\qt\\include\\qvariant.h"

inline QVariant::Type QVariant::type() const
{
    return d->typ;
}

inline bool QVariant::isValid() const
{
    return (d->typ != Invalid);
}

inline QValueListConstIterator<QString> QVariant::stringListBegin() const
{
    if ( d->typ != StringList )
	return QValueListConstIterator<QString>();
    return ((const QStringList*)d->value.ptr)->begin();
}

inline QValueListConstIterator<QString> QVariant::stringListEnd() const
{
    if ( d->typ != StringList )
	return QValueListConstIterator<QString>();
    return ((const QStringList*)d->value.ptr)->end();
}

inline QValueListConstIterator<QVariant> QVariant::listBegin() const
{
    if ( d->typ != List )
	return QValueListConstIterator<QVariant>();
    return ((const QValueList<QVariant>*)d->value.ptr)->begin();
}

inline QValueListConstIterator<QVariant> QVariant::listEnd() const
{
    if ( d->typ != List )
	return QValueListConstIterator<QVariant>();
    return ((const QValueList<QVariant>*)d->value.ptr)->end();
}

inline QMapConstIterator<QString,QVariant> QVariant::mapBegin() const
{
    if ( d->typ != Map )
	return QMapConstIterator<QString,QVariant>();
    return ((const QMap<QString,QVariant>*)d->value.ptr)->begin();
}

inline QMapConstIterator<QString,QVariant> QVariant::mapEnd() const
{
    if ( d->typ != Map )
	return QMapConstIterator<QString,QVariant>();
    return ((const QMap<QString,QVariant>*)d->value.ptr)->end();
}

inline QMapConstIterator<QString,QVariant> QVariant::mapFind( const QString& key ) const
{
    if ( d->typ != Map )
	return QMapConstIterator<QString,QVariant>();
    return ((const QMap<QString,QVariant>*)d->value.ptr)->find( key );
}

__declspec(dllimport) QDataStream& operator>> ( QDataStream& s, QVariant& p );
__declspec(dllimport) QDataStream& operator<< ( QDataStream& s, const QVariant& p );
__declspec(dllimport) QDataStream& operator>> ( QDataStream& s, QVariant::Type& p );
__declspec(dllimport) QDataStream& operator<< ( QDataStream& s, const QVariant::Type p );

#line 320 "c:\\qt\\include\\qvariant.h"

#line 322 "c:\\qt\\include\\qvariant.h"
#line 13 "h:\\c_projekte\\elansim\\headview.h"
#line 1 "c:\\qt\\include\\qdialog.h"









































#line 1 "c:\\qt\\include\\qwidget.h"









































#line 1 "c:\\qt\\include\\qwindowdefs.h"










































#line 1 "c:\\qt\\include\\qobjectdefs.h"









































#line 1 "c:\\qt\\include\\qglobal.h"


























































































































































































































































































































































































































































































































































































































































#line 43 "c:\\qt\\include\\qobjectdefs.h"
#line 44 "c:\\qt\\include\\qobjectdefs.h"











#line 56 "c:\\qt\\include\\qobjectdefs.h"















 
 
 
 
 
 
 
 


 















#line 98 "c:\\qt\\include\\qobjectdefs.h"






#line 105 "c:\\qt\\include\\qobjectdefs.h"



#line 109 "c:\\qt\\include\\qobjectdefs.h"








class QObject;
class QMetaObject;
class QSignal;
class QConnection;
class QEvent;
struct QMetaData;
class QConnectionList;
class QConnectionListIt;
class QSignalDict;
class QSignalDictIt;
class QObjectList;
class QObjectListIt;
class QMemberDict;


#line 133 "c:\\qt\\include\\qobjectdefs.h"
#line 44 "c:\\qt\\include\\qwindowdefs.h"
#line 1 "c:\\qt\\include\\qstring.h"
























































































































































































































































































































































































































































































































































































































































































































































































































































#line 45 "c:\\qt\\include\\qwindowdefs.h"
#line 1 "c:\\qt\\include\\qnamespace.h"









































#line 1 "c:\\qt\\include\\qglobal.h"


























































































































































































































































































































































































































































































































































































































































#line 43 "c:\\qt\\include\\qnamespace.h"
#line 44 "c:\\qt\\include\\qnamespace.h"


class QColor;
class QCursor;


class __declspec(dllimport) Qt {
public:
    static QColor & color0;
    static QColor & color1;
    static QColor & black;
    static QColor & white;
    static QColor & darkGray;
    static QColor & gray;
    static QColor & lightGray;
    static QColor & red;
    static QColor & green;
    static QColor & blue;
    static QColor & cyan;
    static QColor & magenta;
    static QColor & yellow;
    static QColor & darkRed;
    static QColor & darkGreen;
    static QColor & darkBlue;
    static QColor & darkCyan;
    static QColor & darkMagenta;
    static QColor & darkYellow;

    
    enum ButtonState {				
	NoButton	= 0x0000,
	LeftButton	= 0x0001,
	RightButton	= 0x0002,
	MidButton	= 0x0004,
	MouseButtonMask = 0x0007,
	ShiftButton	= 0x0008,
	ControlButton   = 0x0010,
	AltButton	= 0x0020,
	KeyButtonMask	= 0x0038,
	Keypad		= 0x4000
    };

    
    enum Orientation {
        Horizontal,
	Vertical
    };

    

    
    enum AlignmentFlags {
	AlignLeft	= 0x0001,		
	AlignRight	= 0x0002,
	AlignHCenter	= 0x0004,
	AlignTop	= 0x0008,
	AlignBottom	= 0x0010,
	AlignVCenter	= 0x0020,
	AlignCenter	= AlignVCenter | AlignHCenter,

	SingleLine	= 0x0040,		
	DontClip	= 0x0080,
	ExpandTabs	= 0x0100,
	ShowPrefix	= 0x0200,
	WordBreak	= 0x0400,
	DontPrint	= 0x1000		
    };

    
    enum WidgetState {
	WState_Created		= 0x00000001,
	WState_Disabled		= 0x00000002,
	WState_Visible		= 0x00000004,
	WState_ForceHide	= 0x00000008,
	WState_OwnCursor	= 0x00000010,
	WState_MouseTracking	= 0x00000020,
	WState_CompressKeys	= 0x00000040,
	WState_BlockUpdates	= 0x00000080,
	WState_InPaintEvent	= 0x00000100,
	WState_Reparented	= 0x00000200,
	WState_ConfigPending	= 0x00000400,
	WState_Resized		= 0x00000800,
	WState_AutoMask		= 0x00001000,
	WState_Polished		= 0x00002000,
	WState_DND		= 0x00004000,
	WState_Modal		= 0x00008000,
	WState_Reserved1	= 0x00010000,
	WState_Reserved2	= 0x00020000,
	WState_Reserved3	= 0x00040000,
	WState_Maximized	= 0x00080000,
	WState_TranslateBackground = 0x00100000,
	WState_ForceDisabled	= 0x00200000,
	WState_Exposed		= 0x00400000
    };

    
    typedef uint WFlags;

    
    enum WidgetFlags {
	WType_TopLevel		= 0x00000001,	
	WType_Modal		= 0x00000002,
	WType_Popup		= 0x00000004,
	WType_Desktop		= 0x00000008,
	WType_Mask		= 0x0000000f,

	WStyle_Customize	= 0x00000010,	
	WStyle_NormalBorder	= 0x00000020,
	WStyle_DialogBorder	= 0x00000040,
	WStyle_NoBorder		= 0x00000000,
	WStyle_Title		= 0x00000080,
	WStyle_SysMenu		= 0x00000100,
	WStyle_Minimize		= 0x00000200,
	WStyle_Maximize		= 0x00000400,
	WStyle_MinMax		= WStyle_Minimize | WStyle_Maximize,
	WStyle_Tool		= 0x00000800,
	WStyle_StaysOnTop	= 0x00001000,
	WStyle_Dialog 		= 0x00002000,
	WStyle_ContextHelp	= 0x00004000,
	WStyle_NoBorderEx	= 0x00008000, 
	WStyle_Mask		= 0x0000fff0,

	WDestructiveClose	= 0x00010000,	
	WPaintDesktop		= 0x00020000,
	WPaintUnclipped		= 0x00040000,
	WPaintClever		= 0x00080000,
	WResizeNoErase		= 0x00100000,
	WMouseNoMask		= 0x00200000,
	WNorthWestGravity	= 0x00400000,
	WRepaintNoErase		= 0x00800000,
	WX11BypassWM		= 0x01000000,
	WGroupLeader 		= 0x02000000
    };

    
    

    enum ImageConversionFlags {
	ColorMode_Mask		= 0x00000003,
	AutoColor		= 0x00000000,
	ColorOnly		= 0x00000003,
	MonoOnly		= 0x00000002,
	

	AlphaDither_Mask	= 0x0000000c,
	ThresholdAlphaDither	= 0x00000000,
	OrderedAlphaDither	= 0x00000004,
	DiffuseAlphaDither	= 0x00000008,
	NoAlpha			= 0x0000000c, 

	Dither_Mask		= 0x00000030,
	DiffuseDither		= 0x00000000,
	OrderedDither		= 0x00000010,
	ThresholdDither		= 0x00000020,
	

	DitherMode_Mask		= 0x000000c0,
	AutoDither		= 0x00000000,
	PreferDither		= 0x00000040,
	AvoidDither		= 0x00000080
    };

    enum BGMode	{				
	TransparentMode,
	OpaqueMode
    };

    enum PaintUnit {				
	PixelUnit,
	LoMetricUnit, 
	HiMetricUnit, 
	LoEnglishUnit, 
	HiEnglishUnit, 
	TwipsUnit 
    };

    enum GUIStyle {
	MacStyle, 
	WindowsStyle,
	Win3Style, 
	PMStyle, 
	MotifStyle
    };

    enum Modifier {		
	SHIFT         = 0x00200000,
	CTRL          = 0x00400000,
	ALT           = 0x00800000,
	MODIFIER_MASK = 0x00e00000,
	UNICODE_ACCEL = 0x10000000,

	ASCII_ACCEL = UNICODE_ACCEL 
    };

    enum Key {
	Key_Escape = 0x1000,		
	Key_Tab = 0x1001,
	Key_Backtab = 0x1002, Key_BackTab = Key_Backtab,
	Key_Backspace = 0x1003, Key_BackSpace = Key_Backspace,
	Key_Return = 0x1004,
	Key_Enter = 0x1005,
	Key_Insert = 0x1006,
	Key_Delete = 0x1007,
	Key_Pause = 0x1008,
	Key_Print = 0x1009,
	Key_SysReq = 0x100a,
	Key_Home = 0x1010,		
	Key_End = 0x1011,
	Key_Left = 0x1012,
	Key_Up = 0x1013,
	Key_Right = 0x1014,
	Key_Down = 0x1015,
	Key_Prior = 0x1016, Key_PageUp = Key_Prior,
	Key_Next = 0x1017, Key_PageDown = Key_Next,
	Key_Shift = 0x1020,		
	Key_Control = 0x1021,
	Key_Meta = 0x1022,
	Key_Alt = 0x1023,
	Key_CapsLock = 0x1024,
	Key_NumLock = 0x1025,
	Key_ScrollLock = 0x1026,
	Key_F1 = 0x1030,		
	Key_F2 = 0x1031,
	Key_F3 = 0x1032,
	Key_F4 = 0x1033,
	Key_F5 = 0x1034,
	Key_F6 = 0x1035,
	Key_F7 = 0x1036,
	Key_F8 = 0x1037,
	Key_F9 = 0x1038,
	Key_F10 = 0x1039,
	Key_F11 = 0x103a,
	Key_F12 = 0x103b,
	Key_F13 = 0x103c,
	Key_F14 = 0x103d,
	Key_F15 = 0x103e,
	Key_F16 = 0x103f,
	Key_F17 = 0x1040,
	Key_F18 = 0x1041,
	Key_F19 = 0x1042,
	Key_F20 = 0x1043,
	Key_F21 = 0x1044,
	Key_F22 = 0x1045,
	Key_F23 = 0x1046,
	Key_F24 = 0x1047,
	Key_F25 = 0x1048,		
	Key_F26 = 0x1049,
	Key_F27 = 0x104a,
	Key_F28 = 0x104b,
	Key_F29 = 0x104c,
	Key_F30 = 0x104d,
	Key_F31 = 0x104e,
	Key_F32 = 0x104f,
	Key_F33 = 0x1050,
	Key_F34 = 0x1051,
	Key_F35 = 0x1052,
	Key_Super_L = 0x1053, 		
	Key_Super_R = 0x1054,
	Key_Menu = 0x1055,
	Key_Hyper_L = 0x1056,
	Key_Hyper_R = 0x1057,
	Key_Help = 0x1058,
	Key_Space = 0x20,		
	Key_Any = Key_Space,
	Key_Exclam = 0x21,
	Key_QuoteDbl = 0x22,
	Key_NumberSign = 0x23,
	Key_Dollar = 0x24,
	Key_Percent = 0x25,
	Key_Ampersand = 0x26,
	Key_Apostrophe = 0x27,
	Key_ParenLeft = 0x28,
	Key_ParenRight = 0x29,
	Key_Asterisk = 0x2a,
	Key_Plus = 0x2b,
	Key_Comma = 0x2c,
	Key_Minus = 0x2d,
	Key_Period = 0x2e,
	Key_Slash = 0x2f,
	Key_0 = 0x30,
	Key_1 = 0x31,
	Key_2 = 0x32,
	Key_3 = 0x33,
	Key_4 = 0x34,
	Key_5 = 0x35,
	Key_6 = 0x36,
	Key_7 = 0x37,
	Key_8 = 0x38,
	Key_9 = 0x39,
	Key_Colon = 0x3a,
	Key_Semicolon = 0x3b,
	Key_Less = 0x3c,
	Key_Equal = 0x3d,
	Key_Greater = 0x3e,
	Key_Question = 0x3f,
	Key_At = 0x40,
	Key_A = 0x41,
	Key_B = 0x42,
	Key_C = 0x43,
	Key_D = 0x44,
	Key_E = 0x45,
	Key_F = 0x46,
	Key_G = 0x47,
	Key_H = 0x48,
	Key_I = 0x49,
	Key_J = 0x4a,
	Key_K = 0x4b,
	Key_L = 0x4c,
	Key_M = 0x4d,
	Key_N = 0x4e,
	Key_O = 0x4f,
	Key_P = 0x50,
	Key_Q = 0x51,
	Key_R = 0x52,
	Key_S = 0x53,
	Key_T = 0x54,
	Key_U = 0x55,
	Key_V = 0x56,
	Key_W = 0x57,
	Key_X = 0x58,
	Key_Y = 0x59,
	Key_Z = 0x5a,
	Key_BracketLeft = 0x5b,
	Key_Backslash = 0x5c,
	Key_BracketRight = 0x5d,
	Key_AsciiCircum = 0x5e,
	Key_Underscore = 0x5f,
	Key_QuoteLeft = 0x60,
	Key_BraceLeft = 0x7b,
	Key_Bar = 0x7c,
	Key_BraceRight = 0x7d,
	Key_AsciiTilde = 0x7e,

	

	Key_nobreakspace = 0x0a0,
	Key_exclamdown = 0x0a1,
	Key_cent = 0x0a2,
	Key_sterling = 0x0a3,
	Key_currency = 0x0a4,
	Key_yen = 0x0a5,
	Key_brokenbar = 0x0a6,
	Key_section = 0x0a7,
	Key_diaeresis = 0x0a8,
	Key_copyright = 0x0a9,
	Key_ordfeminine = 0x0aa,
	Key_guillemotleft = 0x0ab,	
	Key_notsign = 0x0ac,
	Key_hyphen = 0x0ad,
	Key_registered = 0x0ae,
	Key_macron = 0x0af,
	Key_degree = 0x0b0,
	Key_plusminus = 0x0b1,
	Key_twosuperior = 0x0b2,
	Key_threesuperior = 0x0b3,
	Key_acute = 0x0b4,
	Key_mu = 0x0b5,
	Key_paragraph = 0x0b6,
	Key_periodcentered = 0x0b7,
	Key_cedilla = 0x0b8,
	Key_onesuperior = 0x0b9,
	Key_masculine = 0x0ba,
	Key_guillemotright = 0x0bb,	
	Key_onequarter = 0x0bc,
	Key_onehalf = 0x0bd,
	Key_threequarters = 0x0be,
	Key_questiondown = 0x0bf,
	Key_Agrave = 0x0c0,
	Key_Aacute = 0x0c1,
	Key_Acircumflex = 0x0c2,
	Key_Atilde = 0x0c3,
	Key_Adiaeresis = 0x0c4,
	Key_Aring = 0x0c5,
	Key_AE = 0x0c6,
	Key_Ccedilla = 0x0c7,
	Key_Egrave = 0x0c8,
	Key_Eacute = 0x0c9,
	Key_Ecircumflex = 0x0ca,
	Key_Ediaeresis = 0x0cb,
	Key_Igrave = 0x0cc,
	Key_Iacute = 0x0cd,
	Key_Icircumflex = 0x0ce,
	Key_Idiaeresis = 0x0cf,
	Key_ETH = 0x0d0,
	Key_Ntilde = 0x0d1,
	Key_Ograve = 0x0d2,
	Key_Oacute = 0x0d3,
	Key_Ocircumflex = 0x0d4,
	Key_Otilde = 0x0d5,
	Key_Odiaeresis = 0x0d6,
	Key_multiply = 0x0d7,
	Key_Ooblique = 0x0d8,
	Key_Ugrave = 0x0d9,
	Key_Uacute = 0x0da,
	Key_Ucircumflex = 0x0db,
	Key_Udiaeresis = 0x0dc,
	Key_Yacute = 0x0dd,
	Key_THORN = 0x0de,
	Key_ssharp = 0x0df,
	Key_agrave = 0x0e0,
	Key_aacute = 0x0e1,
	Key_acircumflex = 0x0e2,
	Key_atilde = 0x0e3,
	Key_adiaeresis = 0x0e4,
	Key_aring = 0x0e5,
	Key_ae = 0x0e6,
	Key_ccedilla = 0x0e7,
	Key_egrave = 0x0e8,
	Key_eacute = 0x0e9,
	Key_ecircumflex = 0x0ea,
	Key_ediaeresis = 0x0eb,
	Key_igrave = 0x0ec,
	Key_iacute = 0x0ed,
	Key_icircumflex = 0x0ee,
	Key_idiaeresis = 0x0ef,
	Key_eth = 0x0f0,
	Key_ntilde = 0x0f1,
	Key_ograve = 0x0f2,
	Key_oacute = 0x0f3,
	Key_ocircumflex = 0x0f4,
	Key_otilde = 0x0f5,
	Key_odiaeresis = 0x0f6,
	Key_division = 0x0f7,
	Key_oslash = 0x0f8,
	Key_ugrave = 0x0f9,
	Key_uacute = 0x0fa,
	Key_ucircumflex = 0x0fb,
	Key_udiaeresis = 0x0fc,
	Key_yacute = 0x0fd,
	Key_thorn = 0x0fe,
	Key_ydiaeresis = 0x0ff,

	Key_unknown = 0xffff
    };

    enum ArrowType {
	UpArrow,
	DownArrow,
	LeftArrow,
	RightArrow
    };

    
    enum RasterOp { 
	CopyROP,
	OrROP,
	XorROP,
	NotAndROP,
	EraseROP=NotAndROP,
	NotCopyROP,
	NotOrROP,
	NotXorROP,
	AndROP,	NotEraseROP=AndROP,
	NotROP,
	ClearROP,
	SetROP,
	NopROP,
	AndNotROP,
	OrNotROP,
	NandROP,
	NorROP,	LastROP=NorROP
    };

    
    enum PenStyle { 
	NoPen,
	SolidLine,
	DashLine,
	DotLine,
	DashDotLine,
	DashDotDotLine,
	MPenStyle = 0x0f
    };

    enum PenCapStyle { 
	FlatCap = 0x00,
	SquareCap = 0x10,
	RoundCap = 0x20,
	MPenCapStyle = 0x30
    };

    enum PenJoinStyle { 
	MiterJoin = 0x00,
	BevelJoin = 0x40,
	RoundJoin = 0x80,
	MPenJoinStyle = 0xc0
    };

    enum BrushStyle { 
	NoBrush,
	SolidPattern,
	Dense1Pattern,
	Dense2Pattern,
	Dense3Pattern,
	Dense4Pattern,
	Dense5Pattern,
	Dense6Pattern,
	Dense7Pattern,
	HorPattern,
	VerPattern,
	CrossPattern,
	BDiagPattern,
	FDiagPattern,
	DiagCrossPattern,
	CustomPattern=24
    };

    enum WindowsVersion {
	WV_32s 		= 0x0001,
	WV_95 		= 0x0002,
	WV_98		= 0x0003,
	WV_DOS_based	= 0x000f,

	WV_NT 		= 0x0010,
	WV_2000 	= 0x0020,
	WV_NT_based	= 0x00f0
    };

    enum UIEffect {
	UI_General,
	UI_AnimateMenu,
	UI_FadeMenu,
	UI_AnimateCombo,
	UI_AnimateTooltip,
	UI_FadeTooltip
    };


    

    static QCursor & arrowCursor;	
    static QCursor & upArrowCursor;	
    static QCursor & crossCursor;	
    static QCursor & waitCursor;	
    static QCursor & ibeamCursor;	
    static QCursor & sizeVerCursor;	
    static QCursor & sizeHorCursor;	
    static QCursor & sizeBDiagCursor;	
    static QCursor & sizeFDiagCursor;	
    static QCursor & sizeAllCursor;	
    static QCursor & blankCursor;	
    static QCursor & splitVCursor;	
						
    static QCursor & splitHCursor;	
						
    static QCursor & pointingHandCursor;	
    static QCursor & forbiddenCursor;	


    enum TextFormat {
	PlainText,
	RichText,
	AutoText
    };
};


class __declspec(dllimport) QInternal {
public:
    enum PaintDeviceFlags {
	UndefinedDevice = 0x00,
	Widget = 0x01,
	Pixmap = 0x02,
	Printer = 0x03,
	Picture = 0x04,
	System = 0x05,
	DeviceTypeMask = 0x0f,
	ExternalDevice = 0x10
    };
};

#line 616 "c:\\qt\\include\\qnamespace.h"
#line 46 "c:\\qt\\include\\qwindowdefs.h"
#line 47 "c:\\qt\\include\\qwindowdefs.h"

#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\limits.h"















#pragma once
#line 18 "c:\\programme\\microsoft visual studio\\vc98\\include\\limits.h"






#line 25 "c:\\programme\\microsoft visual studio\\vc98\\include\\limits.h"













#line 39 "c:\\programme\\microsoft visual studio\\vc98\\include\\limits.h"
















#line 56 "c:\\programme\\microsoft visual studio\\vc98\\include\\limits.h"





#line 62 "c:\\programme\\microsoft visual studio\\vc98\\include\\limits.h"





#line 68 "c:\\programme\\microsoft visual studio\\vc98\\include\\limits.h"








#line 77 "c:\\programme\\microsoft visual studio\\vc98\\include\\limits.h"








#line 86 "c:\\programme\\microsoft visual studio\\vc98\\include\\limits.h"
































#line 119 "c:\\programme\\microsoft visual studio\\vc98\\include\\limits.h"
#line 49 "c:\\qt\\include\\qwindowdefs.h"



class QPaintDevice;
class QPaintDeviceMetrics;
class QWidget;
class QWidgetMapper;
class QDialog;
class QColor;
class QColorGroup;
class QPalette;
class QCursor;
class QPoint;
class QSize;
class QRect;
class QPointArray;
class QPainter;
class QRegion;
class QFont;
class QFontMetrics;
class QFontInfo;
class QPen;
class QBrush;
class QWMatrix;
class QPixmap;
class QBitmap;
class QMovie;
class QImage;
class QImageIO;
class QPicture;
class QPrinter;
class QAccel;
class QTimer;
class QTime;
class QClipboard;




class QWidgetList;
class QWidgetListIt;










#line 101 "c:\\qt\\include\\qwindowdefs.h"



#line 1 "c:\\qt\\include\\qwindowdefs_win.h"


#line 4 "c:\\qt\\include\\qwindowdefs_win.h"




#line 9 "c:\\qt\\include\\qwindowdefs_win.h"



#line 13 "c:\\qt\\include\\qwindowdefs_win.h"

typedef void *HANDLE;





#line 21 "c:\\qt\\include\\qwindowdefs_win.h"











#line 33 "c:\\qt\\include\\qwindowdefs_win.h"

struct HINSTANCE__; typedef struct HINSTANCE__ *HINSTANCE;
struct HDC__; typedef struct HDC__ *HDC;
struct HWND__; typedef struct HWND__ *HWND;
struct HFONT__; typedef struct HFONT__ *HFONT;
struct HPEN__; typedef struct HPEN__ *HPEN;
struct HBRUSH__; typedef struct HBRUSH__ *HBRUSH;
struct HBITMAP__; typedef struct HBITMAP__ *HBITMAP;
struct HICON__; typedef struct HICON__ *HICON;
typedef HICON HCURSOR;
struct HPALETTE__; typedef struct HPALETTE__ *HPALETTE;
struct HRGN__; typedef struct HRGN__ *HRGN;

typedef struct tagMSG MSG;
typedef HWND  WId;


__declspec(dllimport) HINSTANCE qWinAppInst();
__declspec(dllimport) HINSTANCE qWinAppPrevInst();
__declspec(dllimport) int	   qWinAppCmdShow();
__declspec(dllimport) HDC	   qt_display_dc();















#line 70 "c:\\qt\\include\\qwindowdefs_win.h"
#line 105 "c:\\qt\\include\\qwindowdefs.h"
#line 106 "c:\\qt\\include\\qwindowdefs.h"



























#line 134 "c:\\qt\\include\\qwindowdefs.h"








#line 143 "c:\\qt\\include\\qwindowdefs.h"

class QApplication;



#line 149 "c:\\qt\\include\\qwindowdefs.h"




typedef Q_INT32 QCOORD;				
const QCOORD QCOORD_MAX =  2147483647;
const QCOORD QCOORD_MIN = -QCOORD_MAX - 1;

typedef unsigned int QRgb;			

__declspec(dllimport) char *qAppName();			




typedef void (*Q_CleanUpFunction)();
__declspec(dllimport) void qAddPostRoutine( Q_CleanUpFunction );
__declspec(dllimport) void qRemovePostRoutine( Q_CleanUpFunction );


__declspec(dllimport) void *qt_find_obj_child( QObject *, const char *, const char * );




#line 175 "c:\\qt\\include\\qwindowdefs.h"
#line 43 "c:\\qt\\include\\qwidget.h"
#line 1 "c:\\qt\\include\\qobject.h"









































#line 1 "c:\\qt\\include\\qobjectdefs.h"




































































































































#line 43 "c:\\qt\\include\\qobject.h"
#line 1 "c:\\qt\\include\\qwindowdefs.h"














































































































































































#line 44 "c:\\qt\\include\\qobject.h"
#line 1 "c:\\qt\\include\\qstring.h"
























































































































































































































































































































































































































































































































































































































































































































































































































































#line 45 "c:\\qt\\include\\qobject.h"
#line 1 "c:\\qt\\include\\qevent.h"









































#line 1 "c:\\qt\\include\\qwindowdefs.h"














































































































































































#line 43 "c:\\qt\\include\\qevent.h"
#line 1 "c:\\qt\\include\\qregion.h"









































#line 1 "c:\\qt\\include\\qshared.h"























































#line 43 "c:\\qt\\include\\qregion.h"
#line 1 "c:\\qt\\include\\qrect.h"









































#line 1 "c:\\qt\\include\\qsize.h"









































#line 1 "c:\\qt\\include\\qpoint.h"









































#line 1 "c:\\qt\\include\\qwindowdefs.h"














































































































































































#line 43 "c:\\qt\\include\\qpoint.h"
#line 44 "c:\\qt\\include\\qpoint.h"


class __declspec(dllimport) QPoint
{
public:
    QPoint();
    QPoint( int xpos, int ypos );

    bool   isNull()	const;

    int	   x()		const;
    int	   y()		const;
    void   setX( int x );
    void   setY( int y );

    int manhattanLength() const;

    QCOORD &rx();
    QCOORD &ry();

    QPoint &operator+=( const QPoint &p );
    QPoint &operator-=( const QPoint &p );
    QPoint &operator*=( int c );
    QPoint &operator*=( double c );
    QPoint &operator/=( int c );
    QPoint &operator/=( double c );

    friend inline bool	 operator==( const QPoint &, const QPoint & );
    friend inline bool	 operator!=( const QPoint &, const QPoint & );
    friend inline QPoint operator+( const QPoint &, const QPoint & );
    friend inline QPoint operator-( const QPoint &, const QPoint & );
    friend inline QPoint operator*( const QPoint &, int );
    friend inline QPoint operator*( int, const QPoint & );
    friend inline QPoint operator*( const QPoint &, double );
    friend inline QPoint operator*( double, const QPoint & );
    friend inline QPoint operator-( const QPoint & );
    friend inline QPoint operator/( const QPoint &, int );
    friend inline QPoint operator/( const QPoint &, double );

private:
    static void warningDivByZero();




#line 90 "c:\\qt\\include\\qpoint.h"
    QCOORD xp;
    QCOORD yp;
#line 93 "c:\\qt\\include\\qpoint.h"
};






__declspec(dllimport) QDataStream &operator<<( QDataStream &, const QPoint & );
__declspec(dllimport) QDataStream &operator>>( QDataStream &, QPoint & );
#line 103 "c:\\qt\\include\\qpoint.h"





inline QPoint::QPoint()
{ xp=0; yp=0; }

inline QPoint::QPoint( int xpos, int ypos )
{ xp=(QCOORD)xpos; yp=(QCOORD)ypos; }

inline bool QPoint::isNull() const
{ return xp == 0 && yp == 0; }

inline int QPoint::x() const
{ return xp; }

inline int QPoint::y() const
{ return yp; }

inline void QPoint::setX( int x )
{ xp = (QCOORD)x; }

inline void QPoint::setY( int y )
{ yp = (QCOORD)y; }

inline QCOORD &QPoint::rx()
{ return xp; }

inline QCOORD &QPoint::ry()
{ return yp; }

inline QPoint &QPoint::operator+=( const QPoint &p )
{ xp+=p.xp; yp+=p.yp; return *this; }

inline QPoint &QPoint::operator-=( const QPoint &p )
{ xp-=p.xp; yp-=p.yp; return *this; }

inline QPoint &QPoint::operator*=( int c )
{ xp*=(QCOORD)c; yp*=(QCOORD)c; return *this; }

inline QPoint &QPoint::operator*=( double c )
{ xp=(QCOORD)(xp*c); yp=(QCOORD)(yp*c); return *this; }

inline bool operator==( const QPoint &p1, const QPoint &p2 )
{ return p1.xp == p2.xp && p1.yp == p2.yp; }

inline bool operator!=( const QPoint &p1, const QPoint &p2 )
{ return p1.xp != p2.xp || p1.yp != p2.yp; }

inline QPoint operator+( const QPoint &p1, const QPoint &p2 )
{ return QPoint(p1.xp+p2.xp, p1.yp+p2.yp); }

inline QPoint operator-( const QPoint &p1, const QPoint &p2 )
{ return QPoint(p1.xp-p2.xp, p1.yp-p2.yp); }

inline QPoint operator*( const QPoint &p, int c )
{ return QPoint(p.xp*c, p.yp*c); }

inline QPoint operator*( int c, const QPoint &p )
{ return QPoint(p.xp*c, p.yp*c); }

inline QPoint operator*( const QPoint &p, double c )
{ return QPoint((QCOORD)(p.xp*c), (QCOORD)(p.yp*c)); }

inline QPoint operator*( double c, const QPoint &p )
{ return QPoint((QCOORD)(p.xp*c), (QCOORD)(p.yp*c)); }

inline QPoint operator-( const QPoint &p )
{ return QPoint(-p.xp, -p.yp); }

inline QPoint &QPoint::operator/=( int c )
{

    if ( c == 0 )
	warningDivByZero();
#line 180 "c:\\qt\\include\\qpoint.h"
    xp/=(QCOORD)c;
    yp/=(QCOORD)c;
    return *this;
}

inline QPoint &QPoint::operator/=( double c )
{

    if ( c == 0.0 )
	warningDivByZero();
#line 191 "c:\\qt\\include\\qpoint.h"
    xp=(QCOORD)(xp/c);
    yp=(QCOORD)(yp/c);
    return *this;
}

inline QPoint operator/( const QPoint &p, int c )
{

    if ( c == 0 )
	QPoint::warningDivByZero();
#line 202 "c:\\qt\\include\\qpoint.h"
    return QPoint(p.xp/c, p.yp/c);
}

inline QPoint operator/( const QPoint &p, double c )
{

    if ( c == 0.0 )
	QPoint::warningDivByZero();
#line 211 "c:\\qt\\include\\qpoint.h"
    return QPoint((QCOORD)(p.xp/c), (QCOORD)(p.yp/c));
}


#line 216 "c:\\qt\\include\\qpoint.h"
#line 43 "c:\\qt\\include\\qsize.h"
#line 44 "c:\\qt\\include\\qsize.h"


class __declspec(dllimport) QSize
{
public:
    QSize();
    QSize( int w, int h );

    bool   isNull()	const;
    bool   isEmpty()	const;
    bool   isValid()	const;

    int	   width()	const;
    int	   height()	const;
    void   setWidth( int w );
    void   setHeight( int h );
    void   transpose();

    QSize expandedTo( const QSize & ) const;
    QSize boundedTo( const QSize & ) const;

    QCOORD &rwidth();
    QCOORD &rheight();

    QSize &operator+=( const QSize & );
    QSize &operator-=( const QSize & );
    QSize &operator*=( int c );
    QSize &operator*=( double c );
    QSize &operator/=( int c );
    QSize &operator/=( double c );

    friend inline bool	operator==( const QSize &, const QSize & );
    friend inline bool	operator!=( const QSize &, const QSize & );
    friend inline QSize operator+( const QSize &, const QSize & );
    friend inline QSize operator-( const QSize &, const QSize & );
    friend inline QSize operator*( const QSize &, int );
    friend inline QSize operator*( int, const QSize & );
    friend inline QSize operator*( const QSize &, double );
    friend inline QSize operator*( double, const QSize & );
    friend inline QSize operator/( const QSize &, int );
    friend inline QSize operator/( const QSize &, double );

private:
    static void warningDivByZero();

    QCOORD wd;
    QCOORD ht;
};






__declspec(dllimport) QDataStream &operator<<( QDataStream &, const QSize & );
__declspec(dllimport) QDataStream &operator>>( QDataStream &, QSize & );






inline QSize::QSize()
{ wd = ht = -1; }

inline QSize::QSize( int w, int h )
{ wd=(QCOORD)w; ht=(QCOORD)h; }

inline bool QSize::isNull() const
{ return wd==0 && ht==0; }

inline bool QSize::isEmpty() const
{ return wd<1 || ht<1; }

inline bool QSize::isValid() const
{ return wd>=0 && ht>=0; }

inline int QSize::width() const
{ return wd; }

inline int QSize::height() const
{ return ht; }

inline void QSize::setWidth( int w )
{ wd=(QCOORD)w; }

inline void QSize::setHeight( int h )
{ ht=(QCOORD)h; }

inline QCOORD &QSize::rwidth()
{ return wd; }

inline QCOORD &QSize::rheight()
{ return ht; }

inline QSize &QSize::operator+=( const QSize &s )
{ wd+=s.wd; ht+=s.ht; return *this; }

inline QSize &QSize::operator-=( const QSize &s )
{ wd-=s.wd; ht-=s.ht; return *this; }

inline QSize &QSize::operator*=( int c )
{ wd*=(QCOORD)c; ht*=(QCOORD)c; return *this; }

inline QSize &QSize::operator*=( double c )
{ wd=(QCOORD)(wd*c); ht=(QCOORD)(ht*c); return *this; }

inline bool operator==( const QSize &s1, const QSize &s2 )
{ return s1.wd == s2.wd && s1.ht == s2.ht; }

inline bool operator!=( const QSize &s1, const QSize &s2 )
{ return s1.wd != s2.wd || s1.ht != s2.ht; }

inline QSize operator+( const QSize & s1, const QSize & s2 )
{ return QSize(s1.wd+s2.wd, s1.ht+s2.ht); }

inline QSize operator-( const QSize &s1, const QSize &s2 )
{ return QSize(s1.wd-s2.wd, s1.ht-s2.ht); }

inline QSize operator*( const QSize &s, int c )
{ return QSize(s.wd*c, s.ht*c); }

inline QSize operator*( int c, const QSize &s )
{  return QSize(s.wd*c, s.ht*c); }

inline QSize operator*( const QSize &s, double c )
{ return QSize((QCOORD)(s.wd*c), (QCOORD)(s.ht*c)); }

inline QSize operator*( double c, const QSize &s )
{ return QSize((QCOORD)(s.wd*c), (QCOORD)(s.ht*c)); }

inline QSize &QSize::operator/=( int c )
{

    if ( c == 0 )
	warningDivByZero();
#line 181 "c:\\qt\\include\\qsize.h"
    wd/=(QCOORD)c; ht/=(QCOORD)c;
    return *this;
}

inline QSize &QSize::operator/=( double c )
{

    if ( c == 0.0 )
	warningDivByZero();
#line 191 "c:\\qt\\include\\qsize.h"
    wd=(QCOORD)(wd/c); ht=(QCOORD)(ht/c);
    return *this;
}

inline QSize operator/( const QSize &s, int c )
{

    if ( c == 0 )
	QSize::warningDivByZero();
#line 201 "c:\\qt\\include\\qsize.h"
    return QSize(s.wd/c, s.ht/c);
}

inline QSize operator/( const QSize &s, double c )
{

    if ( c == 0.0 )
	QSize::warningDivByZero();
#line 210 "c:\\qt\\include\\qsize.h"
    return QSize((QCOORD)(s.wd/c), (QCOORD)(s.ht/c));
}

inline QSize QSize::expandedTo( const QSize & otherSize ) const
{
    return QSize( ((wd) > (otherSize.wd) ? (wd) : (otherSize.wd)), ((ht) > (otherSize.ht) ? (ht) : (otherSize.ht)) );
}

inline QSize QSize::boundedTo( const QSize & otherSize ) const
{
    return QSize( ((wd) < (otherSize.wd) ? (wd) : (otherSize.wd)), ((ht) < (otherSize.ht) ? (ht) : (otherSize.ht)) );
}


#line 225 "c:\\qt\\include\\qsize.h"
#line 43 "c:\\qt\\include\\qrect.h"
#line 44 "c:\\qt\\include\\qrect.h"




#line 49 "c:\\qt\\include\\qrect.h"

class __declspec(dllimport) QRect					
{
public:
    QRect()	{ x1 = y1 = 0; x2 = y2 = -1; }
    QRect( const QPoint &topleft, const QPoint &bottomright );
    QRect( const QPoint &topleft, const QSize &size );
    QRect( int left, int top, int width, int height );

    bool   isNull()	const;
    bool   isEmpty()	const;
    bool   isValid()	const;
    QRect  normalize()	const;

    int	   left()	const;
    int	   top()	const;
    int	   right()	const;
    int	   bottom()	const;

    QCOORD &rLeft();
    QCOORD &rTop();
    QCOORD &rRight();
    QCOORD &rBottom();
	
    int	   x()		const;
    int	   y()		const;
    void   setLeft( int pos );
    void   setTop( int pos );
    void   setRight( int pos );
    void   setBottom( int pos );
    void   setX( int x );
    void   setY( int y );

    QPoint topLeft()	 const;
    QPoint bottomRight() const;
    QPoint topRight()	 const;
    QPoint bottomLeft()	 const;
    QPoint center()	 const;

    void   rect( int *x, int *y, int *w, int *h ) const;
    void   coords( int *x1, int *y1, int *x2, int *y2 ) const;

    void   moveTopLeft( const QPoint &p );
    void   moveBottomRight( const QPoint &p );
    void   moveTopRight( const QPoint &p );
    void   moveBottomLeft( const QPoint &p );
    void   moveCenter( const QPoint &p );
    void   moveBy( int dx, int dy );

    void   setRect( int x, int y, int w, int h );
    void   setCoords( int x1, int y1, int x2, int y2 );

    QSize  size()	const;
    int	   width()	const;
    int	   height()	const;
    void   setWidth( int w );
    void   setHeight( int h );
    void   setSize( const QSize &s );

    QRect  operator|(const QRect &r) const;
    QRect  operator&(const QRect &r) const;
    QRect&  operator|=(const QRect &r);
    QRect&  operator&=(const QRect &r);

    bool   contains( const QPoint &p, bool proper=FALSE ) const;
    bool   contains( int x, int y, bool proper=FALSE ) const;
    bool   contains( const QRect &r, bool proper=FALSE ) const;
    QRect  unite( const QRect &r ) const;
    QRect  intersect( const QRect &r ) const;
    bool   intersects( const QRect &r ) const;

    friend __declspec(dllimport) bool operator==( const QRect &, const QRect & );
    friend __declspec(dllimport) bool operator!=( const QRect &, const QRect & );

private:





#line 130 "c:\\qt\\include\\qrect.h"
    QCOORD x1;
    QCOORD y1;
    QCOORD x2;
    QCOORD y2;
#line 135 "c:\\qt\\include\\qrect.h"
};

__declspec(dllimport) bool operator==( const QRect &, const QRect & );
__declspec(dllimport) bool operator!=( const QRect &, const QRect & );






__declspec(dllimport) QDataStream &operator<<( QDataStream &, const QRect & );
__declspec(dllimport) QDataStream &operator>>( QDataStream &, QRect & );
#line 148 "c:\\qt\\include\\qrect.h"





inline QRect::QRect( int left, int top, int width, int height )
{
    x1 = (QCOORD)left;
    y1 = (QCOORD)top;
    x2 = (QCOORD)(left+width-1);
    y2 = (QCOORD)(top+height-1);
}

inline bool QRect::isNull() const
{ return x2 == x1-1 && y2 == y1-1; }

inline bool QRect::isEmpty() const
{ return x1 > x2 || y1 > y2; }

inline bool QRect::isValid() const
{ return x1 <= x2 && y1 <= y2; }

inline int QRect::left() const
{ return x1; }

inline int QRect::top() const
{ return y1; }

inline int QRect::right() const
{ return x2; }

inline int QRect::bottom() const
{ return y2; }

inline QCOORD &QRect::rLeft()
{ return x1; }

inline QCOORD & QRect::rTop()
{ return y1; }

inline QCOORD & QRect::rRight()
{ return x2; }

inline QCOORD & QRect::rBottom()
{ return y2; }

inline int QRect::x() const
{ return x1; }

inline int QRect::y() const
{ return y1; }

inline void QRect::setLeft( int pos )
{ x1 = (QCOORD)pos; }

inline void QRect::setTop( int pos )
{ y1 = (QCOORD)pos; }

inline void QRect::setRight( int pos )
{ x2 = (QCOORD)pos; }

inline void QRect::setBottom( int pos )
{ y2 = (QCOORD)pos; }

inline void QRect::setX( int x )
{ x1 = (QCOORD)x; }

inline void QRect::setY( int y )
{ y1 = (QCOORD)y; }

inline QPoint QRect::topLeft() const
{ return QPoint(x1, y1); }

inline QPoint QRect::bottomRight() const
{ return QPoint(x2, y2); }

inline QPoint QRect::topRight() const
{ return QPoint(x2, y1); }

inline QPoint QRect::bottomLeft() const
{ return QPoint(x1, y2); }

inline QPoint QRect::center() const
{ return QPoint((x1+x2)/2, (y1+y2)/2); }

inline int QRect::width() const
{ return  x2 - x1 + 1; }

inline int QRect::height() const
{ return  y2 - y1 + 1; }

inline QSize QRect::size() const
{ return QSize(x2-x1+1, y2-y1+1); }

inline bool QRect::contains( int x, int y, bool proper ) const
{
    if ( proper )
        return x > x1 && x < x2 &&
               y > y1 && y < y2;
    else
        return x >= x1 && x <= x2 &&
               y >= y1 && y <= y2;
}

#line 253 "c:\\qt\\include\\qrect.h"
#line 44 "c:\\qt\\include\\qregion.h"
#line 1 "c:\\qt\\include\\qstring.h"
























































































































































































































































































































































































































































































































































































































































































































































































































































#line 45 "c:\\qt\\include\\qregion.h"
#line 46 "c:\\qt\\include\\qregion.h"


class __declspec(dllimport) QRegion
{
public:
    enum RegionType { Rectangle, Ellipse };

    QRegion();
    QRegion( int x, int y, int w, int h, RegionType = Rectangle );
    QRegion( const QRect &, RegionType = Rectangle );
    QRegion( const QPointArray &, bool winding=FALSE );
    QRegion( const QRegion & );
    QRegion( const QBitmap & );
   ~QRegion();
    QRegion &operator=( const QRegion & );

    bool    isNull()   const;
    bool    isEmpty()  const;

    bool    contains( const QPoint &p ) const;
    bool    contains( const QRect &r )	const;

    void    translate( int dx, int dy );

    QRegion unite( const QRegion & )	const;
    QRegion intersect( const QRegion &) const;
    QRegion subtract( const QRegion & ) const;
    QRegion eor( const QRegion & )	const;

    QRect   boundingRect() const;
    QArray<QRect> rects() const;
    void setRects( const QRect *, int );

    QRegion operator|( const QRegion & ) const;
    QRegion operator+( const QRegion & ) const;
    QRegion operator&( const QRegion & ) const;
    QRegion operator-( const QRegion & ) const;
    QRegion operator^( const QRegion & ) const;
    QRegion& operator|=( const QRegion & );
    QRegion& operator+=( const QRegion & );
    QRegion& operator&=( const QRegion & );
    QRegion& operator-=( const QRegion & );
    QRegion& operator^=( const QRegion & );

    bool    operator==( const QRegion & )  const;
    bool    operator!=( const QRegion &r ) const
			{ return !(operator==(r)); }


    HRGN    handle() const { return data->rgn; }







#line 104 "c:\\qt\\include\\qregion.h"


    friend __declspec(dllimport) QDataStream &operator<<( QDataStream &, const QRegion & );
    friend __declspec(dllimport) QDataStream &operator>>( QDataStream &, QRegion & );
#line 109 "c:\\qt\\include\\qregion.h"
private:
    QRegion( bool );
    QRegion copy() const;
    void    detach();

    QRegion winCombine( const QRegion &, int ) const;
#line 116 "c:\\qt\\include\\qregion.h"
    void    exec( const QByteArray &, int ver = 0 );
    struct QRegionData : public QShared {

	HRGN   rgn;






#line 127 "c:\\qt\\include\\qregion.h"
	bool   is_null;
    } *data;
};



















__declspec(dllimport) QDataStream &operator<<( QDataStream &, const QRegion & );
__declspec(dllimport) QDataStream &operator>>( QDataStream &, QRegion & );
#line 152 "c:\\qt\\include\\qregion.h"


#line 155 "c:\\qt\\include\\qregion.h"
#line 44 "c:\\qt\\include\\qevent.h"
#line 1 "c:\\qt\\include\\qnamespace.h"







































































































































































































































































































































































































































































































































































































































#line 45 "c:\\qt\\include\\qevent.h"
#line 1 "c:\\qt\\include\\qmime.h"









































#line 1 "c:\\qt\\include\\qwindowdefs.h"














































































































































































#line 43 "c:\\qt\\include\\qmime.h"
#line 44 "c:\\qt\\include\\qmime.h"



class __declspec(dllimport) QMimeSource {
public:
    virtual ~QMimeSource();
    virtual const char* format( int n = 0 ) const = 0;
    virtual bool provides( const char* ) const;
    virtual QByteArray encodedData( const char* ) const = 0;
};

class QMimeSourceFactoryData;
class QStringList;

class __declspec(dllimport) QMimeSourceFactory {
public:
    QMimeSourceFactory();
    virtual ~QMimeSourceFactory();

    static QMimeSourceFactory* defaultFactory();
    static void setDefaultFactory( QMimeSourceFactory* );

    virtual const QMimeSource* data(const QString& abs_name) const;
    virtual QString makeAbsolute(const QString& abs_or_rel_name, const QString& context) const;
    const QMimeSource* data(const QString& abs_or_rel_name, const QString& context) const;

    virtual void setText( const QString& abs_name, const QString& text );
    virtual void setImage( const QString& abs_name, const QImage& im );
    virtual void setPixmap( const QString& abs_name, const QPixmap& pm );
    virtual void setData( const QString& abs_name, QMimeSource* data );
    virtual void setFilePath( const QStringList& );
    virtual QStringList filePath() const;
    void addFilePath( const QString& );
    virtual void setExtensionType( const QString& ext, const char* mimetype );

private:
    QMimeSourceFactoryData* d;
};





#line 1 "c:\\qt\\include\\qlist.h"









































#line 1 "c:\\qt\\include\\qglist.h"









































#line 1 "c:\\qt\\include\\qcollection.h"









































#line 1 "c:\\qt\\include\\qglobal.h"


























































































































































































































































































































































































































































































































































































































































#line 43 "c:\\qt\\include\\qcollection.h"
#line 44 "c:\\qt\\include\\qcollection.h"


class QGVector;
class QGList;
class QGDict;


class __declspec(dllimport) QCollection			
{
public:
    bool autoDelete()	const	       { return del_item; }
    void setAutoDelete( bool enable )  { del_item = enable; }

    virtual uint  count() const = 0;
    virtual void  clear() = 0;			

    typedef void *Item;				

protected:
    QCollection() { del_item = FALSE; }		
    QCollection(const QCollection &) { del_item = FALSE; }
    virtual ~QCollection() {}

    bool del_item;				

    virtual Item     newItem( Item );		
    virtual void     deleteItem( Item );	
};


#line 75 "c:\\qt\\include\\qcollection.h"
#line 43 "c:\\qt\\include\\qglist.h"
#line 44 "c:\\qt\\include\\qglist.h"






class __declspec(dllimport) QLNode
{
friend class QGList;
friend class QGListIterator;
public:
    QCollection::Item getData()	{ return data; }
private:
    QCollection::Item data;
    QLNode *prev;
    QLNode *next;
    QLNode( QCollection::Item d ) { data = d; }
};






class __declspec(dllimport) QGList : public QCollection	
{
friend class QGListIterator;
friend class QGVector;				
public:
    uint  count() const;			


    QDataStream &read( QDataStream & );		
    QDataStream &write( QDataStream & ) const;	
#line 79 "c:\\qt\\include\\qglist.h"
protected:
    QGList();					
    QGList( const QGList & );			
    virtual ~QGList();

    QGList &operator=( const QGList & );	
    bool operator==( const QGList& ) const;

    void inSort( QCollection::Item );		
    void append( QCollection::Item );		
    bool insertAt( uint index, QCollection::Item ); 
    void relinkNode( QLNode * );		
    bool removeNode( QLNode * );		
    bool remove( QCollection::Item = 0 );	
    bool removeRef( QCollection::Item = 0 );	
    bool removeFirst();				
    bool removeLast();				
    bool removeAt( uint index );		
    QCollection::Item takeNode( QLNode * );	
    QCollection::Item take();			
    QCollection::Item takeAt( uint index );	
    QCollection::Item takeFirst();		
    QCollection::Item takeLast();		

    void sort();                        
    void clear();			

    int	 findRef( QCollection::Item, bool = TRUE ); 
    int	 find( QCollection::Item, bool = TRUE ); 

    uint containsRef( QCollection::Item ) const; 
    uint contains( QCollection::Item )	const;	

    QCollection::Item at( uint index );		
    int	  at() const;				
    QLNode *currentNode() const;		

    QCollection::Item get() const;		

    QCollection::Item cfirst() const;	
    QCollection::Item clast()  const;	
    QCollection::Item first();		
    QCollection::Item last();		
    QCollection::Item next();		
    QCollection::Item prev();		

    void  toVector( QGVector * ) const;		

    virtual int compareItems( QCollection::Item, QCollection::Item );


    virtual QDataStream &read( QDataStream &, QCollection::Item & );
    virtual QDataStream &write( QDataStream &, QCollection::Item ) const;
#line 133 "c:\\qt\\include\\qglist.h"
private:
    void  prepend( QCollection::Item ); 

    void heapSortPushDown( QCollection::Item* heap, int first, int last );

    QLNode *firstNode;				
    QLNode *lastNode;				
    QLNode *curNode;				
    int	    curIndex;				
    uint    numNodes;				
    QGList *iterators;				

    QLNode *locate( uint );			
    QLNode *unlink();				
};


inline uint QGList::count() const
{
    return numNodes;
}

inline bool QGList::removeFirst()
{
    first();
    return remove();
}

inline bool QGList::removeLast()
{
    last();
    return remove();
}

inline int QGList::at() const
{
    return curIndex;
}

inline QCollection::Item QGList::at( uint index )
{
    QLNode *n = locate( index );
    return n ? n->data : 0;
}

inline QLNode *QGList::currentNode() const
{
    return curNode;
}

inline QCollection::Item QGList::get() const
{
    return curNode ? curNode->data : 0;
}

inline QCollection::Item QGList::cfirst() const
{
    return firstNode ? firstNode->data : 0;
}

inline QCollection::Item QGList::clast() const
{
    return lastNode ? lastNode->data : 0;
}







__declspec(dllimport) QDataStream &operator>>( QDataStream &, QGList & );
__declspec(dllimport) QDataStream &operator<<( QDataStream &, const QGList & );
#line 207 "c:\\qt\\include\\qglist.h"





class __declspec(dllimport) QGListIterator			
{
friend class QGList;
protected:
    QGListIterator( const QGList & );
    QGListIterator( const QGListIterator & );
    QGListIterator &operator=( const QGListIterator & );
   ~QGListIterator();

    bool  atFirst() const;			
    bool  atLast()  const;			
    QCollection::Item	  toFirst();				
    QCollection::Item	  toLast();				

    QCollection::Item	  get() const;				
    QCollection::Item	  operator()();				
    QCollection::Item	  operator++();				
    QCollection::Item	  operator+=(uint);			
    QCollection::Item	  operator--();				
    QCollection::Item	  operator-=(uint);			

protected:
    QGList *list;				

private:
    QLNode  *curNode;				
};


inline bool QGListIterator::atFirst() const
{
    return curNode == list->firstNode;
}

inline bool QGListIterator::atLast() const
{
    return curNode == list->lastNode;
}

inline QCollection::Item QGListIterator::get() const
{
    return curNode ? curNode->data : 0;
}


#line 258 "c:\\qt\\include\\qglist.h"
#line 43 "c:\\qt\\include\\qlist.h"
#line 44 "c:\\qt\\include\\qlist.h"


template<class type> class __declspec(dllimport) QList : public QGList
{
public:
    QList()				{}
    QList( const QList<type> &l ) : QGList(l) {}
   ~QList()				{ clear(); }
    QList<type> &operator=(const QList<type> &l)
			{ return (QList<type>&)QGList::operator=(l); }
    bool operator==( const QList<type> &list ) const
    { return QGList::operator==( list ); }
    uint  count()   const		{ return QGList::count(); }
    bool  isEmpty() const		{ return QGList::count() == 0; }
    bool  insert( uint i, const type *d){ return QGList::insertAt(i,(QCollection::Item)d); }
    void  inSort( const type *d )	{ QGList::inSort((QCollection::Item)d); }
    void  prepend( const type *d )	{ QGList::insertAt(0,(QCollection::Item)d); }
    void  append( const type *d )	{ QGList::append((QCollection::Item)d); }
    bool  remove( uint i )		{ return QGList::removeAt(i); }
    bool  remove()			{ return QGList::remove((QCollection::Item)0); }
    bool  remove( const type *d )	{ return QGList::remove((QCollection::Item)d); }
    bool  removeRef( const type *d )	{ return QGList::removeRef((QCollection::Item)d); }
    void  removeNode( QLNode *n )	{ QGList::removeNode(n); }
    bool  removeFirst()			{ return QGList::removeFirst(); }
    bool  removeLast()			{ return QGList::removeLast(); }
    type *take( uint i )		{ return (type *)QGList::takeAt(i); }
    type *take()			{ return (type *)QGList::take(); }
    type *takeNode( QLNode *n )		{ return (type *)QGList::takeNode(n); }
    void  clear()			{ QGList::clear(); }
    void  sort()			{ QGList::sort(); }
    int	  find( const type *d )		{ return QGList::find((QCollection::Item)d); }
    int	  findNext( const type *d )	{ return QGList::find((QCollection::Item)d,FALSE); }
    int	  findRef( const type *d )	{ return QGList::findRef((QCollection::Item)d); }
    int	  findNextRef( const type *d ){ return QGList::findRef((QCollection::Item)d,FALSE);}
    uint  contains( const type *d ) const { return QGList::contains((QCollection::Item)d); }
    uint  containsRef( const type *d ) const
					{ return QGList::containsRef((QCollection::Item)d); }
    type *at( uint i )			{ return (type *)QGList::at(i); }
    int	  at() const			{ return QGList::at(); }
    type *current()  const		{ return (type *)QGList::get(); }
    QLNode *currentNode()  const	{ return QGList::currentNode(); }
    type *getFirst() const		{ return (type *)QGList::cfirst(); }
    type *getLast()  const		{ return (type *)QGList::clast(); }
    type *first()			{ return (type *)QGList::first(); }
    type *last()			{ return (type *)QGList::last(); }
    type *next()			{ return (type *)QGList::next(); }
    type *prev()			{ return (type *)QGList::prev(); }
    void  toVector( QGVector *vec )const{ QGList::toVector(vec); }
private:
    void  deleteItem( QCollection::Item d );
};





#line 101 "c:\\qt\\include\\qlist.h"

template<class type> inline void QList<type>::deleteItem( QCollection::Item d )
{
    if ( del_item ) delete (type *)d;
}


template<class type> class __declspec(dllimport) QListIterator : public QGListIterator
{
public:
    QListIterator(const QList<type> &l) :QGListIterator((QGList &)l) {}
   ~QListIterator()	      {}
    uint  count()   const     { return list->count(); }
    bool  isEmpty() const     { return list->count() == 0; }
    bool  atFirst() const     { return QGListIterator::atFirst(); }
    bool  atLast()  const     { return QGListIterator::atLast(); }
    type *toFirst()	      { return (type *)QGListIterator::toFirst(); }
    type *toLast()	      { return (type *)QGListIterator::toLast(); }
    operator type *() const   { return (type *)QGListIterator::get(); }
    type *operator*()         { return (type *)QGListIterator::get(); }

    
    
    
    
    

    type *current()   const   { return (type *)QGListIterator::get(); }
    type *operator()()	      { return (type *)QGListIterator::operator()();}
    type *operator++()	      { return (type *)QGListIterator::operator++(); }
    type *operator+=(uint j)  { return (type *)QGListIterator::operator+=(j);}
    type *operator--()	      { return (type *)QGListIterator::operator--(); }
    type *operator-=(uint j)  { return (type *)QGListIterator::operator-=(j);}
    QListIterator<type>& operator=(const QListIterator<type>&it)
			      { QGListIterator::operator=(it); return *this; }
};


#line 140 "c:\\qt\\include\\qlist.h"
#line 88 "c:\\qt\\include\\qmime.h"
#line 89 "c:\\qt\\include\\qmime.h"







class __declspec(dllimport) QWindowsMime {
public:
    QWindowsMime();
    virtual ~QWindowsMime();

    static void initialize();

    static QList<QWindowsMime> all();
    static QWindowsMime* convertor( const char* mime, int cf );
    static const char* cfToMime(int cf);

    static int registerMimeType(const char *mime);

    virtual const char* convertorName()=0;
    virtual int countCf()=0;
    virtual int cf(int index)=0;
    virtual bool canConvert( const char* mime, int cf )=0;
    virtual const char* mimeFor(int cf)=0;
    virtual int cfFor(const char* )=0;
    virtual QByteArray convertToMime( QByteArray data, const char* mime, int cf )=0;
    virtual QByteArray convertFromMime( QByteArray data, const char* mime, int cf )=0;
};

#line 120 "c:\\qt\\include\\qmime.h"

#line 122 "c:\\qt\\include\\qmime.h"

#line 124 "c:\\qt\\include\\qmime.h"
#line 46 "c:\\qt\\include\\qevent.h"
#line 47 "c:\\qt\\include\\qevent.h"


class __declspec(dllimport) QEvent: public Qt		
{
public:
    enum Type {

	
	
	
	

	None = 0,				


	Timer = 1,				
	MouseButtonPress = 2,			
	MouseButtonRelease = 3,			
	MouseButtonDblClick= 4,			
	MouseMove = 5,				
	KeyPress = 6,				
	KeyRelease = 7,				
	FocusIn = 8,				
	FocusOut = 9,				
	Enter = 10,				
	Leave = 11,				
	Paint = 12,				
	Move = 13,				
	Resize = 14,				
	Create = 15,				
	Destroy = 16,				
	Show = 17,				
	Hide = 18,				
	Close = 19,				
	Quit = 20,				
	Reparent = 21,				
	ShowMinimized = 22,		       	
	ShowNormal = 23,	       		
	WindowActivate = 24,	       		
	WindowDeactivate = 25,	       		
	ShowToParent = 26,	       		
	HideToParent = 27,	       		
	ShowMaximized = 28,		       	
	Accel = 30,				
	Wheel = 31,				
	AccelAvailable = 32,			
	CaptionChange = 33,			
	IconChange = 34,			
	ParentFontChange = 35,			
	ApplicationFontChange = 36,		
	ParentPaletteChange = 37,		
	ApplicationPaletteChange = 38,		
	Clipboard = 40,				
	Speech = 42,				
	SockAct = 50,				
	AccelOverride = 51,			
	DragEnter = 60,				
	DragMove = 61,				
	DragLeave = 62,				
	Drop = 63,				
	DragResponse = 64,			
	ChildInserted = 70,			
	ChildRemoved = 71,			
	LayoutHint = 72,			
	ShowWindowRequest = 73,			
	ActivateControl = 80,			
	DeactivateControl = 81,			
	User = 1000				
    };

    QEvent( Type type ) : t(type), posted(FALSE) {}
    virtual ~QEvent();
    Type  type() const	{ return t; }
protected:
    Type  t;
private:
    bool  posted;

    friend class QEvent;
#line 127 "c:\\qt\\include\\qevent.h"

    friend class QApplication;
    friend class QBaseApplication;
};


class __declspec(dllimport) QTimerEvent : public QEvent
{
public:
    QTimerEvent( int timerId )
	: QEvent(Timer), id(timerId) {}
    int	  timerId()	const	{ return id; }
protected:
    int	  id;
};


class __declspec(dllimport) QMouseEvent : public QEvent
{
public:
    QMouseEvent( Type type, const QPoint &pos, int button, int state );

    QMouseEvent( Type type, const QPoint &pos, const QPoint&globalPos,
		 int button, int state )
	: QEvent(type), p(pos), g(globalPos), b(button),s((ushort)state) {};

    const QPoint &pos() const	{ return p; }
    const QPoint &globalPos() const { return g; }
    int	   x()		const	{ return p.x(); }
    int	   y()		const	{ return p.y(); }
    int	   globalX()	const	{ return g.x(); }
    int	   globalY()	const	{ return g.y(); }
    ButtonState button() const	{ return (ButtonState) b; }
    ButtonState state()	const	{ return (ButtonState) s; }
    ButtonState stateAfter() const;
protected:
    QPoint p;
    QPoint g;
    int	   b; 
    ushort s; 
};



class __declspec(dllimport) QWheelEvent : public QEvent
{
public:
    QWheelEvent( const QPoint &pos, int delta, int state );
    QWheelEvent( const QPoint &pos, const QPoint& globalPos, int delta, int state )
	: QEvent(Wheel), p(pos), g(globalPos), d(delta), s((ushort)state),
	  accpt(TRUE) {}
    int	   delta()	const	{ return d; }
    const QPoint &pos() const	{ return p; }
    const QPoint &globalPos() const	{ return g; }
    int	   x()		const	{ return p.x(); }
    int	   y()		const	{ return p.y(); }
    int	   globalX()	const	{ return g.x(); }
    int	   globalY()	const	{ return g.y(); }
    ButtonState state()	const	{ return ButtonState(s); }
    bool   isAccepted() const	{ return accpt; }
    void   accept()		{ accpt = TRUE; }
    void   ignore()		{ accpt = FALSE; }
protected:
    QPoint p;
    QPoint g;
    int d;
    ushort s;
    bool   accpt;
};


class __declspec(dllimport) QKeyEvent : public QEvent
{
public:
    QKeyEvent( Type type, int key, int ascii, int state,
		const QString& text=QString::null, bool autorep=FALSE, ushort count=1 )
	: QEvent(type), txt(text), k((ushort)key), s((ushort)state),
	    a((uchar)ascii), accpt(TRUE), autor(autorep), c(count) {}
    int	   key()	const	{ return k; }
    int	   ascii()	const	{ return a; }
    ButtonState state()	const	{ return ButtonState(s); }
    ButtonState stateAfter() const;
    bool   isAccepted() const	{ return accpt; }
    QString text()      const   { return txt; }
    bool   isAutoRepeat() const	{ return autor; }
    int   count() const	{ return int(c); }
    void   accept()		{ accpt = TRUE; }
    void   ignore()		{ accpt = FALSE; }

protected:
    QString txt;
    ushort k, s;
    uchar  a;
    uint   accpt:1;
    uint   autor:1;
    ushort c;
};


class __declspec(dllimport) QFocusEvent : public QEvent
{
public:

    QFocusEvent( Type type )
	: QEvent(type) {}

    bool   gotFocus()	const { return type() == FocusIn; }
    bool   lostFocus()	const { return type() == FocusOut; }

    enum Reason { Mouse, Tab, ActiveWindow, Popup, Shortcut, Other };
    static Reason reason();
    static void setReason( Reason reason );
    static void resetReason();

private:
    static Reason m_reason;
    static Reason prev_reason;
};


class __declspec(dllimport) QPaintEvent : public QEvent
{
public:
    QPaintEvent( const QRegion& paintRegion, bool erased = TRUE)
	: QEvent(Paint),
	  rec(paintRegion.boundingRect()),
	  reg(paintRegion),
	  erase(erased){}
    QPaintEvent( const QRect &paintRect, bool erased = TRUE )
	: QEvent(Paint),
	  rec(paintRect),
	  reg(paintRect),
	  erase(erased){}
    const QRect &rect() const	  { return rec; }
    const QRegion &region() const { return reg; }
    bool erased() const { return erase; }
protected:
    friend class QApplication;
    friend class QBaseApplication;
    QRect rec;
    QRegion reg;
    bool erase;
};


class __declspec(dllimport) QMoveEvent : public QEvent
{
public:
    QMoveEvent( const QPoint &pos, const QPoint &oldPos )
	: QEvent(Move), p(pos), oldp(oldPos) {}
    const QPoint &pos()	  const { return p; }
    const QPoint &oldPos()const { return oldp;}
protected:
    QPoint p, oldp;
    friend class QApplication;
    friend class QBaseApplication;
};


class __declspec(dllimport) QResizeEvent : public QEvent
{
public:
    QResizeEvent( const QSize &size, const QSize &oldSize )
	: QEvent(Resize), s(size), olds(oldSize) {}
    const QSize &size()	  const { return s; }
    const QSize &oldSize()const { return olds;}
protected:
    QSize s, olds;
    friend class QApplication;
    friend class QBaseApplication;
};


class __declspec(dllimport) QCloseEvent : public QEvent
{
public:
    QCloseEvent()
	: QEvent(Close), accpt(FALSE) {}
    bool   isAccepted() const	{ return accpt; }
    void   accept()		{ accpt = TRUE; }
    void   ignore()		{ accpt = FALSE; }
protected:
    bool   accpt;
};


class __declspec(dllimport) QShowEvent : public QEvent
{
public:
    QShowEvent(bool spontaneous)
	: QEvent(Show), spont(spontaneous) {}
    bool spontaneous() const { return spont; }
protected:
    bool spont;
};


class __declspec(dllimport) QHideEvent : public QEvent
{
public:
    QHideEvent(bool spontaneous)
	: QEvent(Hide), spont(spontaneous) {}
    bool spontaneous() const { return spont; }
protected:
    bool spont;
};







class __declspec(dllimport) QDropEvent : public QEvent, public QMimeSource
{
public:
    QDropEvent( const QPoint& pos, Type typ=Drop )
	: QEvent(typ), p(pos),
	  act(0), accpt(0), accptact(0), resv(0),
	  d(0)
	{}
    const QPoint &pos() const	{ return p; }
    bool isAccepted() const	{ return accpt || accptact; }
    void accept(bool y=TRUE)	{ accpt = y; }
    void ignore()		{ accpt = FALSE; }

    bool isActionAccepted() const { return accptact; }
    void acceptAction(bool y=TRUE) { accptact = y; }
    enum Action { Copy, Link, Move, Private, UserAction=100 };
    void setAction( Action a ) { act = (uint)a; }
    Action action() const { return Action(act); }

    QWidget* source() const;
    const char* format( int n = 0 ) const;
    QByteArray encodedData( const char* ) const;
    bool provides( const char* ) const;

    QByteArray data(const char* f) const { return encodedData(f); }

    void setPoint( const QPoint& np ) { p = np; }

protected:
    QPoint p;
    uint act:8;
    uint accpt:1;
    uint accptact:1;
    uint resv:5;
    void * d;
};



class __declspec(dllimport) QDragMoveEvent : public QDropEvent
{
public:
    QDragMoveEvent( const QPoint& pos, Type typ=DragMove )
	: QDropEvent(pos,typ),
	  rect( pos, QSize( 1, 1 ) ) {}
    QRect answerRect() const { return rect; }
    void accept( bool y=TRUE ) { QDropEvent::accept(y); }
    void accept( const QRect & r) { accpt = TRUE; rect = r; }
    void ignore( const QRect & r) { accpt =FALSE; rect = r; }
    void ignore()		{ QDropEvent::ignore(); }

protected:
    QRect rect;
};


class __declspec(dllimport) QDragEnterEvent : public QDragMoveEvent
{
public:
    QDragEnterEvent( const QPoint& pos ) :
	QDragMoveEvent(pos, DragEnter) { }
};



class __declspec(dllimport) QDragResponseEvent : public QEvent
{
public:
    QDragResponseEvent( bool accepted )
	: QEvent(DragResponse), a(accepted) {}
    bool   dragAccepted() const	{ return a; }
protected:
    bool a;
};


class __declspec(dllimport) QDragLeaveEvent : public QEvent
{
public:
    QDragLeaveEvent()
	: QEvent(DragLeave) {}
};

#line 424 "c:\\qt\\include\\qevent.h"

class __declspec(dllimport) QChildEvent : public QEvent
{
public:
    QChildEvent( Type type, QObject *child )
	: QEvent(type), c(child) {}
    QObject *child() const	{ return c; }
    bool inserted() const { return t == ChildInserted; }
    bool removed() const { return t == ChildRemoved; }
protected:
    QObject *c;
};


class __declspec(dllimport) QCustomEvent : public QEvent
{
public:
    QCustomEvent( int type );
    QCustomEvent( Type type, void *data )
	: QEvent(type), d(data) {};
    void       *data()	const	{ return d; }
    void	setData( void* data )	{ d = data; }
private:
    void       *d;
};

#line 451 "c:\\qt\\include\\qevent.h"
#line 46 "c:\\qt\\include\\qobject.h"
#line 1 "c:\\qt\\include\\qnamespace.h"







































































































































































































































































































































































































































































































































































































































#line 47 "c:\\qt\\include\\qobject.h"
#line 1 "c:\\qt\\include\\qstringlist.h"

















































































#line 48 "c:\\qt\\include\\qobject.h"
#line 49 "c:\\qt\\include\\qobject.h"




class QMetaObject;
class QVariant;



class __declspec(dllimport) QObject: public Qt
{
    

public:
    QObject( QObject *parent=0, const char *name=0 );
    virtual ~QObject();

    static QString tr( const char * );
    static QString tr( const char *, const char * );

    virtual bool event( QEvent * );
    virtual bool eventFilter( QObject *, QEvent * );

    virtual QMetaObject *metaObject() const { return staticMetaObject(); }
    virtual const char	*className()  const;

    bool	 isA( const char * )	 const;
    bool	 inherits( const char * ) const;

    const char  *name() const;
    const char  *name( const char * defaultName ) const;

    virtual void setName( const char *name );
    bool	 isWidgetType()	  const { return isWidget; }
    bool	 highPriority()	  const { return FALSE; }

    bool	 signalsBlocked()  const { return blockSig; }
    void	 blockSignals( bool b );

    int		 startTimer( int interval );
    void	 killTimer( int id );
    void	 killTimers();

    QObject           *child( const char *name, const char *type = 0 );
    const QObjectList *children() const { return childObjects; }

    static const QObjectList *objectTrees();

    
    QObjectList	      *queryList( const char *inheritsClass = 0,
				  const char *objName = 0,
				  bool regexpMatch = TRUE,
				  bool recursiveSearch = TRUE );

    virtual void insertChild( QObject * );
    virtual void removeChild( QObject * );

    void	 installEventFilter( const QObject * );
    void	 removeEventFilter( const QObject * );

    static bool  connect( const QObject *sender, const char *signal,
			  const QObject *receiver, const char *member );
    bool	 connect( const QObject *sender, const char *signal,
			  const char *member ) const;
    static bool  disconnect( const QObject *sender, const char *signal,
			     const QObject *receiver, const char *member );
    bool	 disconnect( const char *signal=0,
			     const QObject *receiver=0, const char *member=0 );
    bool	 disconnect( const QObject *receiver, const char *member=0 );

    void	 dumpObjectTree();
    void	 dumpObjectInfo();


    bool setProperty( const char *name, const QVariant& value ); 
    QVariant property( const char *name ) const;    
#line 126 "c:\\qt\\include\\qobject.h"

protected:
    void	 destroyed();

public:
    QObject	*parent() const { return parentObj; }

private :
    void	 cleanupEventFilter();

protected:
    bool	 activate_filters( QEvent * );
    QConnectionList *receivers( const char *signal ) const;
    void	 activate_signal( const char *signal );
    void	 activate_signal( const char *signal, short );
    void	 activate_signal( const char *signal, int );
    void	 activate_signal( const char *signal, long );
    void	 activate_signal( const char *signal, const char * );
    void	 activate_signal_bool( const char *signal, bool );
    void	 activate_signal_string( const char *signal, QString );
    void	 activate_signal_strref( const char *signal, const QString & );

    const QObject *sender();


    virtual void initMetaObject();
    static QMetaObject* staticMetaObject();

    virtual void timerEvent( QTimerEvent * );
    virtual void childEvent( QChildEvent * );

    virtual void connectNotify( const char *signal );
    virtual void disconnectNotify( const char *signal );
    virtual bool checkConnectArgs( const char *signal, const QObject *receiver,
				   const char *member );
    static QCString normalizeSignalSlot( const char *signalSlot );

    static  void badSuperclassWarning( const char *className,
				       const char *superclassName );

private:
    uint	isSignal   : 1;
    uint	isWidget   : 1;
    uint	pendTimer  : 1;
    uint	pendEvent  : 1;
    uint	blockSig   : 1;
    uint	wasDeleted : 1;
    uint	isTree : 1;

    QMetaObject *queryMetaObject() const;
    static QMetaObject *metaObj;
    const char	*objname;
    QObject	*parentObj;
    QObjectList *childObjects;
    QSignalDict *connections;
    QObjectList *senderObjects;
    QObjectList *eventFilters;
    

    QObject	*sigSender;

    friend class QApplication;
    friend class QBaseApplication;
    friend class QWidget;
    friend class QSignal;
    friend class QSenderObject;

private:	



#line 198 "c:\\qt\\include\\qobject.h"

public:
    

    QStringList  superClasses( bool includeThis = FALSE ) const; 
#line 204 "c:\\qt\\include\\qobject.h"
};

#line 207 "c:\\qt\\include\\qobject.h"

inline bool QObject::connect( const QObject *sender, const char *signal,
			      const char *member ) const
{
    return connect( sender, signal, this, member );
}

inline bool QObject::disconnect( const char *signal,
				 const QObject *receiver, const char *member )
{
    return disconnect( this, signal, receiver, member );
}

inline bool QObject::disconnect( const QObject *receiver, const char *member )
{
    return disconnect( this, 0, receiver, member );
}

inline const QObject *QObject::sender()
{
    return sigSender;
}


class __declspec(dllimport) QSenderObject : public QObject		
{
public:
    void setSender( QObject *s ) { sigSender=s; }
};











#line 248 "c:\\qt\\include\\qobject.h"
#line 44 "c:\\qt\\include\\qwidget.h"
#line 1 "c:\\qt\\include\\qpaintdevice.h"









































#line 1 "c:\\qt\\include\\qwindowdefs.h"














































































































































































#line 43 "c:\\qt\\include\\qpaintdevice.h"
#line 1 "c:\\qt\\include\\qrect.h"




























































































































































































































































#line 44 "c:\\qt\\include\\qpaintdevice.h"
#line 45 "c:\\qt\\include\\qpaintdevice.h"




#line 50 "c:\\qt\\include\\qpaintdevice.h"

class QIODevice;
class QString;




#line 58 "c:\\qt\\include\\qpaintdevice.h"

union QPDevCmdParam {
    int			 ival;
    int			*ivec;
    QString	        *str;
    const QPoint	*point;
    const QRect		*rect;
    const QPointArray	*ptarr;
    const QPixmap	*pixmap;
    const QImage	*image;
    const QColor	*color;
    const QFont		*font;
    const QPen		*pen;
    const QBrush	*brush;
    const QRegion	*rgn;
    const QWMatrix	*matrix;
    QIODevice		*device;
};



class __declspec(dllimport) QPaintDevice				
{
public:
    virtual ~QPaintDevice();

    int		devType() const;
    bool	isExtDev() const;
    bool	paintingActive() const;

    
    

    HDC		handle() const;






#line 99 "c:\\qt\\include\\qpaintdevice.h"























#line 123 "c:\\qt\\include\\qpaintdevice.h"






#line 130 "c:\\qt\\include\\qpaintdevice.h"

    enum PDevCmd {
	PdcNOP = 0, 
	PdcDrawPoint = 1, 
	PdcDrawFirst = PdcDrawPoint,
	PdcMoveTo = 2, 
	PdcLineTo = 3, 
	PdcDrawLine = 4, 
	PdcDrawRect = 5, 
	PdcDrawRoundRect = 6, 
	PdcDrawEllipse = 7, 
	PdcDrawArc = 8, 
	PdcDrawPie = 9, 
	PdcDrawChord = 10, 
	PdcDrawLineSegments = 11, 
	PdcDrawPolyline = 12, 
	PdcDrawPolygon = 13, 
	PdcDrawQuadBezier = 14, 
	PdcDrawText = 15, 
	PdcDrawTextFormatted = 16, 
	PdcDrawPixmap = 17, 
	PdcDrawImage = 18, 
	PdcDrawText2 = 19, 
	PdcDrawText2Formatted = 20, 
	PdcDrawLast = PdcDrawText2Formatted,

	

	PdcBegin = 30, 
	PdcEnd = 31, 
	PdcSave = 32, 
	PdcRestore = 33, 
	PdcSetdev = 34, 
	PdcSetBkColor = 40, 
	PdcSetBkMode = 41, 
	PdcSetROP = 42, 
	PdcSetBrushOrigin = 43, 
	PdcSetFont = 45, 
	PdcSetPen = 46, 
	PdcSetBrush = 47, 
	PdcSetTabStops = 48, 
	PdcSetTabArray = 49, 
	PdcSetUnit = 50, 
	PdcSetVXform = 51, 
	PdcSetWindow = 52, 
	PdcSetViewport = 53, 
	PdcSetWXform = 54, 
	PdcSetWMatrix = 55, 
	PdcSaveWMatrix = 56,
	PdcRestoreWMatrix = 57,
	PdcSetClip = 60, 
	PdcSetClipRegion = 61, 

	PdcReservedStart = 0, 
	PdcReservedStop = 199 
    };

protected:
    QPaintDevice( uint devflags );


    HDC		hdc;				










#line 203 "c:\\qt\\include\\qpaintdevice.h"

    virtual bool cmd( int, QPainter *, QPDevCmdParam * );
    virtual int	 metric( int ) const;
    virtual int	 fontMet( QFont *, int, const char * = 0, int = 0 ) const;
    virtual int	 fontInf( QFont *, int ) const;

    ushort	devFlags;			
    ushort	painters;			

    friend class QPainter;
    friend class QPaintDeviceMetrics;
    friend __declspec(dllimport) void bitBlt( QPaintDevice *, int, int,
				 const QPaintDevice *,
				 int, int, int, int, Qt::RasterOp, bool );


#line 220 "c:\\qt\\include\\qpaintdevice.h"

private:











#line 234 "c:\\qt\\include\\qpaintdevice.h"

private:	



#line 240 "c:\\qt\\include\\qpaintdevice.h"
};


__declspec(dllimport)
void bitBlt( QPaintDevice *dst, int dx, int dy,
	     const QPaintDevice *src, int sx=0, int sy=0, int sw=-1, int sh=-1,
	     Qt::RasterOp = Qt::CopyROP, bool ignoreMask=FALSE );

__declspec(dllimport)
void bitBlt( QPaintDevice *dst, int dx, int dy,
	     const QImage *src, int sx=0, int sy=0, int sw=-1, int sh=-1,
	     int conversion_flags=0 );















#line 268 "c:\\qt\\include\\qpaintdevice.h"





inline int QPaintDevice::devType() const
{ return devFlags & QInternal::DeviceTypeMask; }

inline bool QPaintDevice::isExtDev() const
{ return (devFlags & QInternal::ExternalDevice) != 0; }

inline bool QPaintDevice::paintingActive() const
{ return painters != 0; }


inline HDC    QPaintDevice::handle() const { return hdc; }


#line 287 "c:\\qt\\include\\qpaintdevice.h"

















































#line 337 "c:\\qt\\include\\qpaintdevice.h"


__declspec(dllimport)
inline void bitBlt( QPaintDevice *dst, const QPoint &dp,
		    const QPaintDevice *src, const QRect &sr =QRect(0,0,-1,-1),
		    Qt::RasterOp rop=Qt::CopyROP, bool ignoreMask=FALSE )
{
    bitBlt( dst, dp.x(), dp.y(), src, sr.x(), sr.y(), sr.width(), sr.height(),
	    rop, ignoreMask );
}




#line 352 "c:\\qt\\include\\qpaintdevice.h"
#line 45 "c:\\qt\\include\\qwidget.h"
#line 1 "c:\\qt\\include\\qpalette.h"









































#line 1 "c:\\qt\\include\\qwindowdefs.h"














































































































































































#line 43 "c:\\qt\\include\\qpalette.h"
#line 1 "c:\\qt\\include\\qcolor.h"









































#line 1 "c:\\qt\\include\\qwindowdefs.h"














































































































































































#line 43 "c:\\qt\\include\\qcolor.h"
#line 44 "c:\\qt\\include\\qcolor.h"

const QRgb  RGB_DIRTY	= 0x80000000;		
const QRgb  RGB_INVALID = 0x40000000;		
const QRgb  RGB_DIRECT	= 0x20000000;		
const QRgb  RGB_MASK	= 0x00ffffff;		


__declspec(dllimport) inline int qRed( QRgb rgb )		
{ return (int)((rgb >> 16) & 0xff); }

__declspec(dllimport) inline int qGreen( QRgb rgb )		
{ return (int)((rgb >> 8) & 0xff); }

__declspec(dllimport) inline int qBlue( QRgb rgb )		
{ return (int)(rgb & 0xff); }

__declspec(dllimport) inline int qAlpha( QRgb rgb )		
{ return (int)((rgb >> 24) & 0xff); }

__declspec(dllimport) inline QRgb qRgb( int r, int g, int b )
{ return (0xff << 24) | ((r & 0xff) << 16) | ((g & 0xff) << 8) | (b & 0xff); }

__declspec(dllimport) inline QRgb qRgba( int r, int g, int b, int a )
{ return ((a & 0xff) << 24) | ((r & 0xff) << 16) | ((g & 0xff) << 8) | (b & 0xff); }

__declspec(dllimport) inline int qGray( int r, int g, int b )
{ return (r*11+g*16+b*5)/32; }

__declspec(dllimport) inline int qGray( QRgb rgb )		
{ return qGray( qRed(rgb), qGreen(rgb), qBlue(rgb) ); }


class __declspec(dllimport) QColor
{
public:
    enum Spec { Rgb, Hsv };

    QColor();
    QColor( int r, int g, int b );
    QColor( int x, int y, int z, Spec );
    QColor( QRgb rgb, uint pixel=0xffffffff);
    QColor( const QString& name );
    QColor( const char *name );
    QColor( const QColor & );
    QColor &operator=( const QColor & );

    bool   isValid() const;
    bool   isDirty() const;

    QString name() const;
    void   setNamedColor( const QString& name );

    void   rgb( int *r, int *g, int *b ) const;
    QRgb   rgb()    const;
    void   setRgb( int r, int g, int b );
    void   setRgb( QRgb rgb );

    int	   red()    const;
    int	   green()  const;
    int	   blue()   const;

    void   hsv( int *h, int *s, int *v ) const;
    void   getHsv( int &h, int &s, int &v ) const;
    void   setHsv( int h, int s, int v );

    QColor light( int f = 150 ) const;
    QColor dark( int f = 200 )	const;

    bool   operator==( const QColor &c ) const;
    bool   operator!=( const QColor &c ) const;

    static bool lazyAlloc();
    static void setLazyAlloc( bool );
    uint   alloc();
    uint   pixel()  const;

    static int  maxColors();
    static int  numBitPlanes();

    static int  enterAllocContext();
    static void leaveAllocContext();
    static int  currentAllocContext();
    static void destroyAllocContext( int );


    static HPALETTE hPal()  { return hpal; }
    static uint	realizePal( QWidget * );
#line 132 "c:\\qt\\include\\qcolor.h"

    static void initialize();
    static void cleanup();

private:
    void   setSystemNamedColor( const QString& name );
    static void initGlobalColors();
    static QColor* globalColors();
    static bool color_init;
    static bool globals_init;
    static bool lazy_alloc;

    static HPALETTE hpal;
#line 146 "c:\\qt\\include\\qcolor.h"
    uint   pix;
    QRgb   rgbVal;
};


inline QColor::QColor()
{ rgbVal = RGB_INVALID; pix = 0; }

inline QColor::QColor( int r, int g, int b )
{ setRgb( r, g, b ); }

inline bool QColor::isValid() const
{ return (rgbVal & RGB_INVALID) == 0; }

inline bool QColor::isDirty() const
{ return (rgbVal & RGB_DIRTY) != 0; }

inline QRgb QColor::rgb() const
{ return rgbVal | ~RGB_MASK; }

inline int QColor::red() const
{ return qRed(rgbVal); }

inline int QColor::green() const
{ return qGreen(rgbVal); }

inline int QColor::blue() const
{ return qBlue(rgbVal); }

inline uint QColor::pixel() const
{ return (rgbVal & RGB_DIRTY) == 0 ? pix : ((QColor*)this)->alloc(); }

inline bool QColor::lazyAlloc()
{ return lazy_alloc; }


inline bool QColor::operator==( const QColor &c ) const
{
    return isValid()==c.isValid() &&
	((((rgbVal | c.rgbVal) & RGB_DIRECT) == 0 &&
	    (rgbVal & RGB_MASK) == (c.rgbVal & RGB_MASK)) ||
	   ((rgbVal & c.rgbVal & RGB_DIRECT) != 0 &&
	    (rgbVal & RGB_MASK) == (c.rgbVal & RGB_MASK) && pix == c.pix));
}

inline bool QColor::operator!=( const QColor &c ) const
{
    return !operator==(c);
}







__declspec(dllimport) QDataStream &operator<<( QDataStream &, const QColor & );
__declspec(dllimport) QDataStream &operator>>( QDataStream &, QColor & );
#line 205 "c:\\qt\\include\\qcolor.h"

#line 207 "c:\\qt\\include\\qcolor.h"
#line 44 "c:\\qt\\include\\qpalette.h"
#line 1 "c:\\qt\\include\\qshared.h"























































#line 45 "c:\\qt\\include\\qpalette.h"
#line 1 "c:\\qt\\include\\qbrush.h"









































#line 1 "c:\\qt\\include\\qcolor.h"














































































































































































































#line 43 "c:\\qt\\include\\qbrush.h"
#line 1 "c:\\qt\\include\\qshared.h"























































#line 44 "c:\\qt\\include\\qbrush.h"
#line 45 "c:\\qt\\include\\qbrush.h"


class __declspec(dllimport) QBrush: public Qt
{
friend class QPainter;
public:
    QBrush();
    QBrush( BrushStyle );
    QBrush( const QColor &, BrushStyle=SolidPattern );
    QBrush( const QColor &, const QPixmap & );
    QBrush( const QBrush & );
   ~QBrush();
    QBrush &operator=( const QBrush & );

    BrushStyle	style()	 const		{ return data->style; }
    void	setStyle( BrushStyle );
    const QColor &color()const		{ return data->color; }
    void	setColor( const QColor & );
    QPixmap    *pixmap() const		{ return data->pixmap; }
    void	setPixmap( const QPixmap & );

    bool	operator==( const QBrush &p ) const;
    bool	operator!=( const QBrush &b ) const
					{ return !(operator==(b)); }

private:
    QBrush	copy()	const;
    void	detach();
    void	init( const QColor &, BrushStyle );
    struct QBrushData : public QShared {	
	BrushStyle style;
	QColor	  color;
	QPixmap	 *pixmap;
    } *data;
};







__declspec(dllimport) QDataStream &operator<<( QDataStream &, const QBrush & );
__declspec(dllimport) QDataStream &operator>>( QDataStream &, QBrush & );
#line 90 "c:\\qt\\include\\qbrush.h"

#line 92 "c:\\qt\\include\\qbrush.h"
#line 46 "c:\\qt\\include\\qpalette.h"
#line 47 "c:\\qt\\include\\qpalette.h"


class QColorGroupPrivate;


class __declspec(dllimport) QColorGroup
{
public:
    QColorGroup();
    QColorGroup( const QColor &foreground, const QColor &button,
		 const QColor &light, const QColor &dark, const QColor &mid,
		 const QColor &text, const QColor &base );
    QColorGroup( const QBrush &foreground, const QBrush &button,
		 const QBrush &light, const QBrush &dark, const QBrush &mid,
		 const QBrush &text, const QBrush &bright_text,
		 const QBrush &base, const QBrush &background);
    QColorGroup( const QColorGroup & );

   ~QColorGroup();

    QColorGroup& operator =(const QColorGroup&);

    
    enum ColorRole { Foreground, Button, Light, Midlight, Dark, Mid,
                     Text, BrightText, ButtonText, Base, Background, Shadow,
                     Highlight, HighlightedText,
		     NColorRoles };

    const QColor &color( ColorRole ) const;
    const QBrush &brush( ColorRole ) const;
    void setColor( ColorRole, const QColor & );
    void setBrush( ColorRole, const QBrush & );

    const QColor &foreground()	const	{ return br[Foreground].color(); }
    const QColor &button()	const	{ return br[Button].color(); }
    const QColor &light()	const	{ return br[Light].color(); }
    const QColor &dark()	const	{ return br[Dark].color(); }
    const QColor &mid()		const	{ return br[Mid].color(); }
    const QColor &text()	const	{ return br[Text].color(); }
    const QColor &base()	const	{ return br[Base].color(); }
    const QColor &background()	const	{ return br[Background].color(); }

    const QColor &midlight()	const	{ return br[Midlight].color(); }
    const QColor &brightText()	const	{ return br[BrightText].color(); }
    const QColor &buttonText()	const	{ return br[ButtonText].color(); }
    const QColor &shadow()	const	{ return br[Shadow].color(); }
    const QColor &highlight()	const	{ return br[Highlight].color(); }
    const QColor &highlightedText() const{return br[HighlightedText].color(); }

    bool	operator==( const QColorGroup &g ) const;
    bool	operator!=( const QColorGroup &g ) const
	{ return !(operator==(g)); }

private:
    QBrush *br;
    QColorGroupPrivate * d;

    friend class QPalette;
};


class __declspec(dllimport) QPalette
{
public:
    QPalette();
    QPalette( const QColor &button );
    QPalette( const QColor &button, const QColor &background );
    QPalette( const QColorGroup &active, const QColorGroup &disabled,
	      const QColorGroup &inactive );
    QPalette( const QPalette & );
   ~QPalette();
    QPalette &operator=( const QPalette & );

    enum ColorGroup { Normal, Disabled, Active, Inactive, NColorGroups };

    const QColor &color( ColorGroup, QColorGroup::ColorRole ) const;
    const QBrush &brush( ColorGroup, QColorGroup::ColorRole ) const;
    void setColor( ColorGroup, QColorGroup::ColorRole, const QColor & );
    void setBrush( ColorGroup, QColorGroup::ColorRole, const QBrush & );

    void setColor( QColorGroup::ColorRole, const QColor & );
    void setBrush( QColorGroup::ColorRole, const QBrush & );

    QPalette	copy() const;

    const QColorGroup &active() const { return data->active; }
    const QColorGroup &disabled() const { return data->disabled; }
    const QColorGroup &inactive() const { return data->inactive; }
    const QColorGroup &normal() const { return data->normal; } 

    void	setActive( const QColorGroup & );
    void	setDisabled( const QColorGroup & );
    void	setInactive( const QColorGroup & );
    void	setNormal( const QColorGroup & ); 

    bool	operator==( const QPalette &p ) const;
    bool	operator!=( const QPalette &p ) const
					{ return !(operator==(p)); }
    bool	isCopyOf( const QPalette & );

    int		serialNumber() const	{ return data->ser_no; }

private:
    void	detach();
    QBrush 	&directBrush( ColorGroup, QColorGroup::ColorRole ) const;

    struct QPalData : public QShared {
	QColorGroup normal; 
	QColorGroup disabled;
	QColorGroup active;
	int	    ser_no;
	QColorGroup inactive;
    } *data;
};







__declspec(dllimport) QDataStream &operator<<( QDataStream &, const QColorGroup & );
__declspec(dllimport) QDataStream &operator>>( QDataStream &, QColorGroup & );

__declspec(dllimport) QDataStream &operator<<( QDataStream &, const QPalette & );
__declspec(dllimport) QDataStream &operator>>( QDataStream &, QPalette & );
#line 174 "c:\\qt\\include\\qpalette.h"

#line 176 "c:\\qt\\include\\qpalette.h"
#line 177 "c:\\qt\\include\\qpalette.h"
#line 46 "c:\\qt\\include\\qwidget.h"
#line 1 "c:\\qt\\include\\qcursor.h"









































#line 1 "c:\\qt\\include\\qpoint.h"























































































































































































































#line 43 "c:\\qt\\include\\qcursor.h"
#line 1 "c:\\qt\\include\\qshared.h"























































#line 44 "c:\\qt\\include\\qcursor.h"
#line 1 "c:\\qt\\include\\qnamespace.h"







































































































































































































































































































































































































































































































































































































































#line 45 "c:\\qt\\include\\qcursor.h"
#line 46 "c:\\qt\\include\\qcursor.h"




















struct QCursorData;


class __declspec(dllimport) QCursor
{
public:
    QCursor();					
    QCursor( int shape );
    QCursor( const QBitmap &bitmap, const QBitmap &mask,
	     int hotX=-1, int hotY=-1 );
    QCursor( const QPixmap &pixmap,
	     int hotX=-1, int hotY=-1 );
    QCursor( const QCursor & );
   ~QCursor();
    QCursor &operator=( const QCursor & );

    int		  shape()   const;
    void	  setShape( int );

    const QBitmap *bitmap() const;
    const QBitmap *mask()   const;
    QPoint	  hotSpot() const;


    HCURSOR	  handle()  const;






#line 98 "c:\\qt\\include\\qcursor.h"

    static QPoint pos();
    static void	  setPos( int x, int y );
    static void	  setPos( const QPoint & );

    static void	  initialize();
    static void	  cleanup();

private:
    void	  setBitmap( const QBitmap &bitmap, const QBitmap &mask,
				 int hotX, int hotY );
    void	  update() const;
    QCursorData	 *data;
    QCursor	 *find_cur(int);
};








enum QCursorShape {
    ArrowCursor, UpArrowCursor, CrossCursor, WaitCursor, IbeamCursor,
    SizeVerCursor, SizeHorCursor, SizeBDiagCursor, SizeFDiagCursor,
    SizeAllCursor, BlankCursor, SplitVCursor, SplitHCursor, PointingHandCursor,
    ForbiddenCursor, LastCursor = ForbiddenCursor, BitmapCursor=24 };






__declspec(dllimport) QDataStream &operator<<( QDataStream &, const QCursor & );
__declspec(dllimport) QDataStream &operator>>( QDataStream &, QCursor & );
#line 135 "c:\\qt\\include\\qcursor.h"
#line 136 "c:\\qt\\include\\qcursor.h"


inline void QCursor::setPos( const QPoint &p )
{
    setPos( p.x(), p.y() );
}

#line 144 "c:\\qt\\include\\qcursor.h"
#line 47 "c:\\qt\\include\\qwidget.h"
#line 1 "c:\\qt\\include\\qfont.h"









































#line 1 "c:\\qt\\include\\qwindowdefs.h"














































































































































































#line 43 "c:\\qt\\include\\qfont.h"
#line 1 "c:\\qt\\include\\qstring.h"
























































































































































































































































































































































































































































































































































































































































































































































































































































#line 44 "c:\\qt\\include\\qfont.h"
#line 45 "c:\\qt\\include\\qfont.h"


class QStringList;
struct QFontDef;
struct QFontData;
class QFontInternal;
class QRenderedFont;

class __declspec(dllimport) QFont					
{
public:
    enum CharSet   { ISO_8859_1,  Latin1 = ISO_8859_1, AnyCharSet,
		     ISO_8859_2,  Latin2 = ISO_8859_2,
		     ISO_8859_3,  Latin3 = ISO_8859_3,
		     ISO_8859_4,  Latin4 = ISO_8859_4,
		     ISO_8859_5,
		     ISO_8859_6,
		     ISO_8859_7,
		     ISO_8859_8,
		     ISO_8859_9,  Latin5 = ISO_8859_9,
		     ISO_8859_10, Latin6 = ISO_8859_10,
		     ISO_8859_11, TIS620 = ISO_8859_11,
		     ISO_8859_12,
		     ISO_8859_13, Latin7 = ISO_8859_13,
		     ISO_8859_14, Latin8 = ISO_8859_14,
		     ISO_8859_15, Latin9 = ISO_8859_15,
		     KOI8R,
		     Set_Ja, Set_1 = Set_Ja,
		     Set_Ko,
		     Set_Th_TH,
		     Set_Zh,
		     Set_Zh_TW,
		     Set_N = Set_Zh_TW,
		     Unicode,
		     





		     Set_GBK,
		     Set_Big5,

		     TSCII,
		     KOI8U,
		     CP1251,
		     PT154,
		     


		     
		     JIS_X_0201 = 0xa0,
		     
		     JIS_X_0208 = 0xc0, Enc16 = JIS_X_0208,
		     KSC_5601,
		     GB_2312,
		     Big5
    };
    enum StyleHint { Helvetica, Times, Courier, OldEnglish,  System, AnyStyle,
		     SansSerif	= Helvetica,
		     Serif	= Times,
		     TypeWriter = Courier,
		     Decorative = OldEnglish};
    enum StyleStrategy { PreferDefault = 0x0001,
			  PreferBitmap = 0x0002,
			  PreferDevice = 0x0004,
			  PreferOutline = 0x0008,
			  ForceOutline = 0x0010,
			  PreferMatch = 0x0020,
			  PreferQuality = 0x0040 };
    enum Weight	   { Light = 25, Normal = 50, DemiBold = 63,
		     Bold  = 75, Black	= 87 };
    QFont();					
    QFont( const QString &family, int pointSize = 12,
	   int weight = Normal, bool italic = FALSE );
    QFont( const QString &family, int pointSize,
	   int weight, bool italic, CharSet charSet );
    QFont( const QFont & );
    ~QFont();
    QFont      &operator=( const QFont & );

    QString	family()	const;
    void	setFamily( const QString &);
    int		pointSize()	const;
    float	pointSizeFloat()	const;
    void	setPointSize( int );
    void	setPointSizeFloat( float );
    int		pixelSize() const;
    void	setPixelSize( int );
    void	setPixelSizeFloat( float );
    int		weight()	const;
    void	setWeight( int );
    bool	bold()		const;
    void	setBold( bool );
    bool	italic()	const;
    void	setItalic( bool );
    bool	underline()	const;
    void	setUnderline( bool );
    bool	strikeOut()	const;
    void	setStrikeOut( bool );
    bool	fixedPitch()	const;
    void	setFixedPitch( bool );
    StyleHint	styleHint()	const;
    void	setStyleHint( StyleHint );
    StyleStrategy styleStrategy() const;
    void	setStyleHint( StyleHint, StyleStrategy );
    CharSet	charSet()	const;
    void	setCharSet( CharSet );

    static CharSet charSetForLocale();

    bool	rawMode()      const;
    void	setRawMode( bool );

    bool	exactMatch()	const;

    bool	operator==( const QFont & ) const;
    bool	operator!=( const QFont & ) const;
    bool	isCopyOf( const QFont & ) const;


    HFONT	handle() const;






#line 174 "c:\\qt\\include\\qfont.h"

    void	setRawName( const QString & );
    QString	rawName() const;

    QString	key() const;

    static QString encodingName( CharSet );

    static QFont defaultFont();
    static void setDefaultFont( const QFont & );

    static QString substitute( const QString &familyName );
    static void insertSubstitution( const QString&, const QString &);
    static void removeSubstitution( const QString &);
    static QStringList substitutions();

    static void initialize();
    static void locale_init();
    static void cleanup();
    static void cacheStatistics();



#line 198 "c:\\qt\\include\\qfont.h"

protected:
    bool	dirty()			const;

    QString	defaultFamily()		const;
    QString	lastResortFamily()	const;
    QString	lastResortFont()	const;
    int		deciPointSize()		const;

private:
    QFont( QFontData * );
    void	init();
    void	detach();
    void	initFontInfo() const;
    void	load() const;


#line 216 "c:\\qt\\include\\qfont.h"

    HFONT	create( bool *, HDC=0, bool=FALSE ) const;
    void       *textMetric() const;
#line 220 "c:\\qt\\include\\qfont.h"

    friend class QFontInternal;
    friend class QFontMetrics;
    friend class QFontInfo;
    friend class QPainter;


#line 228 "c:\\qt\\include\\qfont.h"


    friend __declspec(dllimport) QDataStream &operator<<( QDataStream &, const QFont & );
    friend __declspec(dllimport) QDataStream &operator>>( QDataStream &, QFont & );
#line 233 "c:\\qt\\include\\qfont.h"
    QFontData	 *d;				
    static CharSet defaultCharSet;
};

inline bool QFont::bold() const
{ return weight() > Normal; }

inline void QFont::setBold( bool enable )
{ setWeight( enable ? Bold : Normal ); }







__declspec(dllimport) QDataStream &operator<<( QDataStream &, const QFont & );
__declspec(dllimport) QDataStream &operator>>( QDataStream &, QFont & );
#line 252 "c:\\qt\\include\\qfont.h"

#line 254 "c:\\qt\\include\\qfont.h"
#line 48 "c:\\qt\\include\\qwidget.h"
#line 1 "c:\\qt\\include\\qfontmetrics.h"









































#line 1 "c:\\qt\\include\\qfont.h"





























































































































































































































































#line 43 "c:\\qt\\include\\qfontmetrics.h"
#line 1 "c:\\qt\\include\\qrect.h"




























































































































































































































































#line 44 "c:\\qt\\include\\qfontmetrics.h"
#line 45 "c:\\qt\\include\\qfontmetrics.h"

class QTextCodec;


class __declspec(dllimport) QFontMetrics
{
public:
    QFontMetrics( const QFont & );
    QFontMetrics( const QFontMetrics & );
   ~QFontMetrics();

    QFontMetrics &operator=( const QFontMetrics & );

    int		ascent()	const;
    int		descent()	const;
    int		height()	const;
    int		leading()	const;
    int		lineSpacing()	const;
    int		minLeftBearing() const;
    int		minRightBearing() const;
    int		maxWidth()	const;

    bool	inFont(QChar)	const;

    int		leftBearing(QChar) const;
    int		rightBearing(QChar) const;
    int		width( const QString &, int len = -1 ) const;
    int		width( QChar ) const;
    int		width( char c ) const { return width( (QChar) c ); }
    QRect	boundingRect( const QString &, int len = -1 ) const;
    QRect	boundingRect( QChar ) const;
    QRect	boundingRect( int x, int y, int w, int h, int flags,
			      const QString& str, int len=-1, int tabstops=0,
			      int *tabarray=0, char **intern=0 ) const;
    QSize	size( int flags,
		      const QString& str, int len=-1, int tabstops=0,
		      int *tabarray=0, char **intern=0 ) const;

    int		underlinePos()	const;
    int		strikeOutPos()	const;
    int		lineWidth()	const;

private:
    QFontMetrics( const QPainter * );
    static void reset( const QPainter * );
    const QFontDef *spec() const;


    void   *textMetric() const;
    HDC	    hdc() const;







#line 103 "c:\\qt\\include\\qfontmetrics.h"

    friend class QWidget;
    friend class QPainter;

    QFontInternal *fin;
    QPainter      *painter;
    int		   flags;

    bool    underlineFlag()  const { return (flags & 0x1) != 0; }
    bool    strikeOutFlag()  const { return (flags & 0x2) != 0; }
    void    setUnderlineFlag()	   { flags |= 0x1; }
    void    setStrikeOutFlag()	   { flags |= 0x2; }
};


#line 119 "c:\\qt\\include\\qfontmetrics.h"
#line 49 "c:\\qt\\include\\qwidget.h"
#line 1 "c:\\qt\\include\\qfontinfo.h"









































#line 1 "c:\\qt\\include\\qfont.h"





























































































































































































































































#line 43 "c:\\qt\\include\\qfontinfo.h"
#line 44 "c:\\qt\\include\\qfontinfo.h"


class __declspec(dllimport) QFontInfo
{
public:
    QFontInfo( const QFont & );
    QFontInfo( const QFontInfo & );
   ~QFontInfo();

    QFontInfo	       &operator=( const QFontInfo & );

    QString   	        family()	const;
    int			pointSize()	const;
    bool		italic()	const;
    int			weight()	const;
    bool		bold()		const;
    bool		underline()	const;
    bool		strikeOut()	const;
    bool		fixedPitch()	const;
    QFont::StyleHint	styleHint()	const;
    QFont::CharSet	charSet()	const;
    bool		rawMode()	const;

    bool		exactMatch()	const;


    const QFont &font() const;
#line 72 "c:\\qt\\include\\qfontinfo.h"

private:
    QFontInfo( const QPainter * );
    static void reset( const QPainter * );
    const QFontDef *spec() const;

    QFontInternal *fin;
    QPainter      *painter;
    int		   flags;

    bool    underlineFlag()  const { return (flags & 0x1) != 0; }
    bool    strikeOutFlag()  const { return (flags & 0x2) != 0; }
    bool    exactMatchFlag() const { return (flags & 0x4) != 0; }
    void    setUnderlineFlag()	   { flags |= 0x1; }
    void    setStrikeOutFlag()	   { flags |= 0x2; }
    void    setExactMatchFlag()	   { flags |= 0x4; }

    friend class QWidget;
    friend class QPainter;
};


inline bool QFontInfo::bold() const
{ return weight() > QFont::Normal; }


#line 99 "c:\\qt\\include\\qfontinfo.h"
#line 50 "c:\\qt\\include\\qwidget.h"
#line 1 "c:\\qt\\include\\qstyle.h"








































#line 1 "c:\\qt\\include\\qwindowdefs.h"














































































































































































#line 42 "c:\\qt\\include\\qstyle.h"
#line 1 "c:\\qt\\include\\qobject.h"























































































































































































































































#line 43 "c:\\qt\\include\\qstyle.h"
#line 44 "c:\\qt\\include\\qstyle.h"


class QButton;
class QPushButton;
class QScrollBar;
class QTabBar;
class QTab;
class QPopupMenu;
class QMenuItem;
class QToolButton;

class __declspec(dllimport) QStyle: public QObject
{
    public: QMetaObject *metaObject() const { return staticMetaObject(); } const char *className() const; static QMetaObject* staticMetaObject(); static QString tr(const char*); static QString tr(const char*, const char*); protected: void initMetaObject(); private: static QMetaObject *metaObj;
    GUIStyle gs;

private:
    QStyle(GUIStyle);
    QStyle();
    friend class QCommonStyle;

public:
    virtual ~QStyle();


    operator GUIStyle() const { return gs; }
    int operator==(GUIStyle s) const { return gs==s; }
    int operator!=(GUIStyle s) const { return gs!=s; }
#line 73 "c:\\qt\\include\\qstyle.h"

    GUIStyle guiStyle() const { return gs; }

    

    virtual void polish( QWidget* );
    virtual void unPolish( QWidget* );

    virtual void polish( QApplication*);
    virtual void unPolish( QApplication*);

    virtual void polish( QPalette&);

    virtual QRect itemRect( QPainter *p, int x, int y, int w, int h,
		    int flags, bool enabled,
		    const QPixmap *pixmap,
		    const QString& text, int len=-1 ); 

    virtual void drawItem( QPainter *p, int x, int y, int w, int h,
		    int flags, const QColorGroup &g, bool enabled,
		    const QPixmap *pixmap, const QString& text,
			   int len=-1, const QColor* penColor = 0 );


    virtual void drawSeparator( QPainter *p, int x1, int y1, int x2, int y2,
		     const QColorGroup &g, bool sunken = TRUE,
		     int lineWidth = 1, int midLineWidth = 0 );

    virtual void drawRect( QPainter *p, int x, int y, int w, int h,
		    const QColor &, int lineWidth = 1,
		    const QBrush *fill = 0 );

    virtual void drawRectStrong( QPainter *p, int x, int y, int w, int h,
		     const QColorGroup &, bool sunken=FALSE,
		     int lineWidth = 1, int midLineWidth = 0,
		     const QBrush *fill = 0 );

    virtual void drawButton( QPainter *p, int x, int y, int w, int h,
		     const QColorGroup &g, bool sunken = FALSE,
		     const QBrush *fill = 0 ) = 0;

    virtual QRect buttonRect( int x, int y, int w, int h); 

    virtual void drawButtonMask( QPainter *p, int x, int y, int w, int h);

    virtual void drawBevelButton( QPainter *p, int x, int y, int w, int h,
		     const QColorGroup &g, bool sunken = FALSE,
		     const QBrush *fill = 0 ) = 0;

    QRect bevelButtonRect( int x, int y, int w, int h); 

    virtual void drawToolButton( QPainter *p, int x, int y, int w, int h,
		     const QColorGroup &g, bool sunken = FALSE,
		     const QBrush *fill = 0 );
    void drawToolButton( QToolButton* btn, QPainter *p); 

    QRect toolButtonRect(  int x, int y, int w, int h); 

    virtual void drawPanel( QPainter *p, int x, int y, int w, int h,
		    const QColorGroup &, bool sunken=FALSE,
		    int lineWidth = 1, const QBrush *fill = 0 );

    virtual void drawPopupPanel( QPainter *p, int x, int y, int w, int h,
				 const QColorGroup &,  int lineWidth = 2,
				 const QBrush *fill = 0 );

    virtual void drawArrow( QPainter *p, Qt::ArrowType type, bool down,
		     int x, int y, int w, int h,
		     const QColorGroup &g, bool enabled, const QBrush *fill = 0 ) = 0;

    
    virtual QSize exclusiveIndicatorSize() const = 0;
    virtual void drawExclusiveIndicator( QPainter* p, int x, int y, int w, int h,
		    const QColorGroup &g, bool on, bool down = FALSE, bool enabled = TRUE ) = 0;
    virtual void drawExclusiveIndicatorMask( QPainter *p, int x, int y, int w, int h, bool on);

    
    virtual QSize indicatorSize() const = 0;
    virtual void drawIndicator( QPainter* p, int x, int y, int w, int h, const QColorGroup &g,
				int state, bool down = FALSE, bool enabled = TRUE ) = 0;
    virtual void drawIndicatorMask( QPainter *p, int x, int y, int w, int h, int state);


    
    virtual void drawFocusRect( QPainter*, const QRect &,
				const QColorGroup &, const QColor* bg = 0,
				bool = FALSE ) = 0;


    

    
    virtual void drawComboButton( QPainter *p, int x, int y, int w, int h,
				  const QColorGroup &g, bool sunken = FALSE,
				  bool editable = FALSE,
				  bool enabled = TRUE,
				  const QBrush *fill = 0 ) = 0;
    virtual QRect comboButtonRect( int x, int y,
		    int w, int h) = 0; 
    virtual QRect comboButtonFocusRect( int x, int y,
		    int w, int h) = 0; 

    virtual void drawComboButtonMask( QPainter *p, int x, int y, int w, int h) = 0;

    
    virtual void drawPushButton( QPushButton* btn, QPainter *p) = 0;
    
    virtual void drawPushButtonLabel( QPushButton* btn, QPainter *p) = 0;
    QRect pushButtonContentsRect( QPushButton* btn ); 
    int menuButtonIndicatorWidth( int h ); 
    virtual void getButtonShift( int &x, int &y) = 0; 

    
    virtual int defaultFrameWidth() const = 0;

    
    virtual void tabbarMetrics( const QTabBar*,
		    int&, int&, int& ) = 0; 
    virtual void drawTab( QPainter*, const QTabBar*, QTab*, bool selected ) = 0;
    virtual void drawTabMask( QPainter*, const QTabBar*, QTab*, bool selected ) = 0;

    
    enum ScrollControl { AddLine = 0x1 , SubLine  = 0x2 , AddPage = 0x4,
			 SubPage = 0x8 , First = 0x10, Last = 0x20,
			 Slider  = 0x40, NoScroll = 0x80 };

    virtual void scrollBarMetrics( const QScrollBar*,
		    int&, int&, int&, int&) = 0; 
    virtual void drawScrollBarControls( QPainter*,  const QScrollBar*,
					int sliderStart, uint controls,
					uint activeControl ) = 0;
    virtual ScrollControl scrollBarPointOver( const QScrollBar*,
					int sliderStart, const QPoint& ) = 0;

    
    virtual int sliderLength() const = 0;
    virtual void drawSlider( QPainter *p,
			     int x, int y, int w, int h,
			     const QColorGroup &g,
			     Orientation, bool tickAbove, bool tickBelow) = 0;

    virtual void drawSliderMask( QPainter *p,
				 int x, int y, int w, int h,
				 Orientation, bool tickAbove, bool tickBelow) = 0;
    virtual void drawSliderGroove( QPainter *p,
				   int x, int y, int w, int h,
				   const QColorGroup& g, QCOORD c,
				   Orientation ) = 0;
    virtual void drawSliderGrooveMask( QPainter *p,
				       int x, int y, int w, int h,
				       QCOORD c,
				       Orientation ) = 0;
    virtual int maximumSliderDragDistance() const = 0;

    virtual int splitterWidth() const = 0;
    virtual void drawSplitter( QPainter *p,
			     int x, int y, int w, int h,
			     const QColorGroup &g,
			     Orientation) = 0;

    virtual void drawCheckMark( QPainter *p, int x, int y, int w, int h,
				const QColorGroup &g,
				bool act, bool dis ) = 0;
    virtual void polishPopupMenu( QPopupMenu* ) = 0;

    virtual int extraPopupMenuItemWidth( bool checkable, int maxpmw,
				QMenuItem* mi,
				const QFontMetrics& fm  ) = 0; 
    virtual int popupSubmenuIndicatorWidth(
				const QFontMetrics& fm  ) = 0; 
    virtual int popupMenuItemHeight( bool checkable,
				QMenuItem* mi,
				const QFontMetrics& fm  ) = 0; 
    virtual void drawPopupMenuItem( QPainter* p, bool checkable,
				    int maxpmw, int tab, QMenuItem* mi,
				    const QPalette& pal,
				    bool act, bool enabled,
				    int x, int y, int w, int h) = 0;
    void drawMenuBarItem( QPainter* p, int x, int y, int w, int h, 
				    QMenuItem* mi, QColorGroup& g,
				    bool enabled, bool active );

    
    QSize scrollBarExtent(); 
    int buttonDefaultIndicatorWidth() const;
    int buttonMargin() const; 
    int toolBarHandleExtent() const; 
    int toolBarHandleExtend() const; 
    int sliderThickness() const ; 
    void drawToolBarHandle( QPainter *p, const QRect &r,
			    Qt::Orientation orientation,
			    bool highlight, const QColorGroup &cg,
			    bool drawBorder = FALSE ); 

protected:
    void setScrollBarExtent( int w, int h=-1 ); 
    void setButtonDefaultIndicatorWidth( int w ); 
    void setButtonMargin( int w ); 
    void setSliderThickness(int t); 


private:	



#line 279 "c:\\qt\\include\\qstyle.h"
};

#line 282 "c:\\qt\\include\\qstyle.h"
#line 283 "c:\\qt\\include\\qstyle.h"
#line 51 "c:\\qt\\include\\qwidget.h"
#line 1 "c:\\qt\\include\\qsizepolicy.h"









































#line 1 "c:\\qt\\include\\qglobal.h"


























































































































































































































































































































































































































































































































































































































































#line 43 "c:\\qt\\include\\qsizepolicy.h"
#line 44 "c:\\qt\\include\\qsizepolicy.h"

class __declspec(dllimport) QSizePolicy
{
private:
    enum { HSize = 6, HMask = 0x3f, VMask = HMask << HSize,
	   MayGrow = 1, ExpMask = 2, MayShrink = 4 };
public:
    enum SizeType { Fixed = 0,
		    Minimum = MayGrow,
		    Maximum = MayShrink,
		    Preferred = MayGrow|MayShrink ,
		    MinimumExpanding = Minimum|ExpMask,
		    Expanding = MinimumExpanding|MayShrink };

    enum ExpandData { NoDirection = 0,
		      Horizontal = 1,
		      Vertical = 2,
		      BothDirections = Horizontal | Vertical };

    QSizePolicy() { data = 0; }

    QSizePolicy( SizeType hor, SizeType ver, bool hfw = FALSE );

    SizeType horData() const { return (SizeType)( data & HMask ); }
    SizeType verData() const { return (SizeType)(( data & VMask ) >> HSize); }

    bool mayShrinkHorizontally() const { return horData() & MayShrink; }
    bool mayShrinkVertically() const { return verData() & MayShrink; }
    bool mayGrowHorizontally() const { return horData() & MayGrow; }
    bool mayGrowVertically() const { return verData() & MayGrow; }

    ExpandData expanding() const
    {
	return (ExpandData)( (int)(verData()&ExpMask ? Vertical : 0)+
			     (int)(horData()&ExpMask ? Horizontal : 0) );
    }

    void setHorData( SizeType d ) { data = (data & ~HMask) | d; }
    void setVerData( SizeType d ) { data = (data & ~(HMask<<HSize)) |
					   (d<<HSize); }
		
    void setHeightForWidth( bool b ) { data = b ? ( data | ( 1 << 2*HSize ) )
					      : ( data & ~( 1 << 2*HSize ) );  }
    bool hasHeightForWidth() const { return data & ( 1 << 2*HSize ); }

    bool operator==( const QSizePolicy& s ) const { return data == s.data; }
    bool operator!=( const QSizePolicy& s ) const { return data != s.data; }

private:
    QSizePolicy( int i ): data( i ) {}

    Q_UINT16 data;
};


inline QSizePolicy::QSizePolicy( SizeType hor, SizeType ver, bool hfw )
	: data( hor | (ver<<HSize) | (hfw ? (1<<2*HSize) : 0) ) {}
#line 102 "c:\\qt\\include\\qsizepolicy.h"

#line 104 "c:\\qt\\include\\qsizepolicy.h"
#line 52 "c:\\qt\\include\\qwidget.h"
#line 53 "c:\\qt\\include\\qwidget.h"

class QLayout;
struct QWExtra;
struct QTLWExtra;
class QFocusData;
class QStyle;
class QWSRegionManager;

class __declspec(dllimport) QWidget : public QObject, public QPaintDevice
{
    public: QMetaObject *metaObject() const { return staticMetaObject(); } const char *className() const; static QMetaObject* staticMetaObject(); static QString tr(const char*); static QString tr(const char*, const char*); protected: void initMetaObject(); private: static QMetaObject *metaObj;
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
#line 104 "c:\\qt\\include\\qwidget.h"
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

public:
    QWidget( QWidget *parent=0, const char *name=0, WFlags f=0 );
    ~QWidget();

    WId		 winId() const;
    void	 setName( const char *name );

    

    QStyle     &style() const;
    void        setStyle( QStyle * );
#line 137 "c:\\qt\\include\\qwidget.h"
    

    bool	 isTopLevel()	const;
    bool	 isModal()	const;
    bool	 isPopup()	const;
    bool	 isDesktop()	const;

    bool	 isEnabled()	const;
    bool	 isEnabledTo(QWidget*) const;
    bool	 isEnabledToTLW() const;

public :
    virtual void setEnabled( bool );
    void setDisabled( bool );

    

public:
    QRect	 frameGeometry() const;
    const QRect &geometry()	const;
    int		 x()		const;
    int		 y()		const;
    QPoint	 pos()		const;
    QSize	 frameSize()    const;
    QSize	 size()		const;
    int		 width()	const;
    int		 height()	const;
    QRect	 rect()		const;
    QRect	 childrenRect() const;
    QRegion	 childrenRegion() const;

    QSize	 minimumSize()	 const;
    QSize	 maximumSize()	 const;
    int		 minimumWidth()	 const;
    int		 minimumHeight() const;
    int		 maximumWidth()	 const;
    int		 maximumHeight() const;
    void	 setMinimumSize( const QSize & );
    virtual void setMinimumSize( int minw, int minh );
    void	 setMaximumSize( const QSize & );
    virtual void setMaximumSize( int maxw, int maxh );
    void	 setMinimumWidth( int minw );
    void	 setMinimumHeight( int minh );
    void	 setMaximumWidth( int maxw );
    void	 setMaximumHeight( int maxh );

    QSize	 sizeIncrement() const;
    void	 setSizeIncrement( const QSize & );
    virtual void setSizeIncrement( int w, int h );
    QSize	 baseSize() const;
    void	 setBaseSize( const QSize & );
    void	 setBaseSize( int basew, int baseh );

    void	setFixedSize( const QSize & );
    void	setFixedSize( int w, int h );
    void	setFixedWidth( int w );
    void	setFixedHeight( int h );

    

    QPoint	 mapToGlobal( const QPoint & )	 const;
    QPoint	 mapFromGlobal( const QPoint & ) const;
    QPoint	 mapToParent( const QPoint & )	 const;
    QPoint	 mapFromParent( const QPoint & ) const;
    QPoint	 mapTo( QWidget *, const QPoint & ) const;
    QPoint	 mapFrom( QWidget *, const QPoint & ) const;

    QWidget	*topLevelWidget()   const;

    

    enum BackgroundMode { FixedColor, FixedPixmap, NoBackground,
			  PaletteForeground, PaletteButton, PaletteLight,
			  PaletteMidlight, PaletteDark, PaletteMid,
			  PaletteText, PaletteBrightText, PaletteBase,
			  PaletteBackground, PaletteShadow, PaletteHighlight,
			  PaletteHighlightedText, PaletteButtonText,
			  X11ParentRelative };

    BackgroundMode	backgroundMode() const;
    virtual void	setBackgroundMode( BackgroundMode );

    const QColor &	backgroundColor() const;
    const QColor &	foregroundColor() const;
    virtual void	setBackgroundColor( const QColor & );

    const QPixmap *	backgroundPixmap() const;
    virtual void	setBackgroundPixmap( const QPixmap & );


    const QColorGroup & colorGroup() const;
    const QPalette &	palette()    const;
    bool		ownPalette() const;
    virtual void	setPalette( const QPalette & );
    void		unsetPalette();
#line 233 "c:\\qt\\include\\qwidget.h"
    QFont		font() const;
    bool		ownFont() const;
    virtual void	setFont( const QFont & );
    void		unsetFont();
    QFontMetrics	fontMetrics() const;
    QFontInfo	 	fontInfo() const;

    enum PropagationMode { NoChildren, AllChildren,
			   SameFont, SamePalette = SameFont };

    PropagationMode	fontPropagation() const; 
    virtual void	setFontPropagation( PropagationMode ); 

    PropagationMode	palettePropagation() const; 
    virtual void	setPalettePropagation( PropagationMode ); 

    const QCursor      &cursor() const;
    bool		ownCursor() const;
    virtual void	setCursor( const QCursor & );
    virtual void	unsetCursor();
#line 254 "c:\\qt\\include\\qwidget.h"
    QString		caption() const;
    const QPixmap      *icon() const;
    QString		iconText() const;
    bool		hasMouseTracking() const;

    virtual void	setMask( const QBitmap & );
    virtual void	setMask( const QRegion & );
    void		clearMask();

public :
    virtual void	setCaption( const QString &);
    virtual void	setIcon( const QPixmap & );
    virtual void	setIconText( const QString &);
    virtual void	setMouseTracking( bool enable );

    

    virtual void	setFocus();
    void		clearFocus();

public:
    enum FocusPolicy {
	NoFocus = 0,
	TabFocus = 0x1,
	ClickFocus = 0x2,
	StrongFocus = 0x3,
	WheelFocus = 0x7
    };

    bool		isActiveWindow() const;
    virtual void	setActiveWindow();
    bool		isFocusEnabled() const;

    FocusPolicy		focusPolicy() const;
    virtual void	setFocusPolicy( FocusPolicy );
    bool		hasFocus() const;
    static void		setTabOrder( QWidget *, QWidget * );
    virtual void	setFocusProxy( QWidget * );
    QWidget *		focusProxy() const;

    

    void		grabMouse();

    void		grabMouse( const QCursor & );
#line 300 "c:\\qt\\include\\qwidget.h"
    void		releaseMouse();
    void		grabKeyboard();
    void		releaseKeyboard();
    static QWidget *	mouseGrabber();
    static QWidget *	keyboardGrabber();

    

    bool	 	isUpdatesEnabled() const;



#line 313 "c:\\qt\\include\\qwidget.h"
public :
    virtual void	setUpdatesEnabled( bool enable );
    void		update();
    void		update( int x, int y, int w, int h );
    void		update( const QRect& );
    void		repaint();
    void		repaint( bool erase );
    void		repaint( int x, int y, int w, int h, bool erase=TRUE );
    void		repaint( const QRect &, bool erase=TRUE );
    void		repaint( const QRegion &, bool erase=TRUE );

    

    virtual void	show();
    virtual void	hide();

    void		iconify()	{ showMinimized(); }
#line 331 "c:\\qt\\include\\qwidget.h"
    virtual void	showMinimized();
    virtual void	showMaximized();
    void		showFullScreen(); 
    virtual void	showNormal();
    virtual void	polish();
    void 		constPolish() const;
    bool		close();

    void		raise();
    void		lower();
    void		stackUnder( QWidget* );
    virtual void	move( int x, int y );
    void		move( const QPoint & );
    virtual void	resize( int w, int h );
    void		resize( const QSize & );
    virtual void	setGeometry( int x, int y, int w, int h );
    virtual void	setGeometry( const QRect & );

public:
    virtual bool	close( bool alsoDelete );
    bool		isVisible()	const;
    bool		isVisibleTo(QWidget*) const;
    bool		isVisibleToTLW() const; 
    QRect		visibleRect() const;
    bool 		isHidden() const;
    bool		isMinimized() const;
    bool		isMaximized() const;

    virtual QSize	sizeHint() const;
    virtual QSize	minimumSizeHint() const;
    virtual QSizePolicy	sizePolicy() const;
    void 		setSizePolicy( QSizePolicy );
    virtual int heightForWidth(int) const;

    virtual void  	adjustSize();

    QLayout *		layout() const { return lay_out; }
#line 369 "c:\\qt\\include\\qwidget.h"
    void		updateGeometry();
    virtual void 	reparent( QWidget *parent, WFlags, const QPoint &,
				  bool showIt=FALSE );
    void		reparent( QWidget *parent, const QPoint &,
				  bool showIt=FALSE );

    void		recreate( QWidget *parent, WFlags f, const QPoint & p,
				  bool showIt=FALSE )
    { reparent(parent,f,p,showIt); }
#line 379 "c:\\qt\\include\\qwidget.h"

    void		erase();
    void		erase( int x, int y, int w, int h );
    void		erase( const QRect & );
    void		erase( const QRegion & );
    void		scroll( int dx, int dy );
    void		scroll( int dx, int dy, const QRect& );

    void		drawText( int x, int y, const QString &);
    void		drawText( const QPoint &, const QString &);

    

    QWidget *		focusWidget() const;
    QRect               microFocusHint() const;

    

    bool		acceptDrops() const;
    virtual void	setAcceptDrops( bool on );

    

    virtual void	setAutoMask(bool);
    bool		autoMask() const;

    enum BackgroundOrigin { WidgetOrigin, ParentOrigin };

    void setBackgroundOrigin( BackgroundOrigin );
    BackgroundOrigin backgroundOrigin() const;


    
    virtual bool customWhatsThis() const;

    QWidget *		parentWidget() const;
    bool		testWState( uint n ) const;
    bool		testWFlags( WFlags f ) const;
    static QWidget *	find( WId );
    static QWidgetMapper *wmapper();



#line 423 "c:\\qt\\include\\qwidget.h"

protected:
    
    bool	 event( QEvent * );
    virtual void mousePressEvent( QMouseEvent * );
    virtual void mouseReleaseEvent( QMouseEvent * );
    virtual void mouseDoubleClickEvent( QMouseEvent * );
    virtual void mouseMoveEvent( QMouseEvent * );
    virtual void wheelEvent( QWheelEvent * );
    virtual void keyPressEvent( QKeyEvent * );
    virtual void keyReleaseEvent( QKeyEvent * );
    virtual void focusInEvent( QFocusEvent * );
    virtual void focusOutEvent( QFocusEvent * );
    virtual void enterEvent( QEvent * );
    virtual void leaveEvent( QEvent * );
    virtual void paintEvent( QPaintEvent * );
    virtual void moveEvent( QMoveEvent * );
    virtual void resizeEvent( QResizeEvent * );
    virtual void closeEvent( QCloseEvent * );


    virtual void dragEnterEvent( QDragEnterEvent * );
    virtual void dragMoveEvent( QDragMoveEvent * );
    virtual void dragLeaveEvent( QDragLeaveEvent * );
    virtual void dropEvent( QDropEvent * );
#line 449 "c:\\qt\\include\\qwidget.h"

    virtual void showEvent( QShowEvent * );
    virtual void hideEvent( QHideEvent * );
    virtual void customEvent( QCustomEvent * );








#line 462 "c:\\qt\\include\\qwidget.h"
    virtual bool winEvent( MSG * );		






#line 470 "c:\\qt\\include\\qwidget.h"

    virtual void updateMask();

    

protected:

    virtual void styleChange( QStyle& );
#line 479 "c:\\qt\\include\\qwidget.h"
    virtual void enabledChange( bool );
    virtual void backgroundColorChange( const QColor & );
    virtual void backgroundPixmapChange( const QPixmap & );

    virtual void paletteChange( const QPalette & );
#line 485 "c:\\qt\\include\\qwidget.h"
    virtual void fontChange( const QFont & );

    int		 metric( int )	const;

    virtual void create( WId = 0, bool initializeWindow = TRUE,
			 bool destroyOldWindow = TRUE );
    virtual void destroy( bool destroyWindow = TRUE,
			  bool destroySubWindows = TRUE );
    uint	 getWState() const;
    virtual void setWState( uint );
    void	 clearWState( uint n );
    WFlags	 getWFlags() const;
    virtual void setWFlags( WFlags );
    void	 clearWFlags( WFlags n );

    virtual void setFRect( const QRect & );
    virtual void setCRect( const QRect & );

    virtual bool focusNextPrevChild( bool next );

    QWExtra	*extraData();
    QTLWExtra	*topData();
    QFocusData	*focusData();

    virtual void setKeyCompression(bool);
    virtual void setMicroFocusHint(int x, int y, int w, int h, bool text=TRUE);

private :
    void	 focusProxyDestroyed();

private:
    void	 setFontSys();

    void 	 setLayout( QLayout *l );
#line 520 "c:\\qt\\include\\qwidget.h"
    void	 setWinId( WId );
    void	 showWindow();
    void	 hideWindow();
    void	 sendShowEventsToChildren( bool spontaneous );
    void	 sendHideEventsToChildren( bool spontaneous );
    void	 createTLExtra();
    void	 createExtra();
    void	 deleteExtra();
    void	 createSysExtra();
    void	 deleteSysExtra();
    void	 createTLSysExtra();
    void	 deleteTLSysExtra();
    void	 deactivateWidgetCleanup();
    void	 internalSetGeometry( int, int, int, int, bool );
    void	 reparentFocusWidgets( QWidget * );
    QFocusData	*focusData( bool create );
    void         setBackgroundFromMode();
    void         setBackgroundColorDirect( const QColor & );
    void   	 setBackgroundPixmapDirect( const QPixmap & );
    void         setBackgroundModeDirect( BackgroundMode );
    void         setBackgroundEmpty();


#line 544 "c:\\qt\\include\\qwidget.h"

    WId		 winid;
    uint	 widget_state;
    uint	 widget_flags;
    uint	 propagate_font : 2; 
    uint	 propagate_palette : 2; 
    uint	 focus_policy : 4;
    uint 	 own_font :1;
    uint 	 own_palette :1;
    uint 	 sizehint_forced :1;
    uint 	 is_closing :1;
    uint 	 in_show : 1;
    QPoint	 fpos;
    QRect	 crect;
    QColor	 bg_col;

    QPalette	 pal;
#line 562 "c:\\qt\\include\\qwidget.h"
    QFont	 fnt;

    QLayout 	*lay_out;
#line 566 "c:\\qt\\include\\qwidget.h"
    QWExtra	*extra;






















#line 590 "c:\\qt\\include\\qwidget.h"

    static void	 createMapper();
    static void	 destroyMapper();
    static QWidgetList	 *wList();
    static QWidgetList	 *tlwList();
    static QWidgetMapper *mapper;
    friend class QApplication;
    friend class QBaseApplication;
    friend class QPainter;
    friend class QFontMetrics;
    friend class QFontInfo;
    friend class QETWidget;

    friend class QLayout;


#line 607 "c:\\qt\\include\\qwidget.h"
private:	



#line 612 "c:\\qt\\include\\qwidget.h"

public: 

    void setPalette( const QPalette &, bool iReallyMeanIt );
#line 617 "c:\\qt\\include\\qwidget.h"
    void setFont( const QFont &, bool iReallyMeanIt );
};


inline bool QWidget::testWState( uint f ) const
{ return (widget_state & f) != 0; }

inline bool QWidget::testWFlags( WFlags f ) const
{ return (widget_flags & f) != 0; }


inline WId QWidget::winId() const
{ return winid; }

inline bool QWidget::isTopLevel() const
{ return testWFlags(WType_TopLevel); }

inline bool QWidget::isModal() const
{ return testWFlags(WType_Modal); }

inline bool QWidget::isPopup() const
{ return testWFlags(WType_Popup); }

inline bool QWidget::isDesktop() const
{ return testWFlags(WType_Desktop); }

inline bool QWidget::isEnabled() const
{ return !testWState(WState_Disabled); }

inline const QRect &QWidget::geometry() const
{ return crect; }

inline int QWidget::x() const
{ return fpos.x(); }

inline int QWidget::y() const
{ return fpos.y(); }

inline QPoint QWidget::pos() const
{ return fpos; }

inline QSize QWidget::size() const
{ return crect.size(); }

inline int QWidget::width() const
{ return crect.width(); }

inline int QWidget::height() const
{ return crect.height(); }

inline QRect QWidget::rect() const
{ return QRect(0,0,crect.width(),crect.height()); }

inline int QWidget::minimumWidth() const
{ return minimumSize().width(); }

inline int QWidget::minimumHeight() const
{ return minimumSize().height(); }

inline int QWidget::maximumWidth() const
{ return maximumSize().width(); }

inline int QWidget::maximumHeight() const
{ return maximumSize().height(); }

inline void QWidget::setMinimumSize( const QSize &s )
{ setMinimumSize(s.width(),s.height()); }

inline void QWidget::setMaximumSize( const QSize &s )
{ setMaximumSize(s.width(),s.height()); }

inline void QWidget::setSizeIncrement( const QSize &s )
{ setSizeIncrement(s.width(),s.height()); }

inline void QWidget::setBaseSize( const QSize &s )
{ setBaseSize(s.width(),s.height()); }

inline const QColor &QWidget::backgroundColor() const
{ return bg_col; }


inline const QPalette &QWidget::palette() const
{ return pal; }
#line 701 "c:\\qt\\include\\qwidget.h"

inline QFont QWidget::font() const
{ return fnt; }

inline QFontMetrics QWidget::fontMetrics() const
{ return QFontMetrics(font()); }

inline QFontInfo QWidget::fontInfo() const
{ return QFontInfo(font()); }

inline bool QWidget::hasMouseTracking() const
{ return testWState(WState_MouseTracking); }

inline bool  QWidget::isFocusEnabled() const
{ return (FocusPolicy)focus_policy != NoFocus; }

inline QWidget::FocusPolicy QWidget::focusPolicy() const
{ return (FocusPolicy)focus_policy; }

inline bool QWidget::isUpdatesEnabled() const
{ return !testWState(WState_BlockUpdates); }

inline void QWidget::update( const QRect &r )
{ update( r.x(), r.y(), r.width(), r.height() ); }

inline void QWidget::repaint()
{ repaint( 0, 0, crect.width(), crect.height(), TRUE ); }

inline void QWidget::repaint( bool erase )
{ repaint( 0, 0, crect.width(), crect.height(), erase ); }

inline void QWidget::repaint( const QRect &r, bool erase )
{ repaint( r.x(), r.y(), r.width(), r.height(), erase ); }

inline void QWidget::erase()
{ erase( 0, 0, crect.width(), crect.height() ); }

inline void QWidget::erase( const QRect &r )
{ erase( r.x(), r.y(), r.width(), r.height() ); }

inline bool QWidget::close()
{ return close( FALSE ); }

inline bool QWidget::isVisible() const
{ return testWState(WState_Visible); }

inline bool QWidget::isHidden() const
{ return testWState(WState_ForceHide); }

inline void QWidget::move( const QPoint &p )
{ move( p.x(), p.y() ); }

inline void QWidget::resize( const QSize &s )
{ resize( s.width(), s.height()); }

inline void QWidget::setGeometry( const QRect &r )
{ setGeometry( r.left(), r.top(), r.width(), r.height() ); }

inline void QWidget::drawText( const QPoint &p, const QString &s )
{ drawText( p.x(), p.y(), s ); }

inline QWidget *QWidget::parentWidget() const
{ return (QWidget *)QObject::parent(); }

inline QWidgetMapper *QWidget::wmapper()
{ return mapper; }

inline uint QWidget::getWState() const
{ return widget_state; }

inline void QWidget::setWState( uint f )
{ widget_state |= f; }

inline void QWidget::clearWState( uint f )
{ widget_state &= ~f; }

inline Qt::WFlags QWidget::getWFlags() const
{ return widget_flags; }

inline void QWidget::setWFlags( WFlags f )
{ widget_flags |= f; }

inline void QWidget::clearWFlags( WFlags f )
{ widget_flags &= ~f; }

inline void QWidget::constPolish() const
{
    if ( !testWState(WState_Polished) ) {
	QWidget* that = (QWidget*) this;
	that->polish();
        that->setWState(WState_Polished); 
    }
}

inline bool QWidget::ownCursor() const
{
    return testWState( WState_OwnCursor );
}
#line 800 "c:\\qt\\include\\qwidget.h"
inline bool QWidget::ownFont() const
{
    return own_font;
}

inline bool QWidget::ownPalette() const
{
    return own_palette;
}
#line 810 "c:\\qt\\include\\qwidget.h"





class QFocusData;
class QWSManager;

class QOleDropTarget;
#line 820 "c:\\qt\\include\\qwidget.h"

struct QTLWExtra {
    QString  caption;				
    QString  iconText;				
    QPixmap *icon;				
    QFocusData *focusData;			
    QSize    fsize;				
    short    incw, inch;			
    uint     iconic: 1;				
    uint     fullscreen : 1;			
    uint     showMode: 2;			
    short    basew, baseh;			








#line 841 "c:\\qt\\include\\qwidget.h"



#line 845 "c:\\qt\\include\\qwidget.h"

    HICON    winIcon;				
#line 848 "c:\\qt\\include\\qwidget.h"
    QRect    normalGeometry;			
};






struct QWExtra {
    Q_INT16  minw, minh;			
    Q_INT16  maxw, maxh;			
    QPixmap *bg_pix;				
    QWidget *focus_proxy;

    QCursor *curs;
#line 864 "c:\\qt\\include\\qwidget.h"
    QTLWExtra *topextra;			

    QOleDropTarget *dropTarget;			
#line 868 "c:\\qt\\include\\qwidget.h"


#line 871 "c:\\qt\\include\\qwidget.h"


#line 874 "c:\\qt\\include\\qwidget.h"
    char     bg_mode;				

    QStyle* style;
#line 878 "c:\\qt\\include\\qwidget.h"
    QRect micro_focus_hint;                     
    QSizePolicy size_policy;
    void * posted_events;			
};


#line 885 "c:\\qt\\include\\qwidget.h"
#line 43 "c:\\qt\\include\\qdialog.h"
#line 44 "c:\\qt\\include\\qdialog.h"



#line 48 "c:\\qt\\include\\qdialog.h"

class QDialogPrivate;
class QPushButton;

class __declspec(dllimport) QDialog : public QWidget			
{
friend class QPushButton;
    public: QMetaObject *metaObject() const { return staticMetaObject(); } const char *className() const; static QMetaObject* staticMetaObject(); static QString tr(const char*); static QString tr(const char*, const char*); protected: void initMetaObject(); private: static QMetaObject *metaObj;
    

public:
    QDialog( QWidget *parent=0, const char *name=0, bool modal=FALSE,
	     WFlags f=0 );
   ~QDialog();

    enum DialogCode { Rejected, Accepted };

    int		exec();
    int		result()  const { return rescode; }

    void	show();
    void	hide();
    void	move( int x, int y );
    void	move( const QPoint &p );
    void	resize( int w, int h );
    void	resize( const QSize & );
    void	setGeometry( int x, int y, int w, int h );
    void	setGeometry( const QRect & );

    void	setOrientation( Orientation orientation );
    Orientation	orientation() const;

    void	setExtension( QWidget* extension );
    QWidget* extension() const;

    QSize	sizeHint() const;
    QSize	minimumSizeHint() const;

    void setSizeGripEnabled(bool);
    bool isSizeGripEnabled() const;

protected :
    virtual void done( int );
    virtual void accept();
    virtual void reject();

    void	showExtension( bool );

protected:
    void	setResult( int r )	{ rescode = r; }
    void	keyPressEvent( QKeyEvent * );
    void	closeEvent( QCloseEvent * );
    void 	resizeEvent( QResizeEvent * );
private:
    virtual void	setDefault( QPushButton * ); 
    void		hideDefault();
    int		rescode;
    uint	did_move   : 1;
    uint	did_resize : 1;
    uint 	in_loop: 1;
    QDialogPrivate* d;

private:	



#line 115 "c:\\qt\\include\\qdialog.h"
};

#line 118 "c:\\qt\\include\\qdialog.h"
#line 119 "c:\\qt\\include\\qdialog.h"
#line 14 "h:\\c_projekte\\elansim\\headview.h"
class QVBoxLayout; 
class QHBoxLayout; 
class QGridLayout; 
class QFrame;
class QSlider;

class Scene;

class SoPerspectiveCamera;
class SoCamera;
class SoVRMLGroup;
class SbVec3f;
class SbRotation;

class HeadView : public QDialog
{ 
    public: QMetaObject *metaObject() const { return staticMetaObject(); } const char *className() const; static QMetaObject* staticMetaObject(); static QString tr(const char*); static QString tr(const char*, const char*); protected: void initMetaObject(); private: static QMetaObject *metaObj;

public:
    HeadView( QWidget* parent = 0, const char* name = 0, bool modal = FALSE, 
		WFlags fl = WStyle_Customize|WStyle_DialogBorder|WStyle_Title );
    ~HeadView();

    QFrame* Frame5;
    QSlider* slider;

	void set(const SbRotation& rot, const SbVec3f& pos);
	void setScene(Scene* sc);

private:
	SoPerspectiveCamera* headCam;
	SoVRMLGroup* _root;
	SoPerspectiveCamera* _cam;



private :
	void _onSlider(int value);
};

#line 55 "h:\\c_projekte\\elansim\\headview.h"
#line 10 "h:\\c_projekte\\elansim\\headview.cpp"

#line 1 "c:\\qt\\include\\qframe.h"









































#line 1 "c:\\qt\\include\\qwidget.h"




















































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 43 "c:\\qt\\include\\qframe.h"
#line 44 "c:\\qt\\include\\qframe.h"



class __declspec(dllimport) QFrame : public QWidget			
{
    public: QMetaObject *metaObject() const { return staticMetaObject(); } const char *className() const; static QMetaObject* staticMetaObject(); static QString tr(const char*); static QString tr(const char*, const char*); protected: void initMetaObject(); private: static QMetaObject *metaObj;
    
    
    
    
    
    
    
    
    

public:
    QFrame( QWidget *parent=0, const char *name=0, WFlags f=0,
	    bool = TRUE );

    int		frameStyle()	const;
    virtual void setFrameStyle( int );

    int		frameWidth()	const;
    QRect	contentsRect()	const;


    bool	lineShapesOk()	const { return TRUE; }
#line 73 "c:\\qt\\include\\qframe.h"

    QSize	sizeHint() const;
    QSizePolicy sizePolicy() const;

    enum Shape { NoFrame  = 0,				
		 Box	  = 0x0001,			
		 Panel    = 0x0002,			
		 WinPanel = 0x0003,			
		 HLine    = 0x0004,			
		 VLine    = 0x0005,			
		 StyledPanel = 0x0006,			
		 PopupPanel = 0x0007,			
		 MShape   = 0x000f			
    };
    enum Shadow { Plain    = 0x0010,			
		  Raised   = 0x0020,			
		  Sunken   = 0x0030,			
		  MShadow  = 0x00f0 };			

    Shape	frameShape()	const;
    void	setFrameShape( Shape );
    Shadow	frameShadow()	const;
    void	setFrameShadow( Shadow );

    int		lineWidth()	const;
    virtual void setLineWidth( int );

    int		margin()	const;
    virtual void setMargin( int );

    int		midLineWidth()	const;
    virtual void setMidLineWidth( int );

    QRect	frameRect()	const;
    virtual void setFrameRect( const QRect & );

protected:
    void	paintEvent( QPaintEvent * );
    void	resizeEvent( QResizeEvent * );
    virtual void drawFrame( QPainter * );
    virtual void drawContents( QPainter * );
    virtual void frameChanged();
    void	updateMask();
    virtual void drawFrameMask( QPainter * );
    virtual void drawContentsMask( QPainter * );

private:
    void	updateFrameWidth();
    QRect	frect;
    int		fstyle;
    short	lwidth;
    short	mwidth;
    short	mlwidth;
    short	fwidth;

    void * d;
private:	



#line 134 "c:\\qt\\include\\qframe.h"
};


inline int QFrame::frameStyle() const
{ return fstyle; }

inline QFrame::Shape QFrame::frameShape() const
{ return (Shape) ( fstyle & MShape ); }

inline QFrame::Shadow QFrame::frameShadow() const
{ return (Shadow) ( fstyle & MShadow ); }

inline void QFrame::setFrameShape( QFrame::Shape s )
{ setFrameStyle( ( fstyle & MShadow ) | s ); }

inline void QFrame::setFrameShadow( QFrame::Shadow s )
{ setFrameStyle( ( fstyle & MShape ) | s ); }

inline int QFrame::lineWidth() const
{ return lwidth; }

inline int QFrame::midLineWidth() const
{ return mlwidth; }

inline int QFrame::margin() const
{ return mwidth; }

inline int QFrame::frameWidth() const
{ return fwidth; }


#line 166 "c:\\qt\\include\\qframe.h"

#line 168 "c:\\qt\\include\\qframe.h"
#line 12 "h:\\c_projekte\\elansim\\headview.cpp"
#line 1 "c:\\qt\\include\\qslider.h"









































#line 1 "c:\\qt\\include\\qwidget.h"




















































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 43 "c:\\qt\\include\\qslider.h"
#line 1 "c:\\qt\\include\\qrangecontrol.h"









































#line 1 "c:\\qt\\include\\qglobal.h"


























































































































































































































































































































































































































































































































































































































































#line 43 "c:\\qt\\include\\qrangecontrol.h"
#line 44 "c:\\qt\\include\\qrangecontrol.h"




class QRangeControlPrivate;


class __declspec(dllimport) QRangeControl
{
public:
    QRangeControl();
    QRangeControl( int minValue, int maxValue,
		   int lineStep, int pageStep, int value );

    int		value()		const;
    void	setValue( int );
    void	addPage();
    void	subtractPage();
    void	addLine();
    void	subtractLine();

    int		minValue()	const;
    int		maxValue()	const;
    void	setRange( int minValue, int maxValue );

    int		lineStep()	const;
    int		pageStep()	const;
    void	setSteps( int line, int page );

    int		bound( int ) const;

protected:
    int		positionFromValue( int val, int space ) const;
    int		valueFromPosition( int pos, int space ) const;
    void	directSetValue( int val );
    int		prevValue()	const;

    virtual void valueChange();
    virtual void rangeChange();
    virtual void stepChange();

private:
    int		minVal, maxVal;
    int		line, page;
    int		val, prevVal;

    QRangeControlPrivate * d;

private:	



#line 97 "c:\\qt\\include\\qrangecontrol.h"
};


inline int QRangeControl::value() const
{ return val; }

inline int QRangeControl::prevValue() const
{ return prevVal; }

inline int QRangeControl::minValue() const
{ return minVal; }

inline int QRangeControl::maxValue() const
{ return maxVal; }

inline int QRangeControl::lineStep() const
{ return line; }

inline int QRangeControl::pageStep() const
{ return page; }


#line 120 "c:\\qt\\include\\qrangecontrol.h"

#line 122 "c:\\qt\\include\\qrangecontrol.h"
#line 44 "c:\\qt\\include\\qslider.h"
#line 45 "c:\\qt\\include\\qslider.h"




class QTimer;
struct QSliderData;


class __declspec(dllimport) QSlider : public QWidget, public QRangeControl
{
    public: QMetaObject *metaObject() const { return staticMetaObject(); } const char *className() const; static QMetaObject* staticMetaObject(); static QString tr(const char*); static QString tr(const char*, const char*); protected: void initMetaObject(); private: static QMetaObject *metaObj;
    
    
    
    
    
    
    
    
    
    
	
public:
    enum TickSetting { NoMarks = 0, Above = 1, Left = Above,
		       Below = 2, Right = Below, Both = 3 };
    QSlider( QWidget *parent, const char *name=0 );
    QSlider( Orientation, QWidget *parent, const char *name=0 );
    QSlider( int minValue, int maxValue, int pageStep, int value, Orientation,
	     QWidget *parent, const char *name=0 );

    virtual void	setOrientation( Orientation );
    Orientation orientation() const;
    virtual void	setTracking( bool enable );
    bool	tracking() const;
    virtual void 	setPalette( const QPalette & );
    QRect	sliderRect() const;
    QSize	sizeHint() const;
    QSizePolicy sizePolicy() const;
    QSize	minimumSizeHint() const;

    virtual void setTickmarks( TickSetting );
    TickSetting tickmarks() const { return ticks; }

    virtual void setTickInterval( int );
    int 	tickInterval() const { return tickInt; }

    int	 minValue() const;
    int	 maxValue() const;
    void setMinValue( int );
    void setMaxValue( int );
    int	 lineStep() const;
    int	 pageStep() const;
    void setLineStep( int );
    void setPageStep( int );
    int  value() const;

public :
    virtual void	setValue( int );
    void	addStep();
    void	subtractStep();

protected:
    void	valueChanged( int value );
    void	sliderPressed();
    void	sliderMoved( int value );
    void	sliderReleased();

protected:
    void	resizeEvent( QResizeEvent * );
    void	paintEvent( QPaintEvent * );

    void	keyPressEvent( QKeyEvent * );
    void	mousePressEvent( QMouseEvent * );
    void	mouseReleaseEvent( QMouseEvent * );
    void	mouseMoveEvent( QMouseEvent * );
    void	wheelEvent( QWheelEvent * );
    void	focusInEvent( QFocusEvent *e );
    void	focusOutEvent( QFocusEvent *e );

    void updateMask();
    void styleChange( QStyle& );

    void	valueChange();
    void	rangeChange();

    virtual void paintSlider( QPainter *, const QColorGroup&, const QRect & );
    void	drawTicks( QPainter *, const QColorGroup&, int, int, int=1 ) const;

    void	drawWinGroove( QPainter *,  QCOORD );
    void	drawTicks( QPainter *,  int, int, int=1 ) const;

    virtual int	thickness() const;


private :
    void	repeatTimeout();

private:
    enum State { Idle, Dragging, TimingUp, TimingDown };

    void	init();
    int		positionFromValue( int ) const;
    int		valueFromPosition( int ) const;
    void	moveSlider( int );
    void	reallyMoveSlider( int );
    void	resetState();
    int		slideLength() const;
    int		available() const;
    int		goodPart( const QPoint& ) const;
    void	initTicks();

    QSliderData *extra;
    QTimer	*timer;
    QCOORD	sliderPos;
    int		sliderVal;
    QCOORD	clickOffset;
    State	state;
    bool	track;
    QCOORD	tickOffset;
    TickSetting	ticks;
    int		tickInt;
    Orientation orient;

private:	



#line 173 "c:\\qt\\include\\qslider.h"
};

inline bool QSlider::tracking() const
{
    return track;
}

inline QSlider::Orientation QSlider::orientation() const
{
    return orient;
}


#line 187 "c:\\qt\\include\\qslider.h"

#line 189 "c:\\qt\\include\\qslider.h"
#line 13 "h:\\c_projekte\\elansim\\headview.cpp"
#line 1 "c:\\qt\\include\\qlayout.h"









































#line 1 "c:\\qt\\include\\qabstractlayout.h"









































#line 1 "c:\\qt\\include\\qobject.h"























































































































































































































































#line 43 "c:\\qt\\include\\qabstractlayout.h"
#line 1 "c:\\qt\\include\\qsizepolicy.h"







































































































#line 44 "c:\\qt\\include\\qabstractlayout.h"
#line 1 "c:\\qt\\include\\qwidget.h"




















































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 45 "c:\\qt\\include\\qabstractlayout.h"
#line 46 "c:\\qt\\include\\qabstractlayout.h"



class QMenuBar;
class QWidget;
struct QLayoutData;
class QLayoutItem;
class QLayout;
class QSpacerItem;
class QDomElement;
class QConfigureLayoutEvent;

class __declspec(dllimport) QGLayoutIterator : public QShared
{
public:
    virtual ~QGLayoutIterator();
    virtual QLayoutItem *next() = 0;
    virtual QLayoutItem *current() = 0;
    virtual QLayoutItem *takeCurrent() = 0;
};

class __declspec(dllimport) QLayoutIterator
{
public:
    QLayoutIterator( QGLayoutIterator *i ) :it(i) {}
    QLayoutIterator( const QLayoutIterator &i ) :it( i.it )
    { if ( it ) it->ref(); }
    ~QLayoutIterator() { if ( it && it->deref() ) delete it; }
    QLayoutIterator &operator=( const QLayoutIterator &i )
    {
	if ( i.it ) i.it->ref();
	if ( it && it->deref() ) delete it;
	it = i.it;
	return *this;
    }
    QLayoutItem *operator++() { return it ? it->next() : 0; }
    QLayoutItem *current() { return it ? it->current() : 0; }
    QLayoutItem *takeCurrent() { return it ? it->takeCurrent() : 0; }
    void deleteCurrent();
private:
    QGLayoutIterator *it;
};


class __declspec(dllimport) QLayoutItem
{
public:
    QLayoutItem( int alignment = 0 ) :align(alignment) {}
    virtual ~QLayoutItem();
    virtual QSize sizeHint() const = 0;
    virtual QSize minimumSize() const = 0;
    virtual QSize maximumSize() const = 0;
    virtual QSizePolicy::ExpandData expanding() const =0;
    virtual void setGeometry( const QRect& ) = 0;
    virtual QRect geometry() const = 0;
    virtual bool isEmpty() const = 0;
    virtual bool hasHeightForWidth() const;
    virtual int heightForWidth( int ) const;
    virtual void invalidate();

    virtual QWidget *widget();
    virtual QLayoutIterator iterator();
    virtual QLayout *layout();
    virtual QSpacerItem *spacerItem();

    int alignment() const { return align; }
    virtual void setAlignment( int a );
protected:
    int align;
};


class __declspec(dllimport) QSpacerItem : public QLayoutItem
{
 public:
    QSpacerItem( int w, int h,
		 QSizePolicy::SizeType hData=QSizePolicy::Minimum,
		 QSizePolicy::SizeType vData= QSizePolicy::Minimum )
	:width(w), height(h), sizeP(hData, vData )
	{}
    void changeSize( int w, int h,
		QSizePolicy::SizeType hData=QSizePolicy::Minimum,
		QSizePolicy::SizeType vData=QSizePolicy::Minimum );
    QSize sizeHint() const ;
    QSize minimumSize() const ;
    QSize maximumSize() const ;
    QSizePolicy::ExpandData expanding() const;
    bool isEmpty() const;
    void setGeometry( const QRect& );
    QRect geometry() const;
    QSpacerItem *spacerItem();
private:
    int width, height;
    QSizePolicy sizeP;
    QRect rect;
};


class __declspec(dllimport) QWidgetItem : public QLayoutItem
{
public:
    QWidgetItem( QWidget *w ) : wid(w) {}
    QSize sizeHint() const ;
    QSize minimumSize() const ;
    QSize maximumSize() const ;
    QSizePolicy::ExpandData expanding() const;
    bool isEmpty() const;
    void setGeometry( const QRect& ) ;
    QRect geometry() const;
    
    virtual QWidget *widget();

    bool hasHeightForWidth() const;
    int heightForWidth( int ) const;

    const QSize &widgetSizeHint() const;

private:
    
    QWidget *wid;
};


class __declspec(dllimport) QLayout : public QObject, public QLayoutItem
{
    public: QMetaObject *metaObject() const { return staticMetaObject(); } const char *className() const; static QMetaObject* staticMetaObject(); static QString tr(const char*); static QString tr(const char*, const char*); protected: void initMetaObject(); private: static QMetaObject *metaObj;
    
    
    
    

public:
    QLayout( QWidget *parent, int margin=0, int space=-1,
	     const char *name=0 );
    QLayout( QLayout *parentLayout, int space=-1, const char *name=0 );
    QLayout( int space=-1, const char *name=0 );

    ~QLayout();

    int margin() const { return outsideBorder; }
    int spacing() const { return insideSpacing; }

    virtual void setMargin( int );
    virtual void setSpacing( int );

    enum { unlimited = 32767 };

    int defaultBorder() const { return insideSpacing; }
    void freeze( int w, int h );
    void freeze() { setResizeMode( Fixed ); }
#line 197 "c:\\qt\\include\\qabstractlayout.h"

    enum ResizeMode { FreeResize, Minimum, Fixed };
    void setResizeMode( ResizeMode );
    ResizeMode resizeMode() const;


    virtual void  setMenuBar( QMenuBar *w );
    QMenuBar *menuBar() const { return menubar; }
#line 206 "c:\\qt\\include\\qabstractlayout.h"

    QWidget *mainWidget();
    bool isTopLevel() const { return topLevel; }

    virtual void setAutoAdd( bool );
    bool autoAdd() const { return autoNewChild; }

    void invalidate();
    QRect geometry() const;
    bool activate();

    void add( QWidget *w ) { addItem( new QWidgetItem( w ) ); }
    virtual void addItem ( QLayoutItem * ) = 0;

    QSizePolicy::ExpandData expanding() const;
    QSize minimumSize() const;
    QSize maximumSize() const;
    void setGeometry( const QRect& )=0;
    QLayoutIterator iterator()=0;
    bool isEmpty() const;

    int totalHeightForWidth( int w ) const;
    QSize totalMinimumSize() const;
    QSize totalMaximumSize() const;
    QSize totalSizeHint() const;
    QLayout *layout();

    bool supportsMargin() const { return marginImpl; }
    
    void setEnabled( bool );
    bool isEnabled() const;

protected:
    bool  eventFilter( QObject *, QEvent * );
    void addChildLayout( QLayout *l );
    void deleteAllItems();

    void setSupportsMargin( bool );
    QRect alignmentRect( const QRect& ) const;
private:
    void setWidgetLayout( QWidget *, QLayout * );
    void init();
    int insideSpacing;
    int outsideBorder;
    uint topLevel : 1;
    uint autoMinimum : 1;
    uint autoNewChild : 1;
    uint frozen : 1;
    uint activated : 1;
    uint marginImpl : 1;
    uint enabled : 1;
    QRect rect;
    QLayoutData *extraData;

    QMenuBar *menubar;
#line 262 "c:\\qt\\include\\qabstractlayout.h"
private:	



#line 267 "c:\\qt\\include\\qabstractlayout.h"

};

inline void QLayoutIterator::deleteCurrent()
{
    delete takeCurrent();
}
#line 275 "c:\\qt\\include\\qabstractlayout.h"
#line 276 "c:\\qt\\include\\qabstractlayout.h"
#line 43 "c:\\qt\\include\\qlayout.h"
#line 44 "c:\\qt\\include\\qlayout.h"


class QLayoutArray;
class QLayoutBox;



#line 52 "c:\\qt\\include\\qlayout.h"

class __declspec(dllimport) QGridLayout : public QLayout
{
    public: QMetaObject *metaObject() const { return staticMetaObject(); } const char *className() const; static QMetaObject* staticMetaObject(); static QString tr(const char*); static QString tr(const char*, const char*); protected: void initMetaObject(); private: static QMetaObject *metaObj;
public:
    QGridLayout( QWidget *parent, int nRows = 1, int nCols = 1, int border=0,
		 int space = -1, const char *name=0 );
    QGridLayout( int nRows = 1, int nCols = 1, int space = -1,
		 const char *name=0 );
    QGridLayout( QLayout *parentLayout, int nRows = 1, int nCols = 1,
		 int space = -1, const char *name=0 );
    ~QGridLayout();

    QSize sizeHint() const;
    QSize minimumSize() const;
    QSize maximumSize() const;

    virtual void setRowStretch( int row, int stretch );
    virtual void setColStretch( int col, int stretch );
    int rowStretch( int row ) const;
    int colStretch( int col ) const;

    int numRows() const;
    int numCols() const;
    QRect cellGeometry( int row, int col ) const;

    bool hasHeightForWidth() const;
    int heightForWidth( int ) const;


    QSizePolicy::ExpandData expanding() const;
    void invalidate();

    void addItem( QLayoutItem * );
    void addItem( QLayoutItem *item, int row, int col );
    void addMultiCell( QLayoutItem *, int fromRow, int toRow,
			       int fromCol, int toCol, int align = 0 );
    

    void addWidget( QWidget *, int row, int col, int align = 0 );
    void addMultiCellWidget( QWidget *, int fromRow, int toRow,
			     int fromCol, int toCol, int align = 0 );
    void addLayout( QLayout *layout, int row, int col);
    void addMultiCellLayout( QLayout *layout, int fromRow, int toRow,
			     int fromCol, int toCol, int align = 0 );
    void addRowSpacing( int row, int minsize );
    void addColSpacing( int col, int minsize );
    void expand( int rows, int cols );

    enum Corner { TopLeft, TopRight, BottomLeft, BottomRight };
    void setOrigin( Corner );
    QLayoutIterator iterator();
    void setGeometry( const QRect& );

protected:
    bool findWidget( QWidget* w, int *r, int *c );
    void add( QLayoutItem*, int row, int col );
private:
    void init( int rows, int cols );
    QLayoutArray *array;

private:	



#line 118 "c:\\qt\\include\\qlayout.h"
};


class QBoxLayoutData;

class __declspec(dllimport) QBoxLayout : public QLayout
{
    public: QMetaObject *metaObject() const { return staticMetaObject(); } const char *className() const; static QMetaObject* staticMetaObject(); static QString tr(const char*); static QString tr(const char*, const char*); protected: void initMetaObject(); private: static QMetaObject *metaObj;
public:
    enum Direction { LeftToRight, RightToLeft, TopToBottom, BottomToTop,
		     Down = TopToBottom, Up = BottomToTop };

    QBoxLayout( QWidget *parent, Direction, int border=0,
		int space = -1, const char *name=0 );

    QBoxLayout( QLayout *parentLayout, Direction, int space = -1,
		const char *name=0 );

    QBoxLayout(	Direction, int space = -1,
		const char *name=0 );

    ~QBoxLayout();

    void addItem( QLayoutItem * );

    Direction direction() const { return dir; }
    void setDirection( Direction );

    void addSpacing( int size );
    void addStretch( int stretch = 0 );
    void addWidget( QWidget *, int stretch = 0, int alignment = 0 );
    void addLayout( QLayout *layout, int stretch = 0 );
    void addStrut( int );

    void insertSpacing( int index, int size );
    void insertStretch( int index, int stretch = 0 );
    void insertWidget( int index, QWidget *widget, int stretch = 0,
		       int alignment = 0 );
    void insertLayout( int index, QLayout *layout, int stretch = 0 );


    bool setStretchFactor( QWidget*, int stretch );
    bool setStretchFactor( QLayout *l, int stretch );

    QSize sizeHint() const;
    QSize minimumSize() const;
    QSize maximumSize() const;

    bool hasHeightForWidth() const;
    int heightForWidth( int ) const;

    QSizePolicy::ExpandData expanding() const;
    void invalidate();
    QLayoutIterator iterator();
    void setGeometry( const QRect& );

    int findWidget( QWidget* w );
protected:
    void insertItem( int index, QLayoutItem * );

private:
    void setupGeom();
    int calcHfw( int );
    QBoxLayoutData *data;
    Direction dir;
private:	



#line 188 "c:\\qt\\include\\qlayout.h"

};


class __declspec(dllimport) QHBoxLayout : public QBoxLayout
{
    public: QMetaObject *metaObject() const { return staticMetaObject(); } const char *className() const; static QMetaObject* staticMetaObject(); static QString tr(const char*); static QString tr(const char*, const char*); protected: void initMetaObject(); private: static QMetaObject *metaObj;
public:
    QHBoxLayout( QWidget *parent, int border=0,
		int space = -1, const char *name=0 );
    QHBoxLayout( QLayout *parentLayout,
		 int space = -1, const char *name=0 );
    QHBoxLayout( int space = -1, const char *name=0 );

    ~QHBoxLayout();

};



class __declspec(dllimport) QVBoxLayout : public QBoxLayout
{
    public: QMetaObject *metaObject() const { return staticMetaObject(); } const char *className() const; static QMetaObject* staticMetaObject(); static QString tr(const char*); static QString tr(const char*, const char*); protected: void initMetaObject(); private: static QMetaObject *metaObj;
public:
    QVBoxLayout( QWidget *parent, int border=0,
		int space = -1, const char *name=0 );
    QVBoxLayout( QLayout *parentLayout,
		 int space = -1, const char *name=0 );
    QVBoxLayout( int space = -1, const char *name=0 );

    ~QVBoxLayout();

};



#line 225 "c:\\qt\\include\\qlayout.h"
#line 226 "c:\\qt\\include\\qlayout.h"
#line 14 "h:\\c_projekte\\elansim\\headview.cpp"
#line 1 "c:\\qt\\include\\qvariant.h"

































































































































































































































































































































#line 15 "h:\\c_projekte\\elansim\\headview.cpp"
#line 1 "c:\\qt\\include\\qtooltip.h"







































#line 1 "c:\\qt\\include\\qwidget.h"




















































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 41 "c:\\qt\\include\\qtooltip.h"
#line 1 "c:\\qt\\include\\qtimer.h"









































#line 1 "c:\\qt\\include\\qobject.h"























































































































































































































































#line 43 "c:\\qt\\include\\qtimer.h"
#line 44 "c:\\qt\\include\\qtimer.h"


class __declspec(dllimport) QTimer : public QObject
{
    public: QMetaObject *metaObject() const { return staticMetaObject(); } const char *className() const; static QMetaObject* staticMetaObject(); static QString tr(const char*); static QString tr(const char*, const char*); protected: void initMetaObject(); private: static QMetaObject *metaObj;
public:
    QTimer( QObject *parent=0, const char *name=0 );
   ~QTimer();

    bool	isActive() const;

    int		start( int msec, bool sshot = FALSE );
    void	changeInterval( int msec );
    void	stop();

    static void singleShot( int msec, QObject *receiver, const char *member );

protected:
    void	timeout();

protected:
    bool	event( QEvent * );

private:
    int		id;
    bool	single;

private:	



#line 76 "c:\\qt\\include\\qtimer.h"
};


inline bool QTimer::isActive() const
{
    return id >= 0;
}


#line 86 "c:\\qt\\include\\qtimer.h"
#line 42 "c:\\qt\\include\\qtooltip.h"
#line 43 "c:\\qt\\include\\qtooltip.h"




class QTipManager;
class QLabel;
class QIconViewToolTip;

class __declspec(dllimport) QToolTipGroup: public QObject
{
    public: QMetaObject *metaObject() const { return staticMetaObject(); } const char *className() const; static QMetaObject* staticMetaObject(); static QString tr(const char*); static QString tr(const char*, const char*); protected: void initMetaObject(); private: static QMetaObject *metaObj;
    
    

public:
    QToolTipGroup( QObject *parent, const char *name = 0 );
   ~QToolTipGroup();

    bool delay() const;
    bool enabled() const;

public :
    void setDelay( bool );
    void setEnabled( bool );

protected:
    void showTip( const QString &);
    void removeTip();

private:
    uint del:1;
    uint ena:1;

    friend class QTipManager;

private:	



#line 83 "c:\\qt\\include\\qtooltip.h"
};


class __declspec(dllimport) QToolTip: public Qt
{
public:
    QToolTip( QWidget *, QToolTipGroup * = 0 );

    static void add( QWidget *, const QString &);
    static void add( QWidget *, const QString &,
		     QToolTipGroup *, const QString& );
    static void remove( QWidget * );

    static void add( QWidget *, const QRect &, const QString &);
    static void add( QWidget *, const QRect &, const QString &,
		     QToolTipGroup *, const QString& );
    static void remove( QWidget *, const QRect & );

    static void hide();

    static QFont    font();
    static void	    setFont( const QFont & );
    static QPalette palette();
    static void	    setPalette( const QPalette & );

    static void	    setEnabled( bool );
    static bool	    enabled();

protected:
    virtual void maybeTip( const QPoint & ) = 0;
    void    tip( const QRect &, const QString &);
    void    tip( const QRect &, const QString& , const QString &);
    void    clear();

public:
    QWidget	  *parentWidget() const { return p; }
    QToolTipGroup *group()	  const { return g; }

private:
    void    tip( const QRect &, const QRect &, const QString &);
    QWidget	    *p;
    QToolTipGroup   *g;
    static QFont    *ttFont;
    static QPalette *ttPalette;

    static void initialize();
    static void cleanup();

    friend class QTipManager;
    friend class QIconViewToolTip;
};


#line 137 "c:\\qt\\include\\qtooltip.h"

#line 139 "c:\\qt\\include\\qtooltip.h"
#line 16 "h:\\c_projekte\\elansim\\headview.cpp"
#line 1 "c:\\qt\\include\\qwhatsthis.h"







































#line 1 "c:\\qt\\include\\qobject.h"























































































































































































































































#line 41 "c:\\qt\\include\\qwhatsthis.h"
#line 42 "c:\\qt\\include\\qwhatsthis.h"



#line 1 "c:\\qt\\include\\qcursor.h"















































































































































#line 46 "c:\\qt\\include\\qwhatsthis.h"

class QToolButton;
class QPopupMenu;
class QStyleSheet;

class __declspec(dllimport) QWhatsThis: public Qt
{
public:
    QWhatsThis( QWidget *);
    virtual ~QWhatsThis();

    virtual QString text( const QPoint & );

    
    static void add( QWidget *, const QString &);
    static void remove( QWidget * );
    static QString textFor( QWidget *, const QPoint & pos = QPoint() );

    static QToolButton * whatsThisButton( QWidget * parent );

    static void enterWhatsThisMode();
    static bool inWhatsThisMode();
    static void leaveWhatsThisMode( const QString& = QString::null, const QPoint& pos = QCursor::pos() );

};

#line 73 "c:\\qt\\include\\qwhatsthis.h"

#line 75 "c:\\qt\\include\\qwhatsthis.h"
#line 17 "h:\\c_projekte\\elansim\\headview.cpp"

#line 1 "c:\\coin3d\\include\\inventor\\qt\\soqtrenderarea.h"




























#line 1 "c:\\coin3d\\include\\inventor\\sbcolor.h"


























#line 1 "c:\\coin3d\\include\\inventor\\system\\inttypes.h"









































































































#line 107 "c:\\coin3d\\include\\inventor\\system\\inttypes.h"












#line 120 "c:\\coin3d\\include\\inventor\\system\\inttypes.h"

#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\sys\\types.h"















#pragma once
#line 18 "c:\\programme\\microsoft visual studio\\vc98\\include\\sys\\types.h"






#line 25 "c:\\programme\\microsoft visual studio\\vc98\\include\\sys\\types.h"



typedef long time_t;

#line 31 "c:\\programme\\microsoft visual studio\\vc98\\include\\sys\\types.h"




typedef unsigned short _ino_t;          



typedef unsigned short ino_t;
#line 41 "c:\\programme\\microsoft visual studio\\vc98\\include\\sys\\types.h"


#line 44 "c:\\programme\\microsoft visual studio\\vc98\\include\\sys\\types.h"




typedef unsigned int _dev_t;            



typedef unsigned int dev_t;
#line 54 "c:\\programme\\microsoft visual studio\\vc98\\include\\sys\\types.h"


#line 57 "c:\\programme\\microsoft visual studio\\vc98\\include\\sys\\types.h"




typedef long _off_t;                    



typedef long off_t;
#line 67 "c:\\programme\\microsoft visual studio\\vc98\\include\\sys\\types.h"


#line 70 "c:\\programme\\microsoft visual studio\\vc98\\include\\sys\\types.h"

#line 72 "c:\\programme\\microsoft visual studio\\vc98\\include\\sys\\types.h"
#line 122 "c:\\coin3d\\include\\inventor\\system\\inttypes.h"
#line 123 "c:\\coin3d\\include\\inventor\\system\\inttypes.h"

#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\stddef.h"















#pragma once
#line 18 "c:\\programme\\microsoft visual studio\\vc98\\include\\stddef.h"






#line 25 "c:\\programme\\microsoft visual studio\\vc98\\include\\stddef.h"



extern "C" {
#line 30 "c:\\programme\\microsoft visual studio\\vc98\\include\\stddef.h"

















#line 48 "c:\\programme\\microsoft visual studio\\vc98\\include\\stddef.h"





























__declspec(dllimport) extern int * __cdecl _errno(void);



#line 82 "c:\\programme\\microsoft visual studio\\vc98\\include\\stddef.h"





typedef int ptrdiff_t;

#line 90 "c:\\programme\\microsoft visual studio\\vc98\\include\\stddef.h"















__declspec(dllimport) extern unsigned long  __cdecl __threadid(void);

__declspec(dllimport) extern unsigned long  __cdecl __threadhandle(void);
#line 109 "c:\\programme\\microsoft visual studio\\vc98\\include\\stddef.h"



}
#line 114 "c:\\programme\\microsoft visual studio\\vc98\\include\\stddef.h"

#line 116 "c:\\programme\\microsoft visual studio\\vc98\\include\\stddef.h"
#line 125 "c:\\coin3d\\include\\inventor\\system\\inttypes.h"
#line 126 "c:\\coin3d\\include\\inventor\\system\\inttypes.h"



typedef char int8_t;

#line 132 "c:\\coin3d\\include\\inventor\\system\\inttypes.h"


typedef unsigned char uint8_t;

#line 137 "c:\\coin3d\\include\\inventor\\system\\inttypes.h"


typedef short int16_t;

#line 142 "c:\\coin3d\\include\\inventor\\system\\inttypes.h"


typedef unsigned short uint16_t;

#line 147 "c:\\coin3d\\include\\inventor\\system\\inttypes.h"


typedef int int32_t;

#line 152 "c:\\coin3d\\include\\inventor\\system\\inttypes.h"


typedef unsigned int uint32_t;

#line 157 "c:\\coin3d\\include\\inventor\\system\\inttypes.h"


typedef __int64 int64_t;

#line 162 "c:\\coin3d\\include\\inventor\\system\\inttypes.h"


typedef unsigned __int64 uint64_t;

#line 167 "c:\\coin3d\\include\\inventor\\system\\inttypes.h"


typedef int intptr_t;

#line 172 "c:\\coin3d\\include\\inventor\\system\\inttypes.h"


typedef unsigned int uintptr_t;

#line 177 "c:\\coin3d\\include\\inventor\\system\\inttypes.h"

#line 179 "c:\\coin3d\\include\\inventor\\system\\inttypes.h"
#line 28 "c:\\coin3d\\include\\inventor\\sbcolor.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbvec3f.h"


























#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"















#pragma once
#line 18 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"






#line 25 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"







#pragma pack(push,8)
#line 34 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"


extern "C" {
#line 38 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"


















#line 57 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"


























typedef wchar_t wint_t;
typedef wchar_t wctype_t;

#line 87 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"
#line 88 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"









typedef char *  va_list;
#line 99 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"

#line 101 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"






#line 108 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"

#line 110 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"






























#line 141 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"





struct _iobuf {
        char *_ptr;
        int   _cnt;
        char *_base;
        int   _flag;
        int   _file;
        int   _charbuf;
        int   _bufsiz;
        char *_tmpfname;
        };
typedef struct _iobuf FILE;

#line 159 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"












#line 172 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"












#line 185 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"



































__declspec(dllimport) extern FILE _iob[];
#line 222 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"









#line 232 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"


typedef __int64 fpos_t;







#line 243 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"
#line 244 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"


#line 247 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"




























__declspec(dllimport) int __cdecl _filbuf(FILE *);
__declspec(dllimport) int __cdecl _flsbuf(int, FILE *);




__declspec(dllimport) FILE * __cdecl _fsopen(const char *, const char *, int);
#line 283 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"

__declspec(dllimport) void __cdecl clearerr(FILE *);
__declspec(dllimport) int __cdecl fclose(FILE *);
__declspec(dllimport) int __cdecl _fcloseall(void);




__declspec(dllimport) FILE * __cdecl _fdopen(int, const char *);
#line 293 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"

__declspec(dllimport) int __cdecl feof(FILE *);
__declspec(dllimport) int __cdecl ferror(FILE *);
__declspec(dllimport) int __cdecl fflush(FILE *);
__declspec(dllimport) int __cdecl fgetc(FILE *);
__declspec(dllimport) int __cdecl _fgetchar(void);
__declspec(dllimport) int __cdecl fgetpos(FILE *, fpos_t *);
__declspec(dllimport) char * __cdecl fgets(char *, int, FILE *);




__declspec(dllimport) int __cdecl _fileno(FILE *);
#line 307 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"

__declspec(dllimport) int __cdecl _flushall(void);
__declspec(dllimport) FILE * __cdecl fopen(const char *, const char *);
__declspec(dllimport) int __cdecl fprintf(FILE *, const char *, ...);
__declspec(dllimport) int __cdecl fputc(int, FILE *);
__declspec(dllimport) int __cdecl _fputchar(int);
__declspec(dllimport) int __cdecl fputs(const char *, FILE *);
__declspec(dllimport) size_t __cdecl fread(void *, size_t, size_t, FILE *);
__declspec(dllimport) FILE * __cdecl freopen(const char *, const char *, FILE *);
__declspec(dllimport) int __cdecl fscanf(FILE *, const char *, ...);
__declspec(dllimport) int __cdecl fsetpos(FILE *, const fpos_t *);
__declspec(dllimport) int __cdecl fseek(FILE *, long, int);
__declspec(dllimport) long __cdecl ftell(FILE *);
__declspec(dllimport) size_t __cdecl fwrite(const void *, size_t, size_t, FILE *);
__declspec(dllimport) int __cdecl getc(FILE *);
__declspec(dllimport) int __cdecl getchar(void);
__declspec(dllimport) int __cdecl _getmaxstdio(void);
__declspec(dllimport) char * __cdecl gets(char *);
__declspec(dllimport) int __cdecl _getw(FILE *);
__declspec(dllimport) void __cdecl perror(const char *);
__declspec(dllimport) int __cdecl _pclose(FILE *);
__declspec(dllimport) FILE * __cdecl _popen(const char *, const char *);
__declspec(dllimport) int __cdecl printf(const char *, ...);
__declspec(dllimport) int __cdecl putc(int, FILE *);
__declspec(dllimport) int __cdecl putchar(int);
__declspec(dllimport) int __cdecl puts(const char *);
__declspec(dllimport) int __cdecl _putw(int, FILE *);
__declspec(dllimport) int __cdecl remove(const char *);
__declspec(dllimport) int __cdecl rename(const char *, const char *);
__declspec(dllimport) void __cdecl rewind(FILE *);
__declspec(dllimport) int __cdecl _rmtmp(void);
__declspec(dllimport) int __cdecl scanf(const char *, ...);
__declspec(dllimport) void __cdecl setbuf(FILE *, char *);
__declspec(dllimport) int __cdecl _setmaxstdio(int);
__declspec(dllimport) int __cdecl setvbuf(FILE *, char *, int, size_t);
__declspec(dllimport) int __cdecl _snprintf(char *, size_t, const char *, ...);
__declspec(dllimport) int __cdecl sprintf(char *, const char *, ...);
__declspec(dllimport) int __cdecl sscanf(const char *, const char *, ...);
__declspec(dllimport) char * __cdecl _tempnam(const char *, const char *);
__declspec(dllimport) FILE * __cdecl tmpfile(void);
__declspec(dllimport) char * __cdecl tmpnam(char *);
__declspec(dllimport) int __cdecl ungetc(int, FILE *);
__declspec(dllimport) int __cdecl _unlink(const char *);
__declspec(dllimport) int __cdecl vfprintf(FILE *, const char *, va_list);
__declspec(dllimport) int __cdecl vprintf(const char *, va_list);
__declspec(dllimport) int __cdecl _vsnprintf(char *, size_t, const char *, va_list);
__declspec(dllimport) int __cdecl vsprintf(char *, const char *, va_list);








#line 363 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"




__declspec(dllimport) FILE * __cdecl _wfsopen(const wchar_t *, const wchar_t *, int);
#line 369 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"

__declspec(dllimport) wint_t __cdecl fgetwc(FILE *);
__declspec(dllimport) wint_t __cdecl _fgetwchar(void);
__declspec(dllimport) wint_t __cdecl fputwc(wint_t, FILE *);
__declspec(dllimport) wint_t __cdecl _fputwchar(wint_t);
__declspec(dllimport) wint_t __cdecl getwc(FILE *);
__declspec(dllimport) wint_t __cdecl getwchar(void);
__declspec(dllimport) wint_t __cdecl putwc(wint_t, FILE *);
__declspec(dllimport) wint_t __cdecl putwchar(wint_t);
__declspec(dllimport) wint_t __cdecl ungetwc(wint_t, FILE *);

__declspec(dllimport) wchar_t * __cdecl fgetws(wchar_t *, int, FILE *);
__declspec(dllimport) int __cdecl fputws(const wchar_t *, FILE *);
__declspec(dllimport) wchar_t * __cdecl _getws(wchar_t *);
__declspec(dllimport) int __cdecl _putws(const wchar_t *);

__declspec(dllimport) int __cdecl fwprintf(FILE *, const wchar_t *, ...);
__declspec(dllimport) int __cdecl wprintf(const wchar_t *, ...);
__declspec(dllimport) int __cdecl _snwprintf(wchar_t *, size_t, const wchar_t *, ...);
__declspec(dllimport) int __cdecl swprintf(wchar_t *, const wchar_t *, ...);
__declspec(dllimport) int __cdecl vfwprintf(FILE *, const wchar_t *, va_list);
__declspec(dllimport) int __cdecl vwprintf(const wchar_t *, va_list);
__declspec(dllimport) int __cdecl _vsnwprintf(wchar_t *, size_t, const wchar_t *, va_list);
__declspec(dllimport) int __cdecl vswprintf(wchar_t *, const wchar_t *, va_list);
__declspec(dllimport) int __cdecl fwscanf(FILE *, const wchar_t *, ...);
__declspec(dllimport) int __cdecl swscanf(const wchar_t *, const wchar_t *, ...);
__declspec(dllimport) int __cdecl wscanf(const wchar_t *, ...);






__declspec(dllimport) FILE * __cdecl _wfdopen(int, const wchar_t *);
__declspec(dllimport) FILE * __cdecl _wfopen(const wchar_t *, const wchar_t *);
__declspec(dllimport) FILE * __cdecl _wfreopen(const wchar_t *, const wchar_t *, FILE *);
__declspec(dllimport) void __cdecl _wperror(const wchar_t *);
__declspec(dllimport) FILE * __cdecl _wpopen(const wchar_t *, const wchar_t *);
__declspec(dllimport) int __cdecl _wremove(const wchar_t *);
__declspec(dllimport) wchar_t * __cdecl _wtempnam(const wchar_t *, const wchar_t *);
__declspec(dllimport) wchar_t * __cdecl _wtmpnam(wchar_t *);



#line 414 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"
#line 415 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"


#line 418 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"





















#line 440 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"










__declspec(dllimport) int __cdecl fcloseall(void);
__declspec(dllimport) FILE * __cdecl fdopen(int, const char *);
__declspec(dllimport) int __cdecl fgetchar(void);
__declspec(dllimport) int __cdecl fileno(FILE *);
__declspec(dllimport) int __cdecl flushall(void);
__declspec(dllimport) int __cdecl fputchar(int);
__declspec(dllimport) int __cdecl getw(FILE *);
__declspec(dllimport) int __cdecl putw(int, FILE *);
__declspec(dllimport) int __cdecl rmtmp(void);
__declspec(dllimport) char * __cdecl tempnam(const char *, const char *);
__declspec(dllimport) int __cdecl unlink(const char *);

#line 463 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"


}
#line 467 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"


#pragma pack(pop)
#line 471 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"

#line 473 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdio.h"
#line 28 "c:\\coin3d\\include\\inventor\\sbvec3f.h"

#line 1 "c:\\coin3d\\include\\inventor\\sbbasic.h"





























#line 1 "c:\\coin3d\\include\\inventor\\c\\basic.h"



































typedef int SbBool;



#line 41 "c:\\coin3d\\include\\inventor\\c\\basic.h"


#line 44 "c:\\coin3d\\include\\inventor\\c\\basic.h"





















#line 1 "c:\\coin3d\\include\\inventor\\system\\inttypes.h"


















































































































































































#line 66 "c:\\coin3d\\include\\inventor\\c\\basic.h"







#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\math.h"















#pragma once
#line 18 "c:\\programme\\microsoft visual studio\\vc98\\include\\math.h"






#line 25 "c:\\programme\\microsoft visual studio\\vc98\\include\\math.h"







#pragma pack(push,8)
#line 34 "c:\\programme\\microsoft visual studio\\vc98\\include\\math.h"


extern "C" {
#line 38 "c:\\programme\\microsoft visual studio\\vc98\\include\\math.h"


















#line 57 "c:\\programme\\microsoft visual studio\\vc98\\include\\math.h"

















struct _exception {
        int type;       
        char *name;     
        double arg1;    
        double arg2;    
        double retval;  
        } ;


#line 84 "c:\\programme\\microsoft visual studio\\vc98\\include\\math.h"







struct _complex {
        double x,y; 
        } ;




#line 99 "c:\\programme\\microsoft visual studio\\vc98\\include\\math.h"


#line 102 "c:\\programme\\microsoft visual studio\\vc98\\include\\math.h"
#line 103 "c:\\programme\\microsoft visual studio\\vc98\\include\\math.h"





















__declspec(dllimport) extern double _HUGE;
#line 126 "c:\\programme\\microsoft visual studio\\vc98\\include\\math.h"



























#line 154 "c:\\programme\\microsoft visual studio\\vc98\\include\\math.h"
        int     __cdecl abs(int);
        double  __cdecl acos(double);
        double  __cdecl asin(double);
        double  __cdecl atan(double);
        double  __cdecl atan2(double, double);
        double  __cdecl cos(double);
        double  __cdecl cosh(double);
        double  __cdecl exp(double);
        double  __cdecl fabs(double);
        double  __cdecl fmod(double, double);
        long    __cdecl labs(long);
        double  __cdecl log(double);
        double  __cdecl log10(double);
        double  __cdecl pow(double, double);
        double  __cdecl sin(double);
        double  __cdecl sinh(double);
        double  __cdecl tan(double);
        double  __cdecl tanh(double);
        double  __cdecl sqrt(double);
#line 174 "c:\\programme\\microsoft visual studio\\vc98\\include\\math.h"
__declspec(dllimport) double  __cdecl atof(const char *);
__declspec(dllimport) double  __cdecl _cabs(struct _complex);



#line 180 "c:\\programme\\microsoft visual studio\\vc98\\include\\math.h"
__declspec(dllimport) double  __cdecl ceil(double);
__declspec(dllimport) double  __cdecl floor(double);
#line 183 "c:\\programme\\microsoft visual studio\\vc98\\include\\math.h"
__declspec(dllimport) double  __cdecl frexp(double, int *);
__declspec(dllimport) double  __cdecl _hypot(double, double);
__declspec(dllimport) double  __cdecl _j0(double);
__declspec(dllimport) double  __cdecl _j1(double);
__declspec(dllimport) double  __cdecl _jn(int, double);
__declspec(dllimport) double  __cdecl ldexp(double, int);
        int     __cdecl _matherr(struct _exception *);
__declspec(dllimport) double  __cdecl modf(double, double *);

__declspec(dllimport) double  __cdecl _y0(double);
__declspec(dllimport) double  __cdecl _y1(double);
__declspec(dllimport) double  __cdecl _yn(int, double);








































#line 236 "c:\\programme\\microsoft visual studio\\vc98\\include\\math.h"







































#line 276 "c:\\programme\\microsoft visual studio\\vc98\\include\\math.h"


































inline long double acosl(long double _X)
        {return (acos((double)_X)); }
inline long double asinl(long double _X)
        {return (asin((double)_X)); }
inline long double atanl(long double _X)
        {return (atan((double)_X)); }
inline long double atan2l(long double _X, long double _Y)
        {return (atan2((double)_X, (double)_Y)); }
inline long double ceill(long double _X)
        {return (ceil((double)_X)); }
inline long double cosl(long double _X)
        {return (cos((double)_X)); }
inline long double coshl(long double _X)
        {return (cosh((double)_X)); }
inline long double expl(long double _X)
        {return (exp((double)_X)); }
inline long double fabsl(long double _X)
        {return (fabs((double)_X)); }
inline long double floorl(long double _X)
        {return (floor((double)_X)); }
inline long double fmodl(long double _X, long double _Y)
        {return (fmod((double)_X, (double)_Y)); }
inline long double frexpl(long double _X, int *_Y)
        {return (frexp((double)_X, _Y)); }
inline long double ldexpl(long double _X, int _Y)
        {return (ldexp((double)_X, _Y)); }
inline long double logl(long double _X)
        {return (log((double)_X)); }
inline long double log10l(long double _X)
        {return (log10((double)_X)); }
inline long double modfl(long double _X, long double *_Y)
        {double _Di, _Df = modf((double)_X, &_Di);
        *_Y = (long double)_Di;
        return (_Df); }
inline long double powl(long double _X, long double _Y)
        {return (pow((double)_X, (double)_Y)); }
inline long double sinl(long double _X)
        {return (sin((double)_X)); }
inline long double sinhl(long double _X)
        {return (sinh((double)_X)); }
inline long double sqrtl(long double _X)
        {return (sqrt((double)_X)); }
inline long double tanl(long double _X)
        {return (tan((double)_X)); }
inline long double tanhl(long double _X)
        {return (tanh((double)_X)); }

inline float frexpf(float _X, int *_Y)
        {return ((float)frexp((double)_X, _Y)); }
inline float ldexpf(float _X, int _Y)
        {return ((float)ldexp((double)_X, _Y)); }

inline float acosf(float _X)
        {return ((float)acos((double)_X)); }
inline float asinf(float _X)
        {return ((float)asin((double)_X)); }
inline float atanf(float _X)
        {return ((float)atan((double)_X)); }
inline float atan2f(float _X, float _Y)
        {return ((float)atan2((double)_X, (double)_Y)); }
inline float ceilf(float _X)
        {return ((float)ceil((double)_X)); }
inline float cosf(float _X)
        {return ((float)cos((double)_X)); }
inline float coshf(float _X)
        {return ((float)cosh((double)_X)); }
inline float expf(float _X)
        {return ((float)exp((double)_X)); }
inline float fabsf(float _X)
        {return ((float)fabs((double)_X)); }
inline float floorf(float _X)
        {return ((float)floor((double)_X)); }
inline float fmodf(float _X, float _Y)
        {return ((float)fmod((double)_X, (double)_Y)); }
inline float logf(float _X)
        {return ((float)log((double)_X)); }
inline float log10f(float _X)
        {return ((float)log10((double)_X)); }
inline float modff(float _X, float *_Y)
        { double _Di, _Df = modf((double)_X, &_Di);
        *_Y = (float)_Di;
        return ((float)_Df); }
inline float powf(float _X, float _Y)
        {return ((float)pow((double)_X, (double)_Y)); }
inline float sinf(float _X)
        {return ((float)sin((double)_X)); }
inline float sinhf(float _X)
        {return ((float)sinh((double)_X)); }
inline float sqrtf(float _X)
        {return ((float)sqrt((double)_X)); }
inline float tanf(float _X)
        {return ((float)tan((double)_X)); }
inline float tanhf(float _X)
        {return ((float)tanh((double)_X)); }
#line 405 "c:\\programme\\microsoft visual studio\\vc98\\include\\math.h"
#line 406 "c:\\programme\\microsoft visual studio\\vc98\\include\\math.h"
#line 407 "c:\\programme\\microsoft visual studio\\vc98\\include\\math.h"
#line 408 "c:\\programme\\microsoft visual studio\\vc98\\include\\math.h"














#line 423 "c:\\programme\\microsoft visual studio\\vc98\\include\\math.h"



__declspec(dllimport) extern double HUGE;

__declspec(dllimport) double  __cdecl cabs(struct _complex);
__declspec(dllimport) double  __cdecl hypot(double, double);
__declspec(dllimport) double  __cdecl j0(double);
__declspec(dllimport) double  __cdecl j1(double);
__declspec(dllimport) double  __cdecl jn(int, double);
        int     __cdecl _matherr(struct _exception *);
__declspec(dllimport) double  __cdecl y0(double);
__declspec(dllimport) double  __cdecl y1(double);
__declspec(dllimport) double  __cdecl yn(int, double);

#line 439 "c:\\programme\\microsoft visual studio\\vc98\\include\\math.h"

#line 441 "c:\\programme\\microsoft visual studio\\vc98\\include\\math.h"




































































}




template<class _Ty> inline
        _Ty _Pow_int(_Ty _X, int _Y)
        {unsigned int _N;
        if (_Y >= 0)
                _N = _Y;
        else
                _N = -_Y;
        for (_Ty _Z = _Ty(1); ; _X *= _X)
                {if ((_N & 1) != 0)
                        _Z *= _X;
                if ((_N >>= 1) == 0)
                        return (_Y < 0 ? _Ty(1) / _Z : _Z); }}













































































































#line 636 "c:\\programme\\microsoft visual studio\\vc98\\include\\math.h"
#line 637 "c:\\programme\\microsoft visual studio\\vc98\\include\\math.h"


#pragma pack(pop)
#line 641 "c:\\programme\\microsoft visual studio\\vc98\\include\\math.h"

#line 643 "c:\\programme\\microsoft visual studio\\vc98\\include\\math.h"
#line 74 "c:\\coin3d\\include\\inventor\\c\\basic.h"






#line 81 "c:\\coin3d\\include\\inventor\\c\\basic.h"


#line 84 "c:\\coin3d\\include\\inventor\\c\\basic.h"


#line 87 "c:\\coin3d\\include\\inventor\\c\\basic.h"


#line 90 "c:\\coin3d\\include\\inventor\\c\\basic.h"


#line 93 "c:\\coin3d\\include\\inventor\\c\\basic.h"


#line 96 "c:\\coin3d\\include\\inventor\\c\\basic.h"


#line 99 "c:\\coin3d\\include\\inventor\\c\\basic.h"


#line 102 "c:\\coin3d\\include\\inventor\\c\\basic.h"


#line 105 "c:\\coin3d\\include\\inventor\\c\\basic.h"


#line 108 "c:\\coin3d\\include\\inventor\\c\\basic.h"


#line 111 "c:\\coin3d\\include\\inventor\\c\\basic.h"


#line 114 "c:\\coin3d\\include\\inventor\\c\\basic.h"


#line 117 "c:\\coin3d\\include\\inventor\\c\\basic.h"


#line 120 "c:\\coin3d\\include\\inventor\\c\\basic.h"


#line 123 "c:\\coin3d\\include\\inventor\\c\\basic.h"


#line 126 "c:\\coin3d\\include\\inventor\\c\\basic.h"


#line 129 "c:\\coin3d\\include\\inventor\\c\\basic.h"


#line 132 "c:\\coin3d\\include\\inventor\\c\\basic.h"


#line 135 "c:\\coin3d\\include\\inventor\\c\\basic.h"


#line 138 "c:\\coin3d\\include\\inventor\\c\\basic.h"


#line 141 "c:\\coin3d\\include\\inventor\\c\\basic.h"


#line 144 "c:\\coin3d\\include\\inventor\\c\\basic.h"




































#line 181 "c:\\coin3d\\include\\inventor\\c\\basic.h"














#line 196 "c:\\coin3d\\include\\inventor\\c\\basic.h"


#line 199 "c:\\coin3d\\include\\inventor\\c\\basic.h"


#line 202 "c:\\coin3d\\include\\inventor\\c\\basic.h"


#line 205 "c:\\coin3d\\include\\inventor\\c\\basic.h"


#line 208 "c:\\coin3d\\include\\inventor\\c\\basic.h"


#line 211 "c:\\coin3d\\include\\inventor\\c\\basic.h"


#line 214 "c:\\coin3d\\include\\inventor\\c\\basic.h"


#line 217 "c:\\coin3d\\include\\inventor\\c\\basic.h"


#line 220 "c:\\coin3d\\include\\inventor\\c\\basic.h"
#line 221 "c:\\coin3d\\include\\inventor\\c\\basic.h"
















#line 238 "c:\\coin3d\\include\\inventor\\c\\basic.h"































































#line 302 "c:\\coin3d\\include\\inventor\\c\\basic.h"
#line 303 "c:\\coin3d\\include\\inventor\\c\\basic.h"
#line 304 "c:\\coin3d\\include\\inventor\\c\\basic.h"







#line 312 "c:\\coin3d\\include\\inventor\\c\\basic.h"
#line 31 "c:\\coin3d\\include\\inventor\\sbbasic.h"



























template <class Type>
inline Type SbAbs( Type Val ) {
  return (Val < 0) ? 0 - Val : Val;
}

template <class Type>
inline Type SbMax( const Type A, const Type B ) {
  return (A < B) ? B : A;
}

template <class Type>
inline Type SbMin( const Type A, const Type B ) {
  return (A < B) ? A : B;
}

template <class Type>
inline Type SbClamp( const Type Val, const Type Min, const Type Max ) {
  return (Val < Min) ? Min : (Val > Max) ? Max : Val;
}

template <class Type>
inline void SbSwap( Type & A, Type & B ) {
  Type T; T = A; A = B; B = T;
}

template <class Type>
inline Type SbSqr(const Type val) {
  return val * val;
}



#line 91 "c:\\coin3d\\include\\inventor\\sbbasic.h"
#line 30 "c:\\coin3d\\include\\inventor\\sbvec3f.h"

class SbPlane;
class SbVec3d;

class __declspec(dllimport) SbVec3f {
public:
  SbVec3f(void) { }
  SbVec3f(const float v[3]);
  SbVec3f(const float x, const float y, const float z);
  SbVec3f(const SbPlane & p0, const SbPlane & p1, const SbPlane & p2);
  SbVec3f(const SbVec3d & v);
  SbVec3f cross(const SbVec3f & v) const;
  float dot(const SbVec3f & v) const;
  SbBool equals(const SbVec3f & v, const float tolerance) const;
  SbVec3f getClosestAxis(void) const;
  const float * getValue(void) const;
  void getValue(float & x, float & y, float & z) const;
  float length(void) const;
  float sqrLength() const;
  void negate(void);
  float normalize(void);
  SbVec3f & setValue(const float v[3]);
  SbVec3f & setValue(const float x, const float y, const float z);
  SbVec3f & setValue(const SbVec3f & barycentric,
                     const SbVec3f & v0,
                     const SbVec3f & v1,
                     const SbVec3f & v2);
  SbVec3f & setValue(const SbVec3d & v);
  float & operator [](const int i);
  const float & operator [](const int i) const;
  SbVec3f & operator *=(const float d);
  SbVec3f & operator /=(const float d);
  SbVec3f & operator +=(const SbVec3f & u);
  SbVec3f & operator -=(const SbVec3f & u);
  SbVec3f operator-(void) const;
  friend __declspec(dllimport) SbVec3f operator *(const SbVec3f & v, const float d);
  friend __declspec(dllimport) SbVec3f operator *(const float d, const SbVec3f & v);
  friend __declspec(dllimport) SbVec3f operator /(const SbVec3f & v, const float d);
  friend __declspec(dllimport) SbVec3f operator +(const SbVec3f & v1, const SbVec3f & v2);
  friend __declspec(dllimport) SbVec3f operator -(const SbVec3f & v1, const SbVec3f & v2);
  friend __declspec(dllimport) int operator ==(const SbVec3f & v1, const SbVec3f & v2);
  friend __declspec(dllimport) int operator !=(const SbVec3f & v1, const SbVec3f & v2);

  void print(FILE * fp) const;

private:
  float vec[3];
};

__declspec(dllimport) SbVec3f operator *(const SbVec3f & v, const float d);
__declspec(dllimport) SbVec3f operator *(const float d, const SbVec3f & v);
__declspec(dllimport) SbVec3f operator /(const SbVec3f & v, const float d);
__declspec(dllimport) SbVec3f operator +(const SbVec3f & v1, const SbVec3f & v2);
__declspec(dllimport) SbVec3f operator -(const SbVec3f & v1, const SbVec3f & v2);
__declspec(dllimport) int operator ==(const SbVec3f & v1, const SbVec3f & v2);
__declspec(dllimport) int operator !=(const SbVec3f & v1, const SbVec3f & v2);




inline float &
SbVec3f::operator [](const int i)
{
  return this->vec[i];
}

inline const float &
SbVec3f::operator [](const int i) const
{
  return this->vec[i];
}

#line 103 "c:\\coin3d\\include\\inventor\\sbvec3f.h"
#line 29 "c:\\coin3d\\include\\inventor\\sbcolor.h"

class __declspec(dllimport) SbColor : public SbVec3f {
public:
  SbColor(void);
  SbColor(const SbVec3f& v);
  SbColor(const float* const rgb);
  SbColor(const float r, const float g, const float b);

  SbColor & setHSVValue(float h, float s, float v);
  SbColor & setHSVValue(const float hsv[3]);
  void getHSVValue(float &h, float &s, float &v) const;
  void getHSVValue(float hsv[3]) const;
  SbColor & setPackedValue(const uint32_t rgba, float& transparency);
  uint32_t getPackedValue(const float transparency = 0.0f) const;

private:
  float red(void) const { return (*this)[0]; }
  float green(void) const { return (*this)[1]; }
  float blue(void) const { return (*this)[2]; }
  uint32_t convertToUInt(const float val) { return (uint32_t)(val*255.0f);}
};

#line 52 "c:\\coin3d\\include\\inventor\\sbcolor.h"
#line 30 "c:\\coin3d\\include\\inventor\\qt\\soqtrenderarea.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbviewportregion.h"



























#line 1 "c:\\coin3d\\include\\inventor\\sbvec2s.h"



























#line 1 "c:\\coin3d\\include\\inventor\\sbbasic.h"


























































































#line 29 "c:\\coin3d\\include\\inventor\\sbvec2s.h"
#line 1 "c:\\coin3d\\include\\inventor\\system\\inttypes.h"


















































































































































































#line 30 "c:\\coin3d\\include\\inventor\\sbvec2s.h"


class __declspec(dllimport) SbVec2s {
public:
  SbVec2s(void);
  SbVec2s(const short v[2]);
  SbVec2s(const short x, const short y);
  int32_t dot(const SbVec2s& v) const;
  const short * getValue(void) const;
  void getValue(short& x, short& y) const;
  void negate(void);
  SbVec2s& setValue(const short v[2]);
  SbVec2s& setValue(short x, short y);
  short& operator [](const int i);
  const short& operator [](const int i) const;
  SbVec2s& operator *=(int d);
  SbVec2s& operator *=(double d);
  SbVec2s& operator /=(int d);
  SbVec2s& operator /=(double d);
  SbVec2s& operator +=(const SbVec2s& u);
  SbVec2s& operator -=(const SbVec2s& u);
  SbVec2s operator-(void) const;
  friend __declspec(dllimport) SbVec2s operator *(const SbVec2s& v, int d);
  friend __declspec(dllimport) SbVec2s operator *(const SbVec2s& v, double d);
  friend __declspec(dllimport) SbVec2s operator *(int d, const SbVec2s& v);
  friend __declspec(dllimport) SbVec2s operator *(double d, const SbVec2s& v);
  friend __declspec(dllimport) SbVec2s operator /(const SbVec2s& v, int d);
  friend __declspec(dllimport) SbVec2s operator /(const SbVec2s& v, double d);
  friend __declspec(dllimport) SbVec2s operator +(const SbVec2s& v1, const SbVec2s& v2);
  friend __declspec(dllimport) SbVec2s operator -(const SbVec2s& v1, const SbVec2s& v2);
  friend __declspec(dllimport) int operator ==(const SbVec2s& v1, const SbVec2s& v2);
  friend __declspec(dllimport) int operator !=(const SbVec2s& v1, const SbVec2s& v2);

  void print(FILE * fp) const;

private:
  short vec[2];
};

__declspec(dllimport) SbVec2s operator *(const SbVec2s& v, int d);
__declspec(dllimport) SbVec2s operator *(const SbVec2s& v, double d);
__declspec(dllimport) SbVec2s operator *(int d, const SbVec2s& v);
__declspec(dllimport) SbVec2s operator *(double d, const SbVec2s& v);
__declspec(dllimport) SbVec2s operator /(const SbVec2s& v, int d);
__declspec(dllimport) SbVec2s operator /(const SbVec2s& v, double d);
__declspec(dllimport) SbVec2s operator +(const SbVec2s& v1, const SbVec2s& v2);
__declspec(dllimport) SbVec2s operator -(const SbVec2s& v1, const SbVec2s& v2);
__declspec(dllimport) int operator ==(const SbVec2s& v1, const SbVec2s& v2);
__declspec(dllimport) int operator !=(const SbVec2s& v1, const SbVec2s& v2);

#line 81 "c:\\coin3d\\include\\inventor\\sbvec2s.h"
#line 29 "c:\\coin3d\\include\\inventor\\sbviewportregion.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbvec2f.h"




























#line 1 "c:\\coin3d\\include\\inventor\\sbbasic.h"


























































































#line 30 "c:\\coin3d\\include\\inventor\\sbvec2f.h"

class __declspec(dllimport) SbVec2f {
public:
  SbVec2f(void);
  SbVec2f(const float v[2]);
  SbVec2f(const float x, const float y);
  float dot(const SbVec2f & v) const;
  SbBool equals(const SbVec2f & v, const float tolerance) const;
  const float * getValue(void) const;
  void getValue(float & x, float & y) const;
  float length(void) const;
  void negate(void);
  float normalize(void);
  SbVec2f & setValue(const float v[2]);
  SbVec2f & setValue(const float x, const float y);
  float & operator [] (const int i);
  const float & operator [] (const int i) const;
  SbVec2f & operator *= (const float d);
  SbVec2f & operator /= (const float d);
  SbVec2f & operator += (const SbVec2f & u);
  SbVec2f & operator -= (const SbVec2f & u);
  SbVec2f operator-(void) const;

  friend __declspec(dllimport) SbVec2f operator * (const SbVec2f & v, const float d);
  friend __declspec(dllimport) SbVec2f operator * (const float d, const SbVec2f & v);
  friend __declspec(dllimport) SbVec2f operator / (const SbVec2f & v, const float d);
  friend __declspec(dllimport) SbVec2f operator + (const SbVec2f & v1, const SbVec2f & v2);
  friend __declspec(dllimport) SbVec2f operator - (const SbVec2f & v1, const SbVec2f & v2);
  friend __declspec(dllimport) int operator == (const SbVec2f & v1, const SbVec2f & v2);
  friend __declspec(dllimport) int operator != (const SbVec2f & v1, const SbVec2f & v2);

  void print(FILE * fp) const;

private:
  float vec[2];
};

__declspec(dllimport) SbVec2f operator * (const SbVec2f & v, const float d);
__declspec(dllimport) SbVec2f operator * (const float d, const SbVec2f & v);
__declspec(dllimport) SbVec2f operator / (const SbVec2f & v, const float d);
__declspec(dllimport) SbVec2f operator + (const SbVec2f & v1, const SbVec2f & v2);
__declspec(dllimport) SbVec2f operator - (const SbVec2f & v1, const SbVec2f & v2);
__declspec(dllimport) int operator == (const SbVec2f & v1, const SbVec2f & v2);
__declspec(dllimport) int operator != (const SbVec2f & v1, const SbVec2f & v2);



#line 78 "c:\\coin3d\\include\\inventor\\sbvec2f.h"
#line 30 "c:\\coin3d\\include\\inventor\\sbviewportregion.h"

class __declspec(dllimport) SbViewportRegion {
public:
  SbViewportRegion(void);
  SbViewportRegion(short width, short height);
  SbViewportRegion(SbVec2s winSize);
  SbViewportRegion(const SbViewportRegion & vpReg);

  void setWindowSize(short width, short height);
  void setWindowSize(SbVec2s winSize);
  void setViewport(float left, float bottom,
                   float width, float height);
  void setViewport(SbVec2f origin, SbVec2f size);
  void setViewportPixels(short left, short bottom,
                         short width, short height);
  void setViewportPixels(SbVec2s origin, SbVec2s size);
  const SbVec2s & getWindowSize(void) const;
  const SbVec2f & getViewportOrigin(void) const;
  const SbVec2s & getViewportOriginPixels(void) const;
  const SbVec2f & getViewportSize(void) const;
  const SbVec2s & getViewportSizePixels(void) const;
  float getViewportAspectRatio(void) const;
  void scaleWidth(float ratio);
  void scaleHeight(float ratio);
  void setPixelsPerInch(float ppi);
  float getPixelsPerInch(void) const;
  float getPixelsPerPoint(void) const;
  friend __declspec(dllimport) int operator ==(const SbViewportRegion & reg1,
                         const SbViewportRegion & reg2);

  void print(FILE * file) const;

private:
  SbVec2s winsize;
  SbVec2f vporigin;
  SbVec2f vpsize;
  SbVec2s vporigin_s;
  SbVec2s vpsize_s;
  float pixperinch;
};

__declspec(dllimport) int operator ==(const SbViewportRegion & reg1, const SbViewportRegion & reg2);

#line 74 "c:\\coin3d\\include\\inventor\\sbviewportregion.h"
#line 31 "c:\\coin3d\\include\\inventor\\qt\\soqtrenderarea.h"
#line 1 "c:\\coin3d\\include\\inventor\\actions\\soglrenderaction.h"


























#line 1 "c:\\coin3d\\include\\inventor\\actions\\soaction.h"


























#line 1 "c:\\coin3d\\include\\inventor\\sbbasic.h"


























































































#line 28 "c:\\coin3d\\include\\inventor\\actions\\soaction.h"
#line 1 "c:\\coin3d\\include\\inventor\\sotype.h"


























#line 1 "c:\\coin3d\\include\\inventor\\sbbasic.h"


























































































#line 28 "c:\\coin3d\\include\\inventor\\sotype.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbdict.h"


























#line 1 "c:\\coin3d\\include\\inventor\\sbbasic.h"


























































































#line 28 "c:\\coin3d\\include\\inventor\\sbdict.h"
#line 1 "c:\\coin3d\\include\\inventor\\c\\base\\hash.h"


























#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdlib.h"
















#pragma once
#line 19 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdlib.h"






#line 26 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdlib.h"







#pragma pack(push,8)
#line 35 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdlib.h"


extern "C" {
#line 39 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdlib.h"


















#line 58 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdlib.h"










































typedef int (__cdecl * _onexit_t)(void);



#line 105 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdlib.h"

#line 107 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdlib.h"






typedef struct _div_t {
        int quot;
        int rem;
} div_t;

typedef struct _ldiv_t {
        long quot;
        long rem;
} ldiv_t;


#line 125 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdlib.h"












__declspec(dllimport) extern int __mb_cur_max;
#line 139 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdlib.h"





















#line 161 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdlib.h"













__declspec(dllimport) int * __cdecl _errno(void);
__declspec(dllimport) unsigned long * __cdecl __doserrno(void);





#line 182 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdlib.h"







__declspec(dllimport) extern char * _sys_errlist[];   
__declspec(dllimport) extern int _sys_nerr;           













#line 205 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdlib.h"
#line 206 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdlib.h"



#line 210 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdlib.h"

__declspec(dllimport) int *          __cdecl __p___argc(void);
__declspec(dllimport) char ***       __cdecl __p___argv(void);
__declspec(dllimport) wchar_t ***    __cdecl __p___wargv(void);
__declspec(dllimport) char ***       __cdecl __p__environ(void);
__declspec(dllimport) wchar_t ***    __cdecl __p__wenviron(void);
__declspec(dllimport) char **        __cdecl __p__pgmptr(void);
__declspec(dllimport) wchar_t **     __cdecl __p__wpgmptr(void);
























#line 243 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdlib.h"


__declspec(dllimport) extern int _fmode;          
__declspec(dllimport) extern int _fileinfo;       




__declspec(dllimport) extern unsigned int _osver;
__declspec(dllimport) extern unsigned int _winver;
__declspec(dllimport) extern unsigned int _winmajor;
__declspec(dllimport) extern unsigned int _winminor;





__declspec(dllimport) __declspec(noreturn) void   __cdecl abort(void);
__declspec(dllimport) __declspec(noreturn) void   __cdecl exit(int);



#line 266 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdlib.h"



#line 270 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdlib.h"
        int    __cdecl abs(int);
#line 272 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdlib.h"
        int    __cdecl atexit(void (__cdecl *)(void));
__declspec(dllimport) double __cdecl atof(const char *);
__declspec(dllimport) int    __cdecl atoi(const char *);
__declspec(dllimport) long   __cdecl atol(const char *);



__declspec(dllimport) void * __cdecl bsearch(const void *, const void *, size_t, size_t,
        int (__cdecl *)(const void *, const void *));
__declspec(dllimport) void * __cdecl calloc(size_t, size_t);
__declspec(dllimport) div_t  __cdecl div(int, int);
__declspec(dllimport) void   __cdecl free(void *);
__declspec(dllimport) char * __cdecl getenv(const char *);
__declspec(dllimport) char * __cdecl _itoa(int, char *, int);

__declspec(dllimport) char * __cdecl _i64toa(__int64, char *, int);
__declspec(dllimport) char * __cdecl _ui64toa(unsigned __int64, char *, int);
__declspec(dllimport) __int64 __cdecl _atoi64(const char *);
#line 291 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdlib.h"


#line 294 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdlib.h"
        long __cdecl labs(long);
#line 296 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdlib.h"
__declspec(dllimport) ldiv_t __cdecl ldiv(long, long);
__declspec(dllimport) char * __cdecl _ltoa(long, char *, int);
__declspec(dllimport) void * __cdecl malloc(size_t);
__declspec(dllimport) int    __cdecl mblen(const char *, size_t);
__declspec(dllimport) size_t __cdecl _mbstrlen(const char *s);
__declspec(dllimport) int    __cdecl mbtowc(wchar_t *, const char *, size_t);
__declspec(dllimport) size_t __cdecl mbstowcs(wchar_t *, const char *, size_t);
__declspec(dllimport) void   __cdecl qsort(void *, size_t, size_t, int (__cdecl *)
        (const void *, const void *));
__declspec(dllimport) int    __cdecl rand(void);
__declspec(dllimport) void * __cdecl realloc(void *, size_t);
__declspec(dllimport) int    __cdecl _set_error_mode(int);
__declspec(dllimport) void   __cdecl srand(unsigned int);
__declspec(dllimport) double __cdecl strtod(const char *, char **);
__declspec(dllimport) long   __cdecl strtol(const char *, char **, int);



__declspec(dllimport) unsigned long __cdecl strtoul(const char *, char **, int);

__declspec(dllimport) int    __cdecl system(const char *);
#line 318 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdlib.h"
__declspec(dllimport) char * __cdecl _ultoa(unsigned long, char *, int);
__declspec(dllimport) int    __cdecl wctomb(char *, wchar_t);
__declspec(dllimport) size_t __cdecl wcstombs(char *, const wchar_t *, size_t);







__declspec(dllimport) wchar_t * __cdecl _itow (int, wchar_t *, int);
__declspec(dllimport) wchar_t * __cdecl _ltow (long, wchar_t *, int);
__declspec(dllimport) wchar_t * __cdecl _ultow (unsigned long, wchar_t *, int);
__declspec(dllimport) double __cdecl wcstod(const wchar_t *, wchar_t **);
__declspec(dllimport) long   __cdecl wcstol(const wchar_t *, wchar_t **, int);
__declspec(dllimport) unsigned long __cdecl wcstoul(const wchar_t *, wchar_t **, int);
__declspec(dllimport) wchar_t * __cdecl _wgetenv(const wchar_t *);
__declspec(dllimport) int    __cdecl _wsystem(const wchar_t *);
__declspec(dllimport) int __cdecl _wtoi(const wchar_t *);
__declspec(dllimport) long __cdecl _wtol(const wchar_t *);

__declspec(dllimport) wchar_t * __cdecl _i64tow(__int64, wchar_t *, int);
__declspec(dllimport) wchar_t * __cdecl _ui64tow(unsigned __int64, wchar_t *, int);
__declspec(dllimport) __int64   __cdecl _wtoi64(const wchar_t *);
#line 343 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdlib.h"


#line 346 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdlib.h"
#line 347 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdlib.h"




__declspec(dllimport) char * __cdecl _ecvt(double, int, int *, int *);

__declspec(dllimport) __declspec(noreturn) void   __cdecl _exit(int);


#line 357 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdlib.h"
__declspec(dllimport) char * __cdecl _fcvt(double, int, int *, int *);
__declspec(dllimport) char * __cdecl _fullpath(char *, const char *, size_t);
__declspec(dllimport) char * __cdecl _gcvt(double, int, char *);
        unsigned long __cdecl _lrotl(unsigned long, int);
        unsigned long __cdecl _lrotr(unsigned long, int);

__declspec(dllimport) void   __cdecl _makepath(char *, const char *, const char *, const char *,
        const char *);
#line 366 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdlib.h"
        _onexit_t __cdecl _onexit(_onexit_t);
__declspec(dllimport) void   __cdecl perror(const char *);
__declspec(dllimport) int    __cdecl _putenv(const char *);
        unsigned int __cdecl _rotl(unsigned int, int);
        unsigned int __cdecl _rotr(unsigned int, int);
__declspec(dllimport) void   __cdecl _searchenv(const char *, const char *, char *);

__declspec(dllimport) void   __cdecl _splitpath(const char *, char *, char *, char *, char *);
#line 375 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdlib.h"
__declspec(dllimport) void   __cdecl _swab(char *, char *, int);






__declspec(dllimport) wchar_t * __cdecl _wfullpath(wchar_t *, const wchar_t *, size_t);
__declspec(dllimport) void   __cdecl _wmakepath(wchar_t *, const wchar_t *, const wchar_t *, const wchar_t *,
        const wchar_t *);
__declspec(dllimport) void   __cdecl _wperror(const wchar_t *);
__declspec(dllimport) int    __cdecl _wputenv(const wchar_t *);
__declspec(dllimport) void   __cdecl _wsearchenv(const wchar_t *, const wchar_t *, wchar_t *);
__declspec(dllimport) void   __cdecl _wsplitpath(const wchar_t *, wchar_t *, wchar_t *, wchar_t *, wchar_t *);


#line 392 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdlib.h"
#line 393 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdlib.h"




__declspec(dllimport) void __cdecl _seterrormode(int);
__declspec(dllimport) void __cdecl _beep(unsigned, unsigned);
__declspec(dllimport) void __cdecl _sleep(unsigned long);
#line 401 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdlib.h"


#line 404 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdlib.h"







__declspec(dllimport) int __cdecl tolower(int);
#line 413 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdlib.h"

__declspec(dllimport) int __cdecl toupper(int);
#line 416 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdlib.h"

#line 418 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdlib.h"

















__declspec(dllimport) char * __cdecl ecvt(double, int, int *, int *);
__declspec(dllimport) char * __cdecl fcvt(double, int, int *, int *);
__declspec(dllimport) char * __cdecl gcvt(double, int, char *);
__declspec(dllimport) char * __cdecl itoa(int, char *, int);
__declspec(dllimport) char * __cdecl ltoa(long, char *, int);
        _onexit_t __cdecl onexit(_onexit_t);
__declspec(dllimport) int    __cdecl putenv(const char *);
__declspec(dllimport) void   __cdecl swab(char *, char *, int);
__declspec(dllimport) char * __cdecl ultoa(unsigned long, char *, int);

#line 446 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdlib.h"

#line 448 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdlib.h"


}

#line 453 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdlib.h"


#pragma pack(pop)
#line 457 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdlib.h"

#line 459 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdlib.h"
#line 28 "c:\\coin3d\\include\\inventor\\c\\base\\hash.h"

#line 1 "c:\\coin3d\\include\\inventor\\c\\basic.h"























































































































































































































































































































#line 30 "c:\\coin3d\\include\\inventor\\c\\base\\hash.h"


extern "C" {
#line 34 "c:\\coin3d\\include\\inventor\\c\\base\\hash.h"

  typedef struct cc_hash cc_hash;
  typedef unsigned long cc_hash_func(const unsigned long key);
  typedef void cc_hash_apply_func(unsigned long key, void * val, void * closure);

  __declspec(dllimport) cc_hash * cc_hash_construct(unsigned int size, float loadfactor);
  __declspec(dllimport) void cc_hash_destruct(cc_hash * ht);
  __declspec(dllimport) void cc_hash_clear(cc_hash * ht);

  __declspec(dllimport) SbBool cc_hash_put(cc_hash * ht, unsigned long key, void * val);
  __declspec(dllimport) SbBool cc_hash_get(cc_hash * ht, unsigned long key, void ** val);
  __declspec(dllimport) SbBool cc_hash_remove(cc_hash * ht, unsigned long key);
  __declspec(dllimport) void cc_hash_apply(cc_hash * ht, cc_hash_apply_func * func, void * closure);

  __declspec(dllimport) unsigned int cc_hash_get_num_elements(cc_hash * ht);

  __declspec(dllimport) void cc_hash_set_hash_func(cc_hash * ht, cc_hash_func * func);
  __declspec(dllimport) void cc_hash_print_stat(cc_hash * ht);




} 
#line 58 "c:\\coin3d\\include\\inventor\\c\\base\\hash.h"

#line 60 "c:\\coin3d\\include\\inventor\\c\\base\\hash.h"
#line 29 "c:\\coin3d\\include\\inventor\\sbdict.h"


class SbPList;

class __declspec(dllimport) SbDict {
public:
  SbDict(const int entries = 251);
  SbDict(const SbDict & from);
  ~SbDict();

  SbDict & operator=(const SbDict & from);

  void applyToAll(void (* rtn)(unsigned long key, void * value)) const;
  void applyToAll(void (* rtn)(unsigned long key, void * value, void * data),
                  void * data) const;
  void clear(void);

  SbBool enter(const unsigned long key, void * const value);
  SbBool find(const unsigned long key, void *& value) const;
  void makePList(SbPList & keys, SbPList & values);
  SbBool remove(const unsigned long key);

  void setHashingFunction(unsigned long (*func)(const unsigned long key));

private:
  cc_hash * hashtable;
  static void copyval(unsigned long key, void * value, void * data);
};

#line 59 "c:\\coin3d\\include\\inventor\\sbdict.h"
#line 29 "c:\\coin3d\\include\\inventor\\sotype.h"


class SbName;
class SoTypedObject;
class SoTypeList;
class SoFieldData;
struct SoTypeData;
template <class Type> class SbList;

class __declspec(dllimport) SoType {
public:
  typedef void * (*instantiationMethod)(void);

  static SoType fromName(const SbName name);
  SbName getName(void) const;
  const SoType getParent(void) const;
  SbBool isDerivedFrom(const SoType type) const;

  static int getAllDerivedFrom(const SoType type, SoTypeList & list);

  SbBool canCreateInstance(void) const;
  void * createInstance(void) const;

  uint16_t getData(void) const;
  int16_t getKey(void) const;

  SbBool operator == (const SoType type) const;
  SbBool operator != (const SoType type) const;

  SbBool operator <  (const SoType type) const;
  SbBool operator <= (const SoType type) const;
  SbBool operator >= (const SoType type) const;
  SbBool operator >  (const SoType type) const;

  static const SoType createType(const SoType parent, const SbName name,
                                 const instantiationMethod method = (instantiationMethod) 0,
                                 const uint16_t data = 0);

  static const SoType overrideType(const SoType originalType,
                                   const instantiationMethod method = (instantiationMethod) 0);

  static void init(void);

  static SoType fromKey(uint16_t key);
  static SoType badType(void);
  SbBool isBad(void) const;

  void makeInternal(void);
  SbBool isInternal(void) const;

  static int getNumTypes(void);

  instantiationMethod getInstantiationMethod(void) const;

private:
  static void clean(void);

  int16_t index;

  static SbList<SoTypeData *> * typedatalist;
  static SbDict * typedict;
  static SbDict * moduledict;
};



inline int16_t
SoType::getKey(void) const
{
  return this->index;
}

inline SbBool
SoType::operator != (const SoType type) const
{
  return (this->getKey() != type.getKey());
}

inline SbBool
SoType::operator == (const SoType type) const
{
  return (this->getKey() == type.getKey());
}

inline SbBool
SoType::operator <  (const SoType type) const
{
  return (this->getKey() < type.getKey());
}

inline SbBool
SoType::operator <= (const SoType type) const
{
  return (this->getKey() <= type.getKey());
}

inline SbBool
SoType::operator >= (const SoType type) const
{
  return (this->getKey() >= type.getKey());
}

inline SbBool
SoType::operator >  (const SoType type) const
{
  return (this->getKey() > type.getKey());
}

inline SbBool
SoType::isBad(void) const
{
  return (this->index == 0);
}

#line 144 "c:\\coin3d\\include\\inventor\\sotype.h"
#line 29 "c:\\coin3d\\include\\inventor\\actions\\soaction.h"
#line 1 "c:\\coin3d\\include\\inventor\\misc\\sotemppath.h"


























#line 1 "c:\\coin3d\\include\\inventor\\sofullpath.h"


























#line 1 "c:\\coin3d\\include\\inventor\\sopath.h"


























#line 1 "c:\\coin3d\\include\\inventor\\misc\\sobase.h"


























#line 1 "c:\\coin3d\\include\\inventor\\sotype.h"















































































































































#line 28 "c:\\coin3d\\include\\inventor\\misc\\sobase.h"
#line 1 "c:\\coin3d\\include\\inventor\\lists\\soauditorlist.h"


























#line 1 "c:\\coin3d\\include\\inventor\\lists\\sbplist.h"


























#line 1 "c:\\coin3d\\include\\inventor\\sbbasic.h"


























































































#line 28 "c:\\coin3d\\include\\inventor\\lists\\sbplist.h"
#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\assert.h"















#line 17 "c:\\programme\\microsoft visual studio\\vc98\\include\\assert.h"



















#line 37 "c:\\programme\\microsoft visual studio\\vc98\\include\\assert.h"




















extern "C" {
#line 59 "c:\\programme\\microsoft visual studio\\vc98\\include\\assert.h"

__declspec(dllimport) void __cdecl _assert(void *, void *, unsigned);


}
#line 65 "c:\\programme\\microsoft visual studio\\vc98\\include\\assert.h"



#line 69 "c:\\programme\\microsoft visual studio\\vc98\\include\\assert.h"
#line 29 "c:\\coin3d\\include\\inventor\\lists\\sbplist.h"


class __declspec(dllimport) SbPList {
  enum { DEFAULTSIZE = 4 };

public:
  SbPList(const int sizehint = DEFAULTSIZE);
  SbPList(const SbPList & l);
  ~SbPList();

  void copy(const SbPList & l);
  SbPList & operator=(const SbPList & l);
  void fit(void);

  void append(void * item);
  int find(void * item) const;
  void insert(void * item, const int insertbefore);
  void removeItem(void * item);
  void remove(const int index);
  void removeFast(const int index);
  int getLength(void) const;
  void truncate(const int length, const int fit = 0);

  void ** getArrayPtr(const int start = 0) const;
  void *& operator[](const int index) const;

  int operator==(const SbPList & l) const;
  int operator!=(const SbPList & l) const;  
  void * get(const int index) const;
  void set(const int index, void * item);
  
protected:

  void expand(const int size);
  int getArraySize(void) const;

private:
  void expandlist(const int size) const; 
  void grow(const int size = -1);

  int itembuffersize;
  int numitems;
  void ** itembuffer;
  void * builtinbuffer[DEFAULTSIZE];
};



inline void 
SbPList::append(void * item) 
{
  if (this->numitems == this->itembuffersize) this->grow();
  this->itembuffer[this->numitems++] = item;
}

inline void 
SbPList::removeFast(const int index) 
{



  this->itembuffer[index] = this->itembuffer[--this->numitems];
}

inline int 
SbPList::getLength(void) const 
{
  return this->numitems;
}

inline void 
SbPList::truncate(const int length, const int dofit) 
{



  this->numitems = length;
  if (dofit) this->fit();
}

inline void ** 
SbPList::getArrayPtr(const int start) const 
{



  return &this->itembuffer[start];
}

inline void *& 
SbPList::operator[](const int index) const 
{



  if (index >= this->getLength()) this->expandlist(index + 1);
  return this->itembuffer[index];
}

inline int 
SbPList::operator!=(const SbPList & l) const 
{
  return !(*this == l);
}

inline void * 
SbPList::get(const int index) const 
{ 
  return this->itembuffer[index]; 
}

inline void 
SbPList::set(const int index, void * item) 
{ 
  this->itembuffer[index] = item; 
}

inline void 
SbPList::expand(const int size) 
{
  this->grow(size);
  this->numitems = size;
}

inline int 
SbPList::getArraySize(void) const 
{
  return this->itembuffersize;
}


#line 161 "c:\\coin3d\\include\\inventor\\lists\\sbplist.h"
#line 28 "c:\\coin3d\\include\\inventor\\lists\\soauditorlist.h"
#line 1 "c:\\coin3d\\include\\inventor\\misc\\sonotification.h"


























#line 1 "c:\\coin3d\\include\\inventor\\misc\\sonotrec.h"


























#line 1 "c:\\coin3d\\include\\inventor\\sbbasic.h"


























































































#line 28 "c:\\coin3d\\include\\inventor\\misc\\sonotrec.h"


class SoBase;


class __declspec(dllimport) SoNotRec {
public:
  enum Type {
    CONTAINER,
    PARENT,
    SENSOR,
    FIELD,
    ENGINE
  };

  SoNotRec(SoBase * const notifbase);
  void setType(const SoNotRec::Type type);
  SoBase * getBase(void) const;
  SoNotRec::Type getType(void) const;
  const SoNotRec * getPrevious(void) const;
  void setPrevious(const SoNotRec * const prev);
  void print(FILE * const file) const;

private:
  Type type;
  SoBase * base;
  const SoNotRec * prev;
};

#line 58 "c:\\coin3d\\include\\inventor\\misc\\sonotrec.h"
#line 28 "c:\\coin3d\\include\\inventor\\misc\\sonotification.h"


class SoEngineOutput;
class SoField;


class __declspec(dllimport) SoNotList {
public:
  SoNotList(void);
  SoNotList(const SoNotList * nl);

  void append(SoNotRec * const rec);
  void append(SoNotRec * const rec, SoField * const field);
  void append(SoNotRec * const rec, SoEngineOutput * const engineout);
  void setLastType(const SoNotRec::Type type);
  SoNotRec * getFirstRec(void) const;
  SoNotRec * getLastRec(void) const;
  SoNotRec * getFirstRecAtNode(void) const;
  SoField * getLastField(void) const;
  SoEngineOutput * getLastEngineOutput(void) const;
  uint32_t getTimeStamp(void) const;

  void print(FILE * const file = (&_iob[1])) const;

private:
  SoNotRec * head;
  SoNotRec * tail;
  SoNotRec * firstnoderec;
  SoField * lastfield;
  SoEngineOutput * lastengine;
  uint32_t stamp;
};

#line 62 "c:\\coin3d\\include\\inventor\\misc\\sonotification.h"
#line 29 "c:\\coin3d\\include\\inventor\\lists\\soauditorlist.h"














class __declspec(dllimport) SoAuditorList : private SbPList {
  typedef SbPList inherited;

public:
  SoAuditorList(void);
  ~SoAuditorList();

  void append(void * const auditor, const SoNotRec::Type type);

  void set(const int index, void * const auditor, const SoNotRec::Type type);
  void * getObject(const int index) const;
  SoNotRec::Type getType(const int index) const;

  int getLength(void) const;
  int find(void * const auditor, const SoNotRec::Type type) const;

  void remove(const int index);
  void remove(void * const auditor, const SoNotRec::Type type);

  void notify(SoNotList * l);

private:
  
  
  SoAuditorList(const int) { }
  SoAuditorList(const SoAuditorList & l) : SbPList(l) { }
  void * get(const int) const { return 0; }
  void set(const int, void * const) { }
  void copy(const SbPList &) { }
  void append(const void *) { }
  int find(const void *) const { return -1; }
  void insert(const void *, const int) { }
  void removeFast(const int) { }
  void truncate(const int, const int = 0) { }
  void push(const void *) { }
  void * pop(void) { return 0; }
  SbPList & operator=(const SbPList &) { return *this; }
  operator void ** (void) { return (void **) 0; }
  operator const void ** (void) const { return (const void **) 0; }
  void * operator[](const int) const { return 0; }
  void * & operator[](const int) { return SbPList::operator[](0); }
  int operator==(const SbPList &) const { return 0; }
  int operator!=(const SbPList &) const { return 0; }

  void doNotify(SoNotList * l, const void * auditor, const SoNotRec::Type type);

};

#line 92 "c:\\coin3d\\include\\inventor\\lists\\soauditorlist.h"
#line 29 "c:\\coin3d\\include\\inventor\\misc\\sobase.h"
#line 1 "c:\\coin3d\\include\\inventor\\c\\base\\rbptree.h"


























#line 1 "c:\\coin3d\\include\\inventor\\c\\basic.h"























































































































































































































































































































#line 28 "c:\\coin3d\\include\\inventor\\c\\base\\rbptree.h"

#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdarg.h"















#pragma once
#line 18 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdarg.h"






#line 25 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdarg.h"







#pragma pack(push,8)
#line 34 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdarg.h"


extern "C" {
#line 38 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdarg.h"


















































































































#line 153 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdarg.h"



}
#line 158 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdarg.h"


#pragma pack(pop)
#line 162 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdarg.h"

#line 164 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdarg.h"
#line 30 "c:\\coin3d\\include\\inventor\\c\\base\\rbptree.h"


extern "C" {
#line 34 "c:\\coin3d\\include\\inventor\\c\\base\\rbptree.h"


typedef struct cc_rbptree_node cc_rbptree_node;

typedef struct cc_rbptree {
  cc_rbptree_node * root;
  
  
  void * inlinepointer[2];
  void * inlinedata[2];
  uint32_t counter;
} cc_rbptree;

void cc_rbptree_init(cc_rbptree * t);
void cc_rbptree_clean(cc_rbptree * t);

void cc_rbptree_insert(cc_rbptree * t, void * p, void * data);
SbBool cc_rbptree_remove(cc_rbptree * t, void * p);
uint32_t cc_rbptree_size(const cc_rbptree * t);


typedef void cc_rbptree_traversecb(void * p, void * data, void * closure);
void cc_rbptree_traverse(const cc_rbptree * t, cc_rbptree_traversecb * func, void * closure);


void cc_rbptree_debug(const cc_rbptree * t);


} 
#line 64 "c:\\coin3d\\include\\inventor\\c\\base\\rbptree.h"

#line 66 "c:\\coin3d\\include\\inventor\\c\\base\\rbptree.h"
#line 30 "c:\\coin3d\\include\\inventor\\misc\\sobase.h"

class SbString;
class SoBaseList;
class SoInput;
class SoOutput;

class __declspec(dllimport) SoBase {

public:
  static void initClass(void);

  void ref(void) const;
  void unref(void) const;
  void unrefNoDelete(void) const;
  int32_t getRefCount(void) const;

  void touch(void);

  virtual SoType getTypeId(void) const = 0;
  SbBool isOfType(SoType type) const;
  static SoType getClassTypeId(void);

  virtual SbName getName(void) const;
  virtual void setName(const SbName & newname);

  static void addName(SoBase * const base, const char * const name);
  static void removeName(SoBase * const base, const char * const name);

  virtual void startNotify(void);
  virtual void notify(SoNotList * l);

  void addAuditor(void * const auditor, const SoNotRec::Type type);
  void removeAuditor(void * const auditor, const SoNotRec::Type type);
  const SoAuditorList & getAuditors(void) const;

  virtual void addWriteReference(SoOutput * out, SbBool isfromfield = 0);
  SbBool shouldWrite(void);

  static void incrementCurrentWriteCounter(void);
  static void decrementCurrentWriteCounter(void);

  static SoBase * getNamedBase(const SbName & name, SoType type);
  static int getNamedBases(const SbName & name, SoBaseList & baselist,
                           SoType type);

  static SbBool read(SoInput * in, SoBase *& base, SoType expectedtype);
  static void setInstancePrefix(const SbString & c);

  static void setTraceRefs(SbBool trace);
  static SbBool getTraceRefs(void);

  static SbBool connectRoute(SoInput * in,
                             const SbName & fromnodename, const SbName & fromfieldname,
                             const SbName & tonodename, const SbName & tofieldname);

  void assertAlive(void) const;
  static SbBool readRoute(SoInput * in);

protected:
  
  enum BaseFlags { IS_ENGINE = 0x01, IS_GROUP = 0x02 };

  SoBase(void);
  virtual ~SoBase();

  virtual void destroy(void);

  SbBool hasMultipleWriteRefs(void) const;
  SbBool writeHeader(SoOutput * out, SbBool isgroup, SbBool isengine) const;
  void writeFooter(SoOutput * out) const;
  virtual const char * getFileFormatName(void) const;

  virtual SbBool readInstance(SoInput * in, unsigned short flags) = 0;

  static uint32_t getCurrentWriteCounter(void);
  static void staticDataLock(void);
  static void staticDataUnlock(void);

private:
  static SbBool readReference(SoInput * in, SoBase *& base);
  static SbBool readBase(SoInput * in, SbName & classname, SoBase *& base);
  static SbBool readBaseInstance(SoInput * in, const SbName & classname,
                                 const SbName & refname, SoBase *& base);

  static SoBase * createInstance(SoInput * in, const SbName & classname);
  static void flushInput(SoInput * in);

  static void cleanClass(void);
  static void freeLists(unsigned long, void * value);

  static SoType classTypeId;

  struct {
    int32_t referencecount  : 27;
    unsigned int ingraph    :  1;
    unsigned int alive      :  4;
    
    
  } objdata;

  void doNotify(SoNotList * l, const void * auditor, const SoNotRec::Type type);
  static void rbptree_notify_cb(void * auditor, void * type, void * closure);
  cc_rbptree auditortree;

  static SbDict * name2obj;
  static SbDict * obj2name;

  static SbString * refwriteprefix;

  static SbBool tracerefs;
  static uint32_t writecounter;
};

#line 144 "c:\\coin3d\\include\\inventor\\misc\\sobase.h"
#line 28 "c:\\coin3d\\include\\inventor\\sopath.h"
#line 1 "c:\\coin3d\\include\\inventor\\lists\\sblist.h"


























#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\assert.h"















#line 17 "c:\\programme\\microsoft visual studio\\vc98\\include\\assert.h"



















#line 37 "c:\\programme\\microsoft visual studio\\vc98\\include\\assert.h"




















extern "C" {
#line 59 "c:\\programme\\microsoft visual studio\\vc98\\include\\assert.h"

__declspec(dllimport) void __cdecl _assert(void *, void *, unsigned);


}
#line 65 "c:\\programme\\microsoft visual studio\\vc98\\include\\assert.h"



#line 69 "c:\\programme\\microsoft visual studio\\vc98\\include\\assert.h"
#line 28 "c:\\coin3d\\include\\inventor\\lists\\sblist.h"

#line 1 "c:\\coin3d\\include\\inventor\\sbbasic.h"


























































































#line 30 "c:\\coin3d\\include\\inventor\\lists\\sblist.h"












#pragma warning(disable:4251)
#pragma warning(disable:4275)
#line 45 "c:\\coin3d\\include\\inventor\\lists\\sblist.h"

template <class Type>
class SbList {
  
  
  
  enum { DEFAULTSIZE = 4 };

public:

  SbList(const int sizehint = DEFAULTSIZE)
    : itembuffersize(DEFAULTSIZE), numitems(0), itembuffer(builtinbuffer) {
    if (sizehint > DEFAULTSIZE) this->grow(sizehint);
  }

  SbList(const SbList<Type> & l)
    : itembuffersize(DEFAULTSIZE), numitems(0), itembuffer(builtinbuffer) {
    this->copy(l);
  }

  ~SbList() {
    if (this->itembuffer != builtinbuffer) delete[] this->itembuffer;
  }

  void copy(const SbList<Type> & l) {
    if (this == &l) return;
    const int n = l.numitems;
    this->expand(n);
    for (int i = 0; i < n; i++) this->itembuffer[i] = l.itembuffer[i];
  }

  SbList <Type> & operator=(const SbList<Type> & l) {
    this->copy(l);
    return *this;
  }

  void fit(void) {
    const int items = this->numitems;

    if (items < this->itembuffersize) {
      Type * newitembuffer = this->builtinbuffer;
      if (items > DEFAULTSIZE) newitembuffer = new Type[items];

      if (newitembuffer != this->itembuffer) {
        for (int i = 0; i < items; i++) newitembuffer[i] = this->itembuffer[i];
      }

      if (this->itembuffer != this->builtinbuffer) delete[] this->itembuffer;
      this->itembuffer = newitembuffer;
      this->itembuffersize = items > DEFAULTSIZE ? items : DEFAULTSIZE;
    }
  }

  void append(const Type item) {
    if (this->numitems == this->itembuffersize) this->grow();
    this->itembuffer[this->numitems++] = item;
  }

  int find(const Type item) const {
    for (int i = 0; i < this->numitems; i++)
      if (this->itembuffer[i] == item) return i;
    return -1;
  }

  void insert(const Type item, const int insertbefore) {



    if (this->numitems == this->itembuffersize) this->grow();

    for (int i = this->numitems; i > insertbefore; i--)
      this->itembuffer[i] = this->itembuffer[i-1];
    this->itembuffer[insertbefore] = item;
    this->numitems++;
  }

  void removeItem(const Type item) {
    int idx = this->find(item);



    this->remove(idx);
  }

  void remove(const int index) {



    this->numitems--;
    for (int i = index; i < this->numitems; i++)
      this->itembuffer[i] = this->itembuffer[i + 1];
  }

  void removeFast(const int index) {



    this->itembuffer[index] = this->itembuffer[--this->numitems];
  }

  int getLength(void) const {
    return this->numitems;
  }

  void truncate(const int length, const int dofit = 0) {



    this->numitems = length;
    if (dofit) this->fit();
  }

  void push(const Type item) {
    this->append(item);
  }

  Type pop(void) {



    return this->itembuffer[--this->numitems];
  }

  const Type * getArrayPtr(const int start = 0) const {
    return &this->itembuffer[start];
  }

  Type operator[](const int index) const {



    return this->itembuffer[index];
  }

  Type & operator[](const int index) {



    return this->itembuffer[index];
  }

  int operator==(const SbList<Type> & l) const {
    if (this == &l) return 1;
    if (this->numitems != l.numitems) return 0;
    for (int i = 0; i < this->numitems; i++)
      if (this->itembuffer[i] != l.itembuffer[i]) return 0;
    return 1;
  }

  int operator!=(const SbList<Type> & l) const {
    return !(*this == l);
  }

protected:

  void expand(const int size) {
    this->grow(size);
    this->numitems = size;
  }

  int getArraySize(void) const {
    return this->itembuffersize;
  }

private:
  void grow(const int size = -1) {
    
    if (size == -1) this->itembuffersize <<= 1;
    else if (size <= this->itembuffersize) return;
    else { this->itembuffersize = size; }

    Type * newbuffer = new Type[this->itembuffersize];
    const int n = this->numitems;
    for (int i = 0; i < n; i++) newbuffer[i] = this->itembuffer[i];
    if (this->itembuffer != this->builtinbuffer) delete[] this->itembuffer;
    this->itembuffer = newbuffer;
  }

  int itembuffersize;
  int numitems;
  Type * itembuffer;
  Type builtinbuffer[DEFAULTSIZE];
};

#line 230 "c:\\coin3d\\include\\inventor\\lists\\sblist.h"
#line 29 "c:\\coin3d\\include\\inventor\\sopath.h"
#line 1 "c:\\coin3d\\include\\inventor\\lists\\sonodelist.h"


























#line 1 "c:\\coin3d\\include\\inventor\\lists\\sobaselist.h"


























class SoBase;

#line 1 "c:\\coin3d\\include\\inventor\\sbbasic.h"


























































































#line 30 "c:\\coin3d\\include\\inventor\\lists\\sobaselist.h"
#line 1 "c:\\coin3d\\include\\inventor\\lists\\sbplist.h"
































































































































































#line 31 "c:\\coin3d\\include\\inventor\\lists\\sobaselist.h"

class __declspec(dllimport) SoBaseList : public SbPList {
public:
  SoBaseList(void);
  SoBaseList(const int size);
  SoBaseList(const SoBaseList & l);
  ~SoBaseList();

  void append(SoBase * ptr);
  void insert(SoBase * ptr, const int addbefore);
  void remove(const int index);
  void removeItem(SoBase * item);
  void truncate(const int length);
  void copy(const SoBaseList & l);
  SoBaseList & operator=(const SoBaseList & l);
  SoBase * operator[](const int i) const;
  void set(const int i, SoBase * const ptr);
  void addReferences(const SbBool flag);
  SbBool isReferencing(void) const;

private:
  SbBool referencing;
};

#line 56 "c:\\coin3d\\include\\inventor\\lists\\sobaselist.h"
#line 28 "c:\\coin3d\\include\\inventor\\lists\\sonodelist.h"

class SoNode;

class __declspec(dllimport) SoNodeList : public SoBaseList {
  typedef SoBaseList inherited;

public:
  SoNodeList(void);
  SoNodeList(const int size);
  SoNodeList(const SoNodeList & nl);
  ~SoNodeList();

  void append(SoNode * const ptr);
  SoNode * operator[](const int i) const;
  SoNodeList & operator=(const SoNodeList & nl);
};

#line 46 "c:\\coin3d\\include\\inventor\\lists\\sonodelist.h"
#line 30 "c:\\coin3d\\include\\inventor\\sopath.h"



#line 1 "c:\\coin3d\\include\\inventor\\solists.h"




























#line 30 "c:\\coin3d\\include\\inventor\\solists.h"




#line 1 "c:\\coin3d\\include\\inventor\\lists\\sbintlist.h"


























#line 1 "c:\\coin3d\\include\\inventor\\lists\\sbplist.h"
































































































































































#line 28 "c:\\coin3d\\include\\inventor\\lists\\sbintlist.h"

class  __declspec(dllimport) SbIntList : public SbPList {
public:
  SbIntList(void) : SbPList () { }
  SbIntList(const int sizehint) : SbPList(sizehint) { }
  
  void append(const int item) {
    ((SbPList*)this)->append((void*)((unsigned long)item));
  }
  int find(const int item) {
    return ((SbPList*)this)->find((void *)((unsigned long)item));
  }
  void insert(const int item, const int addbefore) {
    ((SbPList*)this)->insert((void *)((unsigned long)item), addbefore);
  }
  int & operator[](const int idx) const {
    return (int&) ((*(const SbPList*)this)[idx]);
  }
};

#line 49 "c:\\coin3d\\include\\inventor\\lists\\sbintlist.h"
#line 35 "c:\\coin3d\\include\\inventor\\solists.h"
#line 1 "c:\\coin3d\\include\\inventor\\lists\\sbplist.h"
































































































































































#line 36 "c:\\coin3d\\include\\inventor\\solists.h"
#line 1 "c:\\coin3d\\include\\inventor\\lists\\sobaselist.h"























































#line 37 "c:\\coin3d\\include\\inventor\\solists.h"
#line 1 "c:\\coin3d\\include\\inventor\\lists\\sodetaillist.h"


























#line 1 "c:\\coin3d\\include\\inventor\\lists\\sbplist.h"
































































































































































#line 28 "c:\\coin3d\\include\\inventor\\lists\\sodetaillist.h"

class SoDetail;

class __declspec(dllimport) SoDetailList : public SbPList {
public:
  SoDetailList(void) : SbPList() { }
  SoDetailList(const int sizehint) : SbPList (sizehint) { }
  SoDetailList(const SoDetailList & l);
  ~SoDetailList();

  void append(SoDetail * detail) {
    SbPList::append((void*) detail);
  }
  void insert(SoDetail * detail, const int insertbefore) {
    SbPList::insert((void*) detail, insertbefore);
  }
  void truncate(const int length, const int fit = 0); 
  void copy(const SoDetailList & l);
  SoDetailList & operator=(const SoDetailList & l) {
    this->copy(l);
    return *this;
  }
  SoDetail * operator[](const int idx) const {
    return (SoDetail*) ((*(const SbPList*)this)[idx]);
  }
  void set(const int index, SoDetail * item);
};

#line 57 "c:\\coin3d\\include\\inventor\\lists\\sodetaillist.h"
#line 38 "c:\\coin3d\\include\\inventor\\solists.h"
#line 1 "c:\\coin3d\\include\\inventor\\lists\\soenabledelementslist.h"


























#line 1 "c:\\coin3d\\include\\inventor\\lists\\sotypelist.h"


























#line 1 "c:\\coin3d\\include\\inventor\\lists\\sbplist.h"
































































































































































#line 28 "c:\\coin3d\\include\\inventor\\lists\\sotypelist.h"
#line 1 "c:\\coin3d\\include\\inventor\\sotype.h"















































































































































#line 29 "c:\\coin3d\\include\\inventor\\lists\\sotypelist.h"

class __declspec(dllimport) SoTypeList : public SbPList {
public:
  SoTypeList(void) : SbPList() { }
  SoTypeList(const int sizehint) : SbPList(sizehint) { }
  SoTypeList(const SoTypeList & l) : SbPList(l) { }

  void append(const SoType type);
  int find(const SoType type) const;
  void insert(const SoType type, const int insertbefore);
  SoType operator[](const int idx) const;
  void set(const int index, const SoType item);
};

#line 44 "c:\\coin3d\\include\\inventor\\lists\\sotypelist.h"
#line 28 "c:\\coin3d\\include\\inventor\\lists\\soenabledelementslist.h"

class __declspec(dllimport) SoEnabledElementsList {
public:
  SoEnabledElementsList(SoEnabledElementsList * const parentlist);
  ~SoEnabledElementsList();

  const SoTypeList & getElements(void) const;
  void enable(const SoType elementtype, const int stackindex);
  void merge(const SoEnabledElementsList & eel);

  static int getCounter(void);

private:
  class SoEnabledElementsListP * pimpl;
};

#line 45 "c:\\coin3d\\include\\inventor\\lists\\soenabledelementslist.h"
#line 39 "c:\\coin3d\\include\\inventor\\solists.h"
#line 1 "c:\\coin3d\\include\\inventor\\lists\\soengineoutputlist.h"


























#line 1 "c:\\coin3d\\include\\inventor\\lists\\sbplist.h"
































































































































































#line 28 "c:\\coin3d\\include\\inventor\\lists\\soengineoutputlist.h"

class SoEngineOutput;

class __declspec(dllimport) SoEngineOutputList : public SbPList {
public:
  SoEngineOutputList(void) : SbPList() { }
  SoEngineOutputList(const int sizehint) : SbPList(sizehint) { }
  SoEngineOutputList(const SoEngineOutputList & l) : SbPList(l) { }
  
  void append(SoEngineOutput * output) {
    SbPList::append((void *) output);
  }
  void insert(SoEngineOutput * output, const int insertbefore) { 
    SbPList::insert((void *) output, insertbefore); 
  }
  SoEngineOutput * operator [](const int idx) const {
    return (SoEngineOutput*) SbPList::operator[](idx);
  }
  void set(const int idx, SoEngineOutput * item) {
    SbPList::operator[](idx) = (void*) item;
  }
};

#line 52 "c:\\coin3d\\include\\inventor\\lists\\soengineoutputlist.h"
#line 40 "c:\\coin3d\\include\\inventor\\solists.h"
#line 1 "c:\\coin3d\\include\\inventor\\lists\\soenginelist.h"


























#line 1 "c:\\coin3d\\include\\inventor\\lists\\sobaselist.h"























































#line 28 "c:\\coin3d\\include\\inventor\\lists\\soenginelist.h"

class SoEngine;

class __declspec(dllimport) SoEngineList : public SoBaseList {
  typedef SoBaseList inherited;

public:
  SoEngineList(void);
  SoEngineList(const int size);
  SoEngineList(const SoEngineList & el);
  ~SoEngineList();

  void append(SoEngine * const ptr);
  SoEngine * operator[](const int i) const;
  SoEngineList & operator=(const SoEngineList & el);
};

#line 46 "c:\\coin3d\\include\\inventor\\lists\\soenginelist.h"
#line 41 "c:\\coin3d\\include\\inventor\\solists.h"
#line 1 "c:\\coin3d\\include\\inventor\\lists\\sofieldlist.h"


























#line 1 "c:\\coin3d\\include\\inventor\\lists\\sbplist.h"
































































































































































#line 28 "c:\\coin3d\\include\\inventor\\lists\\sofieldlist.h"

class SoField;

class __declspec(dllimport) SoFieldList : public SbPList {
public:
  SoFieldList(void) : SbPList() { }
  SoFieldList(const int sizehint) : SbPList(sizehint) { }
  SoFieldList(const SoFieldList & l) : SbPList(l) { }
  
  void append(SoField * field) { 
    SbPList::append((void *) field); 
  }
  void insert(SoField * field, const int insertbefore) {
    SbPList::insert((void *) field, insertbefore); 
  }

  SoField * operator [](const int idx) const {
    return (SoField*) SbPList::operator[](idx);
  }
  void set(const int idx, SoField * field) {
    SbPList::operator[](idx) = (void*) field;
  }
  SoField * get(const int idx) const {
    return (SoField*) SbPList::get(idx);
  }
};

#line 56 "c:\\coin3d\\include\\inventor\\lists\\sofieldlist.h"
#line 42 "c:\\coin3d\\include\\inventor\\solists.h"
#line 1 "c:\\coin3d\\include\\inventor\\lists\\sonodelist.h"













































#line 43 "c:\\coin3d\\include\\inventor\\solists.h"
#line 1 "c:\\coin3d\\include\\inventor\\lists\\sopathlist.h"


























#line 1 "c:\\coin3d\\include\\inventor\\lists\\sobaselist.h"























































#line 28 "c:\\coin3d\\include\\inventor\\lists\\sopathlist.h"

class SoPath;

class __declspec(dllimport) SoPathList : public SoBaseList {
  typedef SoBaseList inherited;

public:
  SoPathList(void);
  SoPathList(const int size);
  SoPathList(const SoPathList & pl);
  ~SoPathList();

  void append(SoPath * const path);
  SoPath * operator[](const int i) const;
  SoPathList & operator=(const SoPathList & pl);
  int findPath(const SoPath & path) const;
  void sort(void);
  void uniquify(void);
};

#line 49 "c:\\coin3d\\include\\inventor\\lists\\sopathlist.h"
#line 44 "c:\\coin3d\\include\\inventor\\solists.h"
#line 1 "c:\\coin3d\\include\\inventor\\lists\\sopickedpointlist.h"


























#line 1 "c:\\coin3d\\include\\inventor\\lists\\sbplist.h"
































































































































































#line 28 "c:\\coin3d\\include\\inventor\\lists\\sopickedpointlist.h"

class SoPickedPoint;

class __declspec(dllimport) SoPickedPointList : public SbPList {
public:
  SoPickedPointList(void) : SbPList() { }
  SoPickedPointList(const int sizehint) : SbPList(sizehint) { }
  SoPickedPointList(const SoPickedPointList & l);
  ~SoPickedPointList() { this->truncate(0); }
  
  void append(SoPickedPoint * pp) { 
    SbPList::append((void *) pp); 
  }
  void insert(SoPickedPoint * pp, const int insertbefore) { 
    SbPList::insert((void *) pp, insertbefore); 
  }
  SoPickedPoint * operator[](const int idx) const {
    return (SoPickedPoint*) SbPList::operator[](idx);
  } 

  void truncate(const int start, const int fit = 0);
  void set(const int idx, SoPickedPoint * pp);

};

#line 54 "c:\\coin3d\\include\\inventor\\lists\\sopickedpointlist.h"
#line 45 "c:\\coin3d\\include\\inventor\\solists.h"
#line 1 "c:\\coin3d\\include\\inventor\\lists\\sotypelist.h"











































#line 46 "c:\\coin3d\\include\\inventor\\solists.h"

#line 48 "c:\\coin3d\\include\\inventor\\solists.h"
#line 34 "c:\\coin3d\\include\\inventor\\sopath.h"
#line 35 "c:\\coin3d\\include\\inventor\\sopath.h"


class SoWriteAction;
class SoNotList;
class SoInput;
class SoPathList;


class __declspec(dllimport) SoPath : public SoBase {
  typedef SoBase inherited;

public:
  static void initClass(void);

  SoPath(const int approxlength = 4);
  SoPath(SoNode * const head);
  SoPath(const SoPath & rhs);

  SoPath & operator=(const SoPath & rhs);

  static SoType getClassTypeId(void);
  virtual SoType getTypeId(void) const;

  void setHead(SoNode * const head);
  SoNode * getHead(void) const;
  void append(const int childindex);
  void append(SoNode * const node);
  void append(const SoPath * const frompath);
  void push(const int childindex);
  void pop(void);
  SoNode * getTail(void) const;
  SoNode * getNode(const int index) const;
  SoNode * getNodeFromTail(const int index) const;
  int getIndex(const int index) const;
  int getIndexFromTail(const int index) const;
  int getLength(void) const;
  void truncate(const int length);

  int findFork(const SoPath * const path) const;
  int findNode(const SoNode * const node) const;

  SbBool containsNode(const SoNode * const node) const;
  SbBool containsPath(const SoPath * const path) const;
  SoPath * copy(const int startfromnodeindex = 0, int numnodes = 0) const;
  friend __declspec(dllimport) SbBool operator==(const SoPath & lhs, const SoPath & rhs);
  friend __declspec(dllimport) SbBool operator!=(const SoPath & lhs, const SoPath & rhs);

  static SoPath * getByName(const SbName name);
  static int getByName(const SbName name, SoPathList & l);

  void insertIndex(SoNode * const parent, const int newindex);
  void removeIndex(SoNode * const parent, const int oldindex);
  void replaceIndex(SoNode * const parent, const int index,
                    SoNode * const newchild);
  SbBool isRelevantNotification(SoNotList * const l) const;

  virtual void write(SoWriteAction * action);

protected:
  virtual ~SoPath();
  void auditPath(const SbBool flag);

private:
  static void * createInstance(void);
  void append(SoNode * const node, const int index);
  int getFullLength(void) const;
  void truncate(const int length, const SbBool donotify);
  virtual SbBool readInstance(SoInput * in, unsigned short flags);
  void setFirstHidden(void);

  SoNodeList nodes;
  SbList<int> indices;
  SbBool isauditing;
  int firsthidden;
  SbBool firsthiddendirty;
  static SoType classTypeId;

  friend class SoFullPath;
  friend class SoNodeKitPath;
  friend class SoAction;
  friend class SoTempPath;
};



inline int
SoPath::getFullLength(void) const
{
  return this->nodes.getLength();
}

inline void
SoPath::push(const int childindex)
{
  this->append(childindex);
}

inline void
SoPath::pop(void)
{
  this->truncate(this->getFullLength() - 1);
}






#line 1 "c:\\coin3d\\include\\inventor\\sofullpath.h"





















































#line 144 "c:\\coin3d\\include\\inventor\\sopath.h"
#line 1 "c:\\coin3d\\include\\inventor\\misc\\solightpath.h"


























#line 1 "c:\\coin3d\\include\\inventor\\sbbasic.h"


























































































#line 28 "c:\\coin3d\\include\\inventor\\misc\\solightpath.h"
#line 1 "c:\\coin3d\\include\\inventor\\lists\\sblist.h"





































































































































































































































#line 29 "c:\\coin3d\\include\\inventor\\misc\\solightpath.h"

class SoNode;
class SoTempPath;

class __declspec(dllimport) SoLightPath {
public:
  SoLightPath(SoNode *node, const int approxlength);
  SoLightPath(const int approxlength);
  ~SoLightPath();

  void setHead(SoNode * const node);
  void append(const int childindex);
  void push(const int childindex);
  void pop(void);
  void setTail(const int childindex);
  SoNode *getTail(void) const;
  SoNode *getHead(void) const;
  SoNode *getNode(const int index) const;
  int getIndex(const int index) const;
  int getFullLength() const;
  void truncate(const int startindex);

  void makeTempPath(SoTempPath *path) const;
private:
  SoNode *headnode;
  SbList <int> indices;
};

#line 58 "c:\\coin3d\\include\\inventor\\misc\\solightpath.h"
#line 145 "c:\\coin3d\\include\\inventor\\sopath.h"
#line 146 "c:\\coin3d\\include\\inventor\\sopath.h"

#line 148 "c:\\coin3d\\include\\inventor\\sopath.h"
#line 28 "c:\\coin3d\\include\\inventor\\sofullpath.h"

class __declspec(dllimport) SoFullPath : public SoPath {
  typedef SoPath inherited;
  friend class SoTempPath;

private:
  SoFullPath(const int approxLength);
  virtual ~SoFullPath(void);

public:
  void pop(void);
  SoNode * getTail(void) const;
  SoNode * getNodeFromTail(const int index) const;
  int getIndexFromTail(const int index) const;
  int getLength(void) const;
};



inline void
SoFullPath::pop(void)
{
  this->truncate(this->nodes.getLength() - 1);
}

#line 54 "c:\\coin3d\\include\\inventor\\sofullpath.h"
#line 28 "c:\\coin3d\\include\\inventor\\misc\\sotemppath.h"

class __declspec(dllimport) SoTempPath : public SoFullPath {
public:
  SoTempPath(const int approxlength);
  
  
  void simpleAppend(SoNode * const node, const int index);
  void replaceTail(SoNode * const node, const int index);
};

#line 39 "c:\\coin3d\\include\\inventor\\misc\\sotemppath.h"
#line 30 "c:\\coin3d\\include\\inventor\\actions\\soaction.h"




#line 1 "c:\\coin3d\\include\\inventor\\lists\\soactionmethodlist.h"


























#line 1 "c:\\coin3d\\include\\inventor\\lists\\sbplist.h"
































































































































































#line 28 "c:\\coin3d\\include\\inventor\\lists\\soactionmethodlist.h"
#line 1 "c:\\coin3d\\include\\inventor\\sotype.h"















































































































































#line 29 "c:\\coin3d\\include\\inventor\\lists\\soactionmethodlist.h"

class SoAction;
class SoNode;

typedef void (* SoActionMethod)(SoAction *, SoNode *);

class __declspec(dllimport) SoActionMethodList : public SbPList {
  typedef SbPList inherited;

public:
  SoActionMethodList(SoActionMethodList * const parentlist);
  ~SoActionMethodList();

  SoActionMethod & operator[](const int index);

  void addMethod(const SoType node, const SoActionMethod method);
  void setUp(void);

private:
  class SoActionMethodListP * pimpl;
};

#line 52 "c:\\coin3d\\include\\inventor\\lists\\soactionmethodlist.h"
#line 35 "c:\\coin3d\\include\\inventor\\actions\\soaction.h"
#line 1 "c:\\coin3d\\include\\inventor\\lists\\soenabledelementslist.h"












































#line 36 "c:\\coin3d\\include\\inventor\\actions\\soaction.h"
























class SoEnabledElementsList;
class SoNode;
class SoPath;
class SoPathList;
class SoState;
class SoActionP;

class __declspec(dllimport) SoAction {
public:
  enum AppliedCode { NODE = 0, PATH = 1, PATH_LIST = 2 };
  enum PathCode { NO_PATH = 0, IN_PATH = 1, BELOW_PATH = 2, OFF_PATH = 3 };

  virtual ~SoAction();

  static void initClass(void);
  static void initClasses(void);

  static SoType getClassTypeId(void);
  virtual SoType getTypeId(void) const = 0;
  virtual SbBool isOfType(SoType type) const;


  virtual void apply(SoNode * root);
  virtual void apply(SoPath * path);
  virtual void apply(const SoPathList & pathlist, SbBool obeysrules = 0);
  void apply(SoAction * beingApplied);
  virtual void invalidateState(void);

  static void nullAction(SoAction * action, SoNode * node);

  AppliedCode getWhatAppliedTo(void) const;
  SoNode * getNodeAppliedTo(void) const;
  SoPath * getPathAppliedTo(void) const;
  const SoPathList * getPathListAppliedTo(void) const;
  const SoPathList * getOriginalPathListAppliedTo(void) const;

  SbBool isLastPathListAppliedTo(void) const;

  PathCode getPathCode(int & numindices, const int * & indices);

  void traverse(SoNode * const node);
  SbBool hasTerminated(void) const;

  const SoPath * getCurPath(void);
  SoState * getState(void) const;

  PathCode getCurPathCode(void) const;
  virtual SoNode * getCurPathTail(void);
  void usePathCode(int & numindices, const int * & indices);
  
  void pushCurPath(const int childindex, SoNode * node = 0);
  void popCurPath(const PathCode prevpathcode);
  void pushCurPath(void);
  
  void popPushCurPath(const int childindex, SoNode * node = 0);
  void popCurPath(void);

public:
  void switchToPathTraversal(SoPath * path);
  void switchToNodeTraversal(SoNode * node);


protected:
  SoAction(void);

  virtual void beginTraversal(SoNode * node);
  virtual void endTraversal(SoNode * node);
  void setTerminated(const SbBool flag);

  virtual const SoEnabledElementsList & getEnabledElements(void) const;
  virtual SbBool shouldCompactPathList(void) const;

  SoState * state;
  SoActionMethodList * traversalMethods;

  


  static SoEnabledElementsList * getClassEnabledElements(void);
  static SoActionMethodList * getClassActionMethods(void);

private:
  static SoType classTypeId;
  



  static void atexit_cleanup(void);
  static SoEnabledElementsList * enabledElements;
  static SoActionMethodList * methods;
  SoTempPath currentpath;
  PathCode currentpathcode;

  SoActionP * pimpl;
};



inline SoAction::PathCode
SoAction::getCurPathCode(void) const
{
  return this->currentpathcode;
}

inline void
SoAction::popCurPath(const PathCode prevpathcode)
{
  this->currentpath.pop();
  this->currentpathcode = prevpathcode;
}

#line 172 "c:\\coin3d\\include\\inventor\\actions\\soaction.h"
#line 28 "c:\\coin3d\\include\\inventor\\actions\\soglrenderaction.h"
#line 1 "c:\\coin3d\\include\\inventor\\actions\\sosubaction.h"




























#line 1 "c:\\coin3d\\include\\inventor\\sbstring.h"


























#line 1 "c:\\coin3d\\include\\inventor\\system\\inttypes.h"


















































































































































































#line 28 "c:\\coin3d\\include\\inventor\\sbstring.h"
#line 1 "c:\\coin3d\\include\\inventor\\c\\base\\string.h"


























#line 1 "c:\\coin3d\\include\\inventor\\c\\basic.h"























































































































































































































































































































#line 28 "c:\\coin3d\\include\\inventor\\c\\base\\string.h"




extern "C" {
#line 34 "c:\\coin3d\\include\\inventor\\c\\base\\string.h"



enum cc_string_constants {
  CC_STRING_MIN_SIZE = 128 - sizeof(char *) + sizeof(int)
};

struct cc_string {
  char * pointer;
  int bufsize;
  char buffer[CC_STRING_MIN_SIZE];
};

typedef  struct cc_string  cc_string;

typedef char (*cc_apply_f)(char);



__declspec(dllimport) void cc_string_construct(cc_string * me);
__declspec(dllimport) cc_string * cc_string_construct_new(void);
__declspec(dllimport) cc_string * cc_string_clone(cc_string * str);
__declspec(dllimport) void cc_string_clean(cc_string * str);
__declspec(dllimport) void cc_string_destruct(cc_string * str);

__declspec(dllimport) void cc_string_set_string(cc_string * str, const cc_string * str2);
__declspec(dllimport) void cc_string_set_text(cc_string * str, const char * text);
__declspec(dllimport) void cc_string_set_subtext(cc_string * str, const char * text, int start, int end);
__declspec(dllimport) void cc_string_set_integer(cc_string * str, int integer);

__declspec(dllimport) void cc_string_append_string(cc_string * str, const cc_string * str2);
__declspec(dllimport) void cc_string_append_text(cc_string * str, const char * text);
__declspec(dllimport) void cc_string_append_integer(cc_string * str, const int digits);
__declspec(dllimport) void cc_string_append_char(cc_string * str, const char c);

__declspec(dllimport) unsigned int cc_string_length(const cc_string * str);
__declspec(dllimport) int cc_string_is(const cc_string * str);
__declspec(dllimport) void cc_string_clear(cc_string * str);
__declspec(dllimport) void cc_string_clear_no_free(cc_string * str);
__declspec(dllimport) uint32_t cc_string_hash(const cc_string * str);
__declspec(dllimport) uint32_t cc_string_hash_text(const char * text);

__declspec(dllimport) const char * cc_string_get_text(const cc_string * str);
__declspec(dllimport) void cc_string_remove_substring(cc_string * str, int start, int end);

__declspec(dllimport) int cc_string_compare(const cc_string * lhs, const cc_string * rhs);
__declspec(dllimport) int cc_string_compare_text(const char * lhs, const char * rhs);
__declspec(dllimport) int cc_string_compare_subtext(const cc_string * str, const char * text, int offset);

__declspec(dllimport) void cc_string_apply(cc_string * str, cc_apply_f function);

__declspec(dllimport) void cc_string_sprintf(cc_string * str, const char * formatstr, ...);
__declspec(dllimport) void cc_string_vsprintf(cc_string * str, const char * formatstr, va_list args);




} 
#line 93 "c:\\coin3d\\include\\inventor\\c\\base\\string.h"

#line 95 "c:\\coin3d\\include\\inventor\\c\\base\\string.h"
#line 29 "c:\\coin3d\\include\\inventor\\sbstring.h"
#line 1 "c:\\coin3d\\include\\inventor\\lists\\sbintlist.h"
















































#line 30 "c:\\coin3d\\include\\inventor\\sbstring.h"



class __declspec(dllimport) SbString {
public:
  SbString(void) { cc_string_construct(&this->str); }

  SbString(const char * s)
  { cc_string_construct(&this->str); cc_string_set_text(&this->str, s); }

  SbString(const char * s, int start, int end)
  { cc_string_construct(&this->str); cc_string_set_subtext(&this->str, s, start, end); }

  SbString(const SbString & s)
  { cc_string_construct(&this->str); cc_string_set_string(&this->str, &s.str); }

  SbString(const int digits)
  { cc_string_construct(&this->str); cc_string_set_integer(&this->str, digits); }

  ~SbString() { cc_string_clean(&this->str); }

  uint32_t hash(void) const { return cc_string_hash(&this->str); }
  static uint32_t hash(const char * s) { return cc_string_hash_text(s); }

  int getLength(void) const { return cc_string_length(&this->str); }

  void makeEmpty(SbBool freeold = 1)
  {
    if ( freeold ) cc_string_clear(&this->str);
    else cc_string_clear_no_free(&this->str);
  }

  const char * getString(void) const { return cc_string_get_text(&this->str); }

  SbString getSubString(int startidx, int endidx = -1) const
  {
    SbString s;
    cc_string_set_subtext(&s.str, cc_string_get_text(&this->str), startidx, endidx);
    return s;
  }
  void deleteSubString(int startidx, int endidx = -1)
  {
    cc_string_remove_substring(&this->str, startidx, endidx);
  }

  void addIntString(const int value) { cc_string_append_integer(&this->str, value); }

  char operator[](int index) const { return this->str.pointer[index]; }

  SbString & operator=(const char * s)
  { cc_string_set_text(&this->str, s); return *this; }
  SbString & operator=(const SbString & s)
  { cc_string_set_text(&this->str, s.str.pointer); return *this; }

  SbString & operator+=(const char * s)
  { cc_string_append_text(&this->str, s); return *this; }
  SbString & operator+=(const SbString & s)
  { cc_string_append_string(&this->str, &s.str); return *this; }
  SbString & operator+=(const char c)
  { cc_string_append_char(&this->str, c); return *this; }

  int operator!(void) const { return ! cc_string_is(&this->str); }

  int compareSubString(const char * text, int offset = 0) const
  { return cc_string_compare_subtext(&this->str, text, offset); }

  SbString & sprintf(const char * formatstr, ...)
  {
    va_list args; ( args = (va_list)&formatstr + ( (sizeof(formatstr) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) );
    cc_string_vsprintf(&this->str, formatstr, args);
    ( args = (va_list)0 ); return *this;
  }
  SbString & vsprintf(const char * formatstr, va_list args)
  { cc_string_vsprintf(&this->str, formatstr, args); return *this; }

  void apply(char (*func)(char input)) { cc_string_apply(&this->str, (cc_apply_f)func); }

  int find(const SbString & s) const;
  SbBool findAll(const SbString & s, SbIntList & found) const;

  friend int operator==(const SbString & sbstr, const char * s);
  friend int operator==(const char * s, const SbString & sbstr);
  friend int operator==(const SbString & str1, const SbString & str2);
  friend int operator!=(const SbString & sbstr, const char * s);
  friend int operator!=(const char * s, const SbString & sbstr);
  friend int operator!=(const SbString & str1, const SbString & str2);

private:
  struct cc_string str;
};

inline int operator==(const SbString & sbstr, const char * s)
{ return (cc_string_compare_text(sbstr.str.pointer, s) == 0); }
inline int operator==(const char * s, const SbString & sbstr)
{ return (cc_string_compare_text(s, sbstr.str.pointer) == 0); }
inline int operator==(const SbString & str1, const SbString & str2)
{ return (cc_string_compare_text(str1.str.pointer, str2.str.pointer) == 0); }

inline int operator!=(const SbString & sbstr, const char * s)
{ return (cc_string_compare_text(sbstr.str.pointer, s) != 0); }
inline int operator!=(const char * s, const SbString & sbstr)
{ return (cc_string_compare_text(s, sbstr.str.pointer) != 0); }
inline int operator!=(const SbString & str1, const SbString & str2)
{ return (cc_string_compare_text(str1.str.pointer, str2.str.pointer) != 0); }



#line 1 "c:\\coin3d\\include\\inventor\\sbname.h"


























#line 1 "c:\\coin3d\\include\\inventor\\sbbasic.h"


























































































#line 28 "c:\\coin3d\\include\\inventor\\sbname.h"

class SbString;

class __declspec(dllimport) SbName {
public:
  SbName(void);
  SbName(const char * nameString);
  SbName(const SbString & str);
  SbName(const SbName & name);
  ~SbName(void);

  const char * getString(void) const;
  int getLength(void) const;
  static SbBool isIdentStartChar(const char c);
  static SbBool isIdentChar(const char c);
  static SbBool isBaseNameStartChar(const char c);
  static SbBool isBaseNameChar(const char c);

  int operator ! (void) const;
  friend __declspec(dllimport) int operator == (const SbName & lhs, const char * rhs);
  friend __declspec(dllimport) int operator == (const char * lhs, const SbName & rhs);
  friend __declspec(dllimport) int operator == (const SbName & lhs, const SbName & rhs);
  friend __declspec(dllimport) int operator != (const SbName & lhs, const char * rhs);
  friend __declspec(dllimport) int operator != (const char * lhs, const SbName & rhs);
  friend __declspec(dllimport) int operator != (const SbName & lhs, const SbName & rhs);

  operator const char * (void) const;

private:
  const class SbNameEntry * entry;
};
__declspec(dllimport) int operator == (const SbName & lhs, const char * rhs);
__declspec(dllimport) int operator == (const char * lhs, const SbName & rhs);
__declspec(dllimport) int operator == (const SbName & lhs, const SbName & rhs);
__declspec(dllimport) int operator != (const SbName & lhs, const char * rhs);
__declspec(dllimport) int operator != (const char * lhs, const SbName & rhs);
__declspec(dllimport) int operator != (const SbName & lhs, const SbName & rhs);

#line 67 "c:\\coin3d\\include\\inventor\\sbname.h"
#line 138 "c:\\coin3d\\include\\inventor\\sbstring.h"
#line 139 "c:\\coin3d\\include\\inventor\\sbstring.h"

#line 141 "c:\\coin3d\\include\\inventor\\sbstring.h"
#line 30 "c:\\coin3d\\include\\inventor\\actions\\sosubaction.h"
#line 1 "c:\\coin3d\\include\\inventor\\actions\\soaction.h"











































































































































































#line 31 "c:\\coin3d\\include\\inventor\\actions\\sosubaction.h"



#line 35 "c:\\coin3d\\include\\inventor\\actions\\sosubaction.h"























































































#line 123 "c:\\coin3d\\include\\inventor\\actions\\sosubaction.h"
#line 29 "c:\\coin3d\\include\\inventor\\actions\\soglrenderaction.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbbasic.h"


























































































#line 30 "c:\\coin3d\\include\\inventor\\actions\\soglrenderaction.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbviewportregion.h"









































































#line 31 "c:\\coin3d\\include\\inventor\\actions\\soglrenderaction.h"
#line 1 "c:\\coin3d\\include\\inventor\\system\\inttypes.h"


















































































































































































#line 32 "c:\\coin3d\\include\\inventor\\actions\\soglrenderaction.h"
#line 1 "c:\\coin3d\\include\\inventor\\lists\\sopathlist.h"
















































#line 33 "c:\\coin3d\\include\\inventor\\actions\\soglrenderaction.h"
#line 1 "c:\\coin3d\\include\\inventor\\lists\\sblist.h"





































































































































































































































#line 34 "c:\\coin3d\\include\\inventor\\actions\\soglrenderaction.h"

typedef void SoGLRenderPassCB(void * userdata);
typedef void SoGLPreRenderCB(void * userdata, class SoGLRenderAction * action);

class __declspec(dllimport) SoGLRenderAction : public SoAction {
  typedef SoAction inherited;

  public: virtual SoType getTypeId(void) const; static SoType getClassTypeId(void); static void addMethod(const SoType type, SoActionMethod method); static void enableElement(const SoType type, const int stackindex); protected: virtual const SoEnabledElementsList & getEnabledElements(void) const; static SoEnabledElementsList * getClassEnabledElements(void); static SoActionMethodList * getClassActionMethods(void); private: static void atexit_cleanup(void); static SoEnabledElementsList * enabledElements; static SoActionMethodList * methods; static SoType classTypeId;

public:
  SoGLRenderAction(const SbViewportRegion & viewportregion);
  virtual ~SoGLRenderAction();

  static void initClass(void);

  enum TransparencyType {
    SCREEN_DOOR,
    ADD, DELAYED_ADD, SORTED_OBJECT_ADD,
    BLEND, DELAYED_BLEND, SORTED_OBJECT_BLEND,
    
    SORTED_OBJECT_SORTED_TRIANGLE_ADD,
    SORTED_OBJECT_SORTED_TRIANGLE_BLEND,
    NONE, SORTED_LAYERS_BLEND
  };

  enum AbortCode {
    CONTINUE, ABORT, PRUNE, DELAY
  };

  typedef AbortCode SoGLRenderAbortCB(void * userdata);

  void setViewportRegion(const SbViewportRegion & newregion);
  const SbViewportRegion & getViewportRegion(void) const;
  void setUpdateArea(const SbVec2f & origin, const SbVec2f & size);
  void getUpdateArea(SbVec2f & origin, SbVec2f & size) const;
  void setAbortCallback(SoGLRenderAbortCB * const func, void * const userdata);
  void setTransparencyType(const TransparencyType type);
  TransparencyType getTransparencyType(void) const;
  void setSmoothing(const SbBool smooth);
  SbBool isSmoothing(void) const;
  void setNumPasses(const int num);
  int getNumPasses(void) const;
  void setPassUpdate(const SbBool flag);
  SbBool isPassUpdate(void) const;
  void setPassCallback(SoGLRenderPassCB * const func, void * const userdata);
  void setCacheContext(const uint32_t context);
  uint32_t getCacheContext(void) const;

  void addDelayedPath(SoPath * path);
  SbBool isRenderingDelayedPaths(void) const;

  SbBool handleTransparency(SbBool istransparent = 0);
  int getCurPass(void) const;
  SbBool abortNow(void);

  void setRenderingIsRemote(SbBool isremote);
  SbBool getRenderingIsRemote(void) const;

  virtual void invalidateState(void);

  void addPreRenderCallback(SoGLPreRenderCB * func, void * userdata);
  void removePreRenderCallback(SoGLPreRenderCB * func, void * userdata);
 
  void setSortedLayersNumPasses(int num);
  int getSortedLayersNumPasses() const;
  
protected:
  virtual void beginTraversal(SoNode * node);
  virtual void endTraversal(SoNode * node);

private:
  void addTransPath(SoPath * path);
  void doPathSort(void);

  class SoGLRenderActionP * pimpl;
  friend class SoGLRenderActionP;
};

#line 113 "c:\\coin3d\\include\\inventor\\actions\\soglrenderaction.h"
#line 32 "c:\\coin3d\\include\\inventor\\qt\\soqtrenderarea.h"
#line 1 "c:\\coin3d\\include\\inventor\\soscenemanager.h"


























#line 1 "c:\\coin3d\\include\\inventor\\sbcolor.h"



















































#line 28 "c:\\coin3d\\include\\inventor\\soscenemanager.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbvec2s.h"
















































































#line 29 "c:\\coin3d\\include\\inventor\\soscenemanager.h"

class SbViewportRegion;
class SoEvent;
class SoGLRenderAction;
class SoAudioRenderAction;
class SoHandleEventAction;
class SoNode;
class SoNodeSensor;
class SoOneShotSensor;
class SoSensor;

class SoSceneManager;
typedef void SoSceneManagerRenderCB(void * userdata, SoSceneManager * mgr);


class __declspec(dllimport) SoSceneManager {
public:
  SoSceneManager(void);
  virtual ~SoSceneManager();
  virtual void render(const SbBool clearwindow = 1,
                      const SbBool clearzbuffer = 1);
  virtual void render(SoGLRenderAction * action,
                      const SbBool initmatrices = 1,
                      const SbBool clearwindow = 1,
                      const SbBool clearzbuffer = 1);
  virtual SbBool processEvent(const SoEvent * const event);
  void reinitialize(void);
  void scheduleRedraw(void);
  virtual void setSceneGraph(SoNode * const sceneroot);
  virtual SoNode * getSceneGraph(void) const;
  void setWindowSize(const SbVec2s & newsize);
  const SbVec2s & getWindowSize(void) const;
  void setSize(const SbVec2s & newsize);
  const SbVec2s & getSize(void) const;
  void setOrigin(const SbVec2s & newOrigin);
  const SbVec2s & getOrigin(void) const;
  void setViewportRegion(const SbViewportRegion & newRegion);
  const SbViewportRegion & getViewportRegion(void) const;
  void setBackgroundColor(const SbColor & color);
  const SbColor & getBackgroundColor(void) const;
  void setBackgroundIndex(const int index);
  int getBackgroundIndex(void) const;
  void setRGBMode(const SbBool onOrOff);
  SbBool isRGBMode(void) const;
  virtual void activate(void);
  virtual void deactivate(void);
  void setRenderCallback(SoSceneManagerRenderCB * f,
                         void * const userData = 0);
  SbBool isAutoRedraw(void) const;
  void setRedrawPriority(const uint32_t priority);
  uint32_t getRedrawPriority(void) const;
  void setAntialiasing(const SbBool smoothing, const int numPasses);
  void getAntialiasing(SbBool & smoothing, int & numPasses) const;
  void setGLRenderAction(SoGLRenderAction * const action);
  SoGLRenderAction * getGLRenderAction(void) const;
  void setAudioRenderAction(SoAudioRenderAction * const action);
  SoAudioRenderAction * getAudioRenderAction(void) const;
  void setHandleEventAction(SoHandleEventAction * hea);
  SoHandleEventAction * getHandleEventAction(void) const;

  static uint32_t getDefaultRedrawPriority(void);
  static void enableRealTimeUpdate(const SbBool flag);
  static SbBool isRealTimeUpdateEnabled(void);

protected:
  int isActive(void) const;
  void redraw(void);

private:
  class SoSceneManagerP * pimpl;
  friend class SoSceneManagerP;
};

#line 103 "c:\\coin3d\\include\\inventor\\soscenemanager.h"
#line 33 "c:\\coin3d\\include\\inventor\\qt\\soqtrenderarea.h"

#line 1 "c:\\coin3d\\include\\inventor\\qt\\soqtglwidget.h"


























#line 1 "c:\\coin3d\\include\\inventor\\sbbasic.h"


























































































#line 28 "c:\\coin3d\\include\\inventor\\qt\\soqtglwidget.h"
#line 1 "c:\\coin3d\\include\\inventor\\qt\\soqtbasic.h"






































template <class Type>
inline Type SoQtAbs(Type Val) {
  return (Val < 0) ? -Val : Val;
}

template <class Type>
inline Type SoQtMin(Type a, Type b) {
  return (b < a) ? b : a;
}

template <class Type>
inline Type SoQtMax(Type a, Type b) {
  return (b > a) ? b : a;
}

template <class Type>
inline Type SoQtClamp(Type val, Type min, Type max) {
  return SoQtMax(min, SoQtMin(max, val));
}

template <class Type>
inline void SoQtSwap(Type & a, Type & b) {
  Type t = a; a = b; b = t;
}







#line 71 "c:\\coin3d\\include\\inventor\\qt\\soqtbasic.h"


#line 74 "c:\\coin3d\\include\\inventor\\qt\\soqtbasic.h"


#line 77 "c:\\coin3d\\include\\inventor\\qt\\soqtbasic.h"


#line 80 "c:\\coin3d\\include\\inventor\\qt\\soqtbasic.h"

















































#line 130 "c:\\coin3d\\include\\inventor\\qt\\soqtbasic.h"
#line 131 "c:\\coin3d\\include\\inventor\\qt\\soqtbasic.h"
#line 132 "c:\\coin3d\\include\\inventor\\qt\\soqtbasic.h"








#line 141 "c:\\coin3d\\include\\inventor\\qt\\soqtbasic.h"
#line 29 "c:\\coin3d\\include\\inventor\\qt\\soqtglwidget.h"
#line 1 "c:\\coin3d\\include\\inventor\\qt\\soqtcomponent.h"


























#line 1 "c:\\coin3d\\include\\inventor\\sblinear.h"











































#line 1 "c:\\coin3d\\include\\inventor\\sbvec2f.h"













































































#line 45 "c:\\coin3d\\include\\inventor\\sblinear.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbvec2s.h"
















































































#line 46 "c:\\coin3d\\include\\inventor\\sblinear.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbvec3f.h"






































































































#line 47 "c:\\coin3d\\include\\inventor\\sblinear.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbvec3s.h"



























#line 1 "c:\\coin3d\\include\\inventor\\sbbasic.h"


























































































#line 29 "c:\\coin3d\\include\\inventor\\sbvec3s.h"

class __declspec(dllimport) SbVec3s {
public:
  SbVec3s(void);
  SbVec3s(const short v[3]);
  SbVec3s(const short x, const short y, const short z);

  int32_t dot(const SbVec3s & v) const;
  const short * getValue(void) const;
  void getValue(short & x, short & y, short & z) const;
  void negate(void);
  SbVec3s & setValue(const short v[3]);
  SbVec3s & setValue(const short x, const short y, const short z);

  short & operator [](const int i);
  const short & operator [](const int i) const;
  SbVec3s & operator *=(int d);
  SbVec3s & operator *=(double  d);
  SbVec3s & operator /=(int d);
  SbVec3s & operator /=(double d);
  SbVec3s & operator +=(const SbVec3s & u);
  SbVec3s & operator -=(const SbVec3s & u);
  SbVec3s operator-(void) const;
  friend __declspec(dllimport) SbVec3s operator *(const SbVec3s & v, int d);
  friend __declspec(dllimport) SbVec3s operator *(const SbVec3s & v, double d);
  friend __declspec(dllimport) SbVec3s operator *(int d, const SbVec3s & v);
  friend __declspec(dllimport) SbVec3s operator *(double d, const SbVec3s & v);
  friend __declspec(dllimport) SbVec3s operator /(const SbVec3s & v, int d);
  friend __declspec(dllimport) SbVec3s operator /(const SbVec3s & v, double d);
  friend __declspec(dllimport) SbVec3s operator +(const SbVec3s & v1, const SbVec3s & v2);
  friend __declspec(dllimport) SbVec3s operator -(const SbVec3s & v1, const SbVec3s & v2);
  friend __declspec(dllimport) int operator ==(const SbVec3s & v1, const SbVec3s & v2);
  friend __declspec(dllimport) int operator !=(const SbVec3s & v1, const SbVec3s & v2);

  void print(FILE * fp) const;

private:
  short vec[3];
};

__declspec(dllimport) SbVec3s operator *(const SbVec3s & v, int d);
__declspec(dllimport) SbVec3s operator *(const SbVec3s & v, double d);
__declspec(dllimport) SbVec3s operator *(int d, const SbVec3s & v);
__declspec(dllimport) SbVec3s operator *(double d, const SbVec3s & v);
__declspec(dllimport) SbVec3s operator /(const SbVec3s & v, int d);
__declspec(dllimport) SbVec3s operator /(const SbVec3s & v, double d);
__declspec(dllimport) SbVec3s operator +(const SbVec3s & v1, const SbVec3s & v2);
__declspec(dllimport) SbVec3s operator -(const SbVec3s & v1, const SbVec3s & v2);
__declspec(dllimport) int operator ==(const SbVec3s & v1, const SbVec3s & v2);
__declspec(dllimport) int operator !=(const SbVec3s & v1, const SbVec3s & v2);



inline short &
SbVec3s::operator [](const int i)
{
  return this->vec[i];
}

inline const short &
SbVec3s::operator [](const int i) const
{
  return this->vec[i];
}

#line 95 "c:\\coin3d\\include\\inventor\\sbvec3s.h"
#line 48 "c:\\coin3d\\include\\inventor\\sblinear.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbvec4f.h"




























#line 1 "c:\\coin3d\\include\\inventor\\sbbasic.h"


























































































#line 30 "c:\\coin3d\\include\\inventor\\sbvec4f.h"

class SbVec3f;

class __declspec(dllimport) SbVec4f {
public:
  SbVec4f(void);
  SbVec4f(const float v[4]);
  SbVec4f(const float x, const float y, const float z, const float w);
  float dot(const SbVec4f& v) const;
  SbBool equals(const SbVec4f& v, const float tolerance) const;
  void getReal(SbVec3f& v) const;
  const float* getValue(void) const;
  void getValue(float& x, float& y, float& z, float& w) const;
  float length(void) const;
  void negate(void);
  float normalize(void);
  SbVec4f& setValue(const float v[4]);
  SbVec4f& setValue(const float x, const float y, const float z,
                    const float w);
  float& operator [](const int i);
  const float& operator [](const int i) const;
  SbVec4f& operator *=(const float d);
  SbVec4f& operator /=(const float d);
  SbVec4f& operator +=(const SbVec4f& u);
  SbVec4f& operator -=(const SbVec4f& u);
  SbVec4f operator-(void) const;
  friend __declspec(dllimport) SbVec4f operator *(const SbVec4f& v, const float d);
  friend __declspec(dllimport) SbVec4f operator *(const float d, const SbVec4f& v);
  friend __declspec(dllimport) SbVec4f operator /(const SbVec4f& v, const float d);
  friend __declspec(dllimport) SbVec4f operator +(const SbVec4f& v1, const SbVec4f& v2);
  friend __declspec(dllimport) SbVec4f operator -(const SbVec4f& v1, const SbVec4f& v2);
  friend __declspec(dllimport) int operator ==(const SbVec4f& v1, const SbVec4f& v2);
  friend __declspec(dllimport) int operator !=(const SbVec4f& v1, const SbVec4f& v2);

  void print(FILE * fp) const;

private:
  float vec[4];
};

__declspec(dllimport) SbVec4f operator *(const SbVec4f& v, const float d);
__declspec(dllimport) SbVec4f operator *(const float d, const SbVec4f& v);
__declspec(dllimport) SbVec4f operator /(const SbVec4f& v, const float d);
__declspec(dllimport) SbVec4f operator +(const SbVec4f& v1, const SbVec4f& v2);
__declspec(dllimport) SbVec4f operator -(const SbVec4f& v1, const SbVec4f& v2);
__declspec(dllimport) int operator ==(const SbVec4f& v1, const SbVec4f& v2);
__declspec(dllimport) int operator !=(const SbVec4f& v1, const SbVec4f& v2);

#line 79 "c:\\coin3d\\include\\inventor\\sbvec4f.h"
#line 49 "c:\\coin3d\\include\\inventor\\sblinear.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbsphere.h"



























#line 1 "c:\\coin3d\\include\\inventor\\sbvec3f.h"






































































































#line 29 "c:\\coin3d\\include\\inventor\\sbsphere.h"

class SbLine;
class SbBox3f;

class __declspec(dllimport) SbSphere {
public:
  SbSphere(void);
  SbSphere(const SbVec3f & center, const float radius);
  void setValue(const SbVec3f & center, const float radius);
  void setCenter(const SbVec3f & center);
  void setRadius(const float radius);
  const SbVec3f &  getCenter(void) const;
  float getRadius(void) const;
  void circumscribe(const SbBox3f & box);
  SbBool intersect(const SbLine & l, SbVec3f & intersection) const;
  SbBool intersect(const SbLine & l, SbVec3f & enter, SbVec3f & exit) const;
  SbBool pointInside(const SbVec3f & p) const;

  void print(FILE * file) const;

private:
  SbVec3f center;
  float radius;
};

#line 55 "c:\\coin3d\\include\\inventor\\sbsphere.h"
#line 50 "c:\\coin3d\\include\\inventor\\sblinear.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbrotation.h"



























#line 1 "c:\\coin3d\\include\\inventor\\sbvec4f.h"














































































#line 29 "c:\\coin3d\\include\\inventor\\sbrotation.h"

class SbMatrix;
class SbVec3f;

class __declspec(dllimport) SbRotation {
public:
  SbRotation(void);
  SbRotation(const SbVec3f & axis, const float radians);
  SbRotation(const float q[4]);
  SbRotation(const float q0, const float q1, const float q2, const float q3);
  SbRotation(const SbMatrix & m);
  SbRotation(const SbVec3f & rotateFrom, const SbVec3f & rotateTo);
  const float * getValue(void) const;
  void getValue(float & q0, float & q1, float & q2, float & q3) const;
  SbRotation & setValue(const float q0, const float q1,
                        const float q2, const float q3);
  void getValue(SbVec3f & axis, float & radians) const;
  void getValue(SbMatrix & matrix) const;
  SbRotation & invert(void);
  SbRotation inverse(void) const;
  SbRotation & setValue(const float q[4]);
  SbRotation & setValue(const SbMatrix & m);
  SbRotation & setValue(const SbVec3f & axis, const float radians);
  SbRotation & setValue(const SbVec3f & rotateFrom, const SbVec3f & rotateTo);
  SbRotation & operator*=(const SbRotation & q);
  SbRotation & operator*=(const float s);
  friend __declspec(dllimport) int operator==(const SbRotation & q1, const SbRotation & q2);
  friend __declspec(dllimport) int operator!=(const SbRotation & q1, const SbRotation & q2);
  SbBool equals(const SbRotation & r, const float tolerance) const;
  friend __declspec(dllimport) SbRotation operator *(const SbRotation & q1, const SbRotation & q2);
  void multVec(const SbVec3f & src, SbVec3f & dst) const;

  void scaleAngle(const float scaleFactor);
  static SbRotation slerp(const SbRotation & rot0, const SbRotation & rot1,
                          float t);
  static SbRotation identity(void);

  void print(FILE * fp) const;

private:
  SbVec4f quat;
};

__declspec(dllimport) int operator ==(const SbRotation & q1, const SbRotation & q2);
__declspec(dllimport) int operator !=(const SbRotation & q1, const SbRotation & q2);
__declspec(dllimport) SbRotation operator *(const SbRotation & q1, const SbRotation & q2);

#line 77 "c:\\coin3d\\include\\inventor\\sbrotation.h"
#line 51 "c:\\coin3d\\include\\inventor\\sblinear.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbline.h"




























#line 1 "c:\\coin3d\\include\\inventor\\sbbasic.h"


























































































#line 30 "c:\\coin3d\\include\\inventor\\sbline.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbvec3f.h"






































































































#line 31 "c:\\coin3d\\include\\inventor\\sbline.h"

class __declspec(dllimport) SbLine {
public:
  SbLine(void);
  SbLine(const SbVec3f & origin, const SbVec3f & point);
  void setValue(const SbVec3f & origin, const SbVec3f & point);
  SbBool getClosestPoints(const SbLine & line2,
                          SbVec3f & ptOnThis, SbVec3f & ptOnLine2) const;
  SbVec3f getClosestPoint(const SbVec3f & point) const;
  const SbVec3f & getPosition(void) const;
  const SbVec3f & getDirection(void) const;

  void print(FILE * file) const;

private:
  SbVec3f pos, dir;
};

#line 50 "c:\\coin3d\\include\\inventor\\sbline.h"
#line 52 "c:\\coin3d\\include\\inventor\\sblinear.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbcylinder.h"




























#line 1 "c:\\coin3d\\include\\inventor\\sbbasic.h"


























































































#line 30 "c:\\coin3d\\include\\inventor\\sbcylinder.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbline.h"

















































#line 31 "c:\\coin3d\\include\\inventor\\sbcylinder.h"

class __declspec(dllimport) SbCylinder {
public:
  SbCylinder(void);
  SbCylinder(const SbLine& a, const float r);
  void setValue(const SbLine& a, const float r);
  void setAxis(const SbLine& a);
  void setRadius(const float r);
  const SbLine& getAxis(void) const;
  float getRadius(void) const;
  SbBool intersect(const SbLine& l, SbVec3f& intersection) const;
  SbBool intersect(const SbLine& l, SbVec3f& enter, SbVec3f& exit) const;

  void print(FILE * file) const;

private:
  SbLine axis;
  float radius;
};

#line 52 "c:\\coin3d\\include\\inventor\\sbcylinder.h"
#line 53 "c:\\coin3d\\include\\inventor\\sblinear.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbplane.h"




























#line 1 "c:\\coin3d\\include\\inventor\\sbvec3f.h"






































































































#line 30 "c:\\coin3d\\include\\inventor\\sbplane.h"

class SbLine;
class SbMatrix;

class __declspec(dllimport) SbPlane {
public:
  SbPlane(void);
  SbPlane(const SbVec3f& normal, const float D);
  SbPlane(const SbVec3f& p0, const SbVec3f& p1, const SbVec3f& p2);
  SbPlane(const SbVec3f& normal, const SbVec3f& point);

  void offset(const float d);
  SbBool intersect(const SbLine& l, SbVec3f& intersection) const;
  void transform(const SbMatrix& matrix);
  SbBool isInHalfSpace(const SbVec3f& point) const;
  float getDistance(const SbVec3f &point) const;
  const SbVec3f& getNormal(void) const;
  float getDistanceFromOrigin(void) const;
  friend __declspec(dllimport) int operator ==(const SbPlane& p1, const SbPlane& p2);
  friend __declspec(dllimport) int operator !=(const SbPlane& p1, const SbPlane& p2);

  void print(FILE * file) const;

  SbBool intersect(const SbPlane & pl, SbLine & line);

private:
  SbVec3f normal;
  float distance;
};

__declspec(dllimport) int operator ==(const SbPlane& p1, const SbPlane& p2);
__declspec(dllimport) int operator !=(const SbPlane& p1, const SbPlane& p2);

#line 64 "c:\\coin3d\\include\\inventor\\sbplane.h"
#line 54 "c:\\coin3d\\include\\inventor\\sblinear.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbmatrix.h"



























#line 1 "c:\\coin3d\\include\\inventor\\sbbasic.h"


























































































#line 29 "c:\\coin3d\\include\\inventor\\sbmatrix.h"

class SbLine;
class SbRotation;
class SbVec3f;
class SbVec4f;

typedef float SbMat[4][4];

class __declspec(dllimport) SbMatrix {
public:
  SbMatrix(void);
  SbMatrix(const float a11, const float a12, const float a13, const float a14,
           const float a21, const float a22, const float a23, const float a24,
           const float a31, const float a32, const float a33, const float a34,
           const float a41, const float a42, const float a43, const float a44);
  SbMatrix(const SbMat & matrix);
  SbMatrix(const SbMat * matrix);
  ~SbMatrix(void);

  SbMatrix & operator =(const SbMat & m);

  operator float*(void);
  SbMatrix & operator =(const SbMatrix & m);
  void setValue(const SbMat & m);
  const SbMat & getValue(void) const;

  void makeIdentity(void);
  void setRotate(const SbRotation & q);
  SbMatrix inverse(void) const;
  float det3(int r1, int r2, int r3,
             int c1, int c2, int c3) const;
  float det3(void) const;
  float det4(void) const;

  SbBool equals(const SbMatrix & m, float tolerance) const;


  operator SbMat&(void);
  float * operator [](int i);
  const float * operator [](int i) const;
  SbMatrix & operator =(const SbRotation & q);
  SbMatrix & operator *=(const SbMatrix & m);
  friend __declspec(dllimport) SbMatrix operator *(const SbMatrix & m1, const SbMatrix & m2);
  friend __declspec(dllimport) int operator ==(const SbMatrix & m1, const SbMatrix & m2);
  friend __declspec(dllimport) int operator !=(const SbMatrix & m1, const SbMatrix & m2);
  void getValue(SbMat & m) const;
  static SbMatrix identity(void);
  void setScale(const float s);
  void setScale(const SbVec3f & s);
  void setTranslate(const SbVec3f & t);
  void setTransform(const SbVec3f & t, const SbRotation & r, const SbVec3f & s);
  void setTransform(const SbVec3f & t, const SbRotation & r, const SbVec3f & s,
                    const SbRotation & so);
  void setTransform(const SbVec3f & translation,
                    const SbRotation & rotation, const SbVec3f & scaleFactor,
                    const SbRotation & scaleOrientation, const SbVec3f & center);
  void getTransform(SbVec3f & t, SbRotation & r,
                    SbVec3f & s, SbRotation & so) const;
  void getTransform(SbVec3f & translation, SbRotation & rotation,
                    SbVec3f & scaleFactor, SbRotation & scaleOrientation,
                    const SbVec3f & center) const;
  SbBool factor(SbMatrix & r, SbVec3f & s, SbMatrix & u, SbVec3f & t,
                SbMatrix & proj);
  SbBool LUDecomposition(int index[4], float & d);
  void LUBackSubstitution(int index[4], float b[4]) const;
  SbMatrix transpose(void) const;
  SbMatrix & multRight(const SbMatrix & m);
  SbMatrix & multLeft(const SbMatrix & m);
  void multMatrixVec(const SbVec3f & src, SbVec3f & dst) const;
  void multVecMatrix(const SbVec3f & src, SbVec3f & dst) const;
  void multDirMatrix(const SbVec3f & src, SbVec3f & dst) const;
  void multLineMatrix(const SbLine & src, SbLine & dst) const;
  void multVecMatrix(const SbVec4f & src, SbVec4f & dst) const;

  void print(FILE * fp) const;

private:
  float matrix[4][4];

  void operator /=(const float v);
  void operator *=(const float v);
};

__declspec(dllimport) SbMatrix operator *(const SbMatrix & m1, const SbMatrix & m2);
__declspec(dllimport) int operator ==(const SbMatrix & m1, const SbMatrix & m2);
__declspec(dllimport) int operator !=(const SbMatrix & m1, const SbMatrix & m2);

#line 117 "c:\\coin3d\\include\\inventor\\sbmatrix.h"
#line 55 "c:\\coin3d\\include\\inventor\\sblinear.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbrotation.h"












































































#line 56 "c:\\coin3d\\include\\inventor\\sblinear.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbplane.h"































































#line 57 "c:\\coin3d\\include\\inventor\\sblinear.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbviewvolume.h"




























#line 1 "c:\\coin3d\\include\\inventor\\sbbasic.h"


























































































#line 30 "c:\\coin3d\\include\\inventor\\sbviewvolume.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbvec3f.h"






































































































#line 31 "c:\\coin3d\\include\\inventor\\sbviewvolume.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbdpviewvolume.h"




























#line 1 "c:\\coin3d\\include\\inventor\\sbbasic.h"


























































































#line 30 "c:\\coin3d\\include\\inventor\\sbdpviewvolume.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbvec3d.h"



























#line 1 "c:\\coin3d\\include\\inventor\\sbbasic.h"


























































































#line 29 "c:\\coin3d\\include\\inventor\\sbvec3d.h"

class SbVec3f;

class __declspec(dllimport) SbVec3d {
public:
  SbVec3d(void) { }
  SbVec3d(const double v[3]);
  SbVec3d(const double x, const double y, const double z);
  SbVec3d(const SbVec3f & v);
  SbVec3d cross(const SbVec3d & v) const;
  double dot(const SbVec3d & v) const;
  SbBool equals(const SbVec3d & v, const double tolerance) const;
  SbVec3d getClosestAxis(void) const;
  const double * getValue(void) const;
  void getValue(double & x, double & y, double & z) const;
  double length(void) const;
  double sqrLength() const;
  void negate(void);
  double normalize(void);
  SbVec3d & setValue(const double v[3]);
  SbVec3d & setValue(const double x, const double y, const double z);
  SbVec3d & setValue(const SbVec3d & barycentric,
                     const SbVec3d & v0,
                     const SbVec3d & v1,
                     const SbVec3d & v2);
  SbVec3d & setValue(const SbVec3f & v);
  double & operator [](const int i);
  const double & operator [](const int i) const;
  SbVec3d & operator *=(const double d);
  SbVec3d & operator /=(const double d);
  SbVec3d & operator +=(const SbVec3d & u);
  SbVec3d & operator -=(const SbVec3d & u);
  SbVec3d operator -(void) const;
  friend __declspec(dllimport) SbVec3d operator *(const SbVec3d & v, const double d);
  friend __declspec(dllimport) SbVec3d operator *(const double d, const SbVec3d & v);
  friend __declspec(dllimport) SbVec3d operator /(const SbVec3d & v, const double d);
  friend __declspec(dllimport) SbVec3d operator +(const SbVec3d & v1, const SbVec3d & v2);
  friend __declspec(dllimport) SbVec3d operator -(const SbVec3d & v1, const SbVec3d & v2);
  friend __declspec(dllimport) int operator ==(const SbVec3d & v1, const SbVec3d & v2);
  friend __declspec(dllimport) int operator !=(const SbVec3d & v1, const SbVec3d & v2);

  void print(FILE * fp) const;

private:
  double vec[3];
};

__declspec(dllimport) SbVec3d operator *(const SbVec3d & v, const double d);
__declspec(dllimport) SbVec3d operator *(const double d, const SbVec3d & v);
__declspec(dllimport) SbVec3d operator /(const SbVec3d & v, const double d);
__declspec(dllimport) SbVec3d operator +(const SbVec3d & v1, const SbVec3d & v2);
__declspec(dllimport) SbVec3d operator -(const SbVec3d & v1, const SbVec3d & v2);
__declspec(dllimport) int operator ==(const SbVec3d & v1, const SbVec3d & v2);
__declspec(dllimport) int operator !=(const SbVec3d & v1, const SbVec3d & v2);




inline double &
SbVec3d::operator [](const int i)
{
  return this->vec[i];
}

inline const double &
SbVec3d::operator [](const int i) const
{
  return this->vec[i];
}

#line 100 "c:\\coin3d\\include\\inventor\\sbvec3d.h"
#line 31 "c:\\coin3d\\include\\inventor\\sbdpviewvolume.h"

class SbBox3f;
class SbDPLine;
class SbDPMatrix;
class SbPlane;
class SbDPRotation;
class SbVec2d;
class SbViewVolume;

class __declspec(dllimport) SbDPViewVolume {
public:
  enum ProjectionType { ORTHOGRAPHIC = 0, PERSPECTIVE = 1 };

public:
  SbDPViewVolume(void);
  ~SbDPViewVolume(void);
  void getMatrices(SbDPMatrix& affine, SbDPMatrix& proj) const;
  SbDPMatrix getMatrix(void) const;
  SbDPMatrix getCameraSpaceMatrix(void) const;
  void projectPointToLine(const SbVec2d& pt, SbDPLine& line) const;
  void projectPointToLine(const SbVec2d& pt,
                          SbVec3d& line0, SbVec3d& line1) const;
  void projectToScreen(const SbVec3d& src, SbVec3d& dst) const;
  SbPlane getPlane(const double distFromEye) const;
  SbVec3d getSightPoint(const double distFromEye) const;
  SbVec3d getPlanePoint(const double distFromEye,
                        const SbVec2d& normPoint) const;
  SbDPRotation getAlignRotation(SbBool rightAngleOnly = 0) const;
  double getWorldToScreenScale(const SbVec3d& worldCenter,
                              double normRadius) const;
  SbVec2d projectBox(const SbBox3f& box) const;
  SbDPViewVolume narrow(double left, double bottom,
                      double right, double top) const;
  SbDPViewVolume narrow(const SbBox3f& box) const;
  void ortho(double left, double right,
             double bottom, double top,
             double nearval, double farval);
  void perspective(double fovy, double aspect,
                   double nearval, double farval);
  void frustum(double left, double right,
               double bottom, double top,
               double nearval, double farval);
  void rotateCamera(const SbDPRotation& q);
  void translateCamera(const SbVec3d& v);
  SbVec3d zVector(void) const;
  SbDPViewVolume zNarrow(double nearval, double farval) const;
  void scale(double factor);
  void scaleWidth(double ratio);
  void scaleHeight(double ratio);
  ProjectionType getProjectionType(void) const;
  const SbVec3d& getProjectionPoint(void) const;
  const SbVec3d& getProjectionDirection(void) const;
  double getNearDist(void) const;
  double getWidth(void) const;
  double getHeight(void) const;
  double getDepth(void) const;

  void print(FILE * fp) const;
  void getViewVolumePlanes(SbPlane planes[6]) const;
  void transform(const SbDPMatrix &matrix);
  SbVec3d getViewUp(void) const;

  void copyValues(SbViewVolume & vv);

private:

  ProjectionType type;
  SbVec3d projPoint;
  SbVec3d projDir;
  double nearDist;
  double nearToFar;
  SbVec3d llf;
  SbVec3d lrf;
  SbVec3d ulf;

  void getPlaneRectangle(const double depth, SbVec3d & lowerleft,
                         SbVec3d & lowerright, SbVec3d & upperleft,
                         SbVec3d & upperright) const;
};

#line 112 "c:\\coin3d\\include\\inventor\\sbdpviewvolume.h"
#line 32 "c:\\coin3d\\include\\inventor\\sbviewvolume.h"

class SbBox3f;
class SbLine;
class SbMatrix;
class SbPlane;
class SbRotation;
class SbVec2f;
class SbVec3f;

class __declspec(dllimport) SbViewVolume {
public:
  enum ProjectionType { ORTHOGRAPHIC = 0, PERSPECTIVE = 1 };

public:
  SbViewVolume(void);
  ~SbViewVolume(void);
  void getMatrices(SbMatrix& affine, SbMatrix& proj) const;
  SbMatrix getMatrix(void) const;
  SbMatrix getCameraSpaceMatrix(void) const;
  void projectPointToLine(const SbVec2f& pt, SbLine& line) const;
  void projectPointToLine(const SbVec2f& pt,
                          SbVec3f& line0, SbVec3f& line1) const;
  void projectToScreen(const SbVec3f& src, SbVec3f& dst) const;
  SbPlane getPlane(const float distFromEye) const;
  SbVec3f getSightPoint(const float distFromEye) const;
  SbVec3f getPlanePoint(const float distFromEye,
                        const SbVec2f& normPoint) const;
  SbRotation getAlignRotation(SbBool rightAngleOnly = 0) const;
  float getWorldToScreenScale(const SbVec3f& worldCenter,
                              float normRadius) const;
  SbVec2f projectBox(const SbBox3f& box) const;
  SbViewVolume narrow(float left, float bottom,
                      float right, float top) const;
  SbViewVolume narrow(const SbBox3f& box) const;
  void ortho(float left, float right,
             float bottom, float top,
             float nearval, float farval);
  void perspective(float fovy, float aspect,
                   float nearval, float farval);
  void frustum(float left, float right,
               float bottom, float top,
               float nearval, float farval);
  void rotateCamera(const SbRotation& q);
  void translateCamera(const SbVec3f& v);
  SbVec3f zVector(void) const;
  SbViewVolume zNarrow(float nearval, float farval) const;
  void scale(float factor);
  void scaleWidth(float ratio);
  void scaleHeight(float ratio);
  ProjectionType getProjectionType(void) const;
  const SbVec3f& getProjectionPoint(void) const;
  const SbVec3f& getProjectionDirection(void) const;
  float getNearDist(void) const;
  float getWidth(void) const;
  float getHeight(void) const;
  float getDepth(void) const;

  void print(FILE * fp) const;
  void getViewVolumePlanes(SbPlane planes[6]) const;
  void transform(const SbMatrix &matrix);
  SbVec3f getViewUp(void) const;
  
  SbBool intersect(const SbVec3f & p) const;
  SbBool intersect(const SbVec3f & p0, const SbVec3f & p1,
                   SbVec3f & closestpoint) const;
  SbBool intersect(const SbBox3f & box) const;
  
  SbBool outsideTest(const SbPlane & p,
                     const SbVec3f & bmin, const SbVec3f & bmax) const;

public:
  
  
  
  
  
  
  ProjectionType type;
  SbVec3f projPoint;
  SbVec3f projDir;
  float nearDist;
  float nearToFar;
  SbVec3f llf;
  SbVec3f lrf;
  SbVec3f ulf;

private:
  
  SbDPViewVolume dpvv;
};

#line 124 "c:\\coin3d\\include\\inventor\\sbviewvolume.h"
#line 58 "c:\\coin3d\\include\\inventor\\sblinear.h"

#line 60 "c:\\coin3d\\include\\inventor\\sblinear.h"
#line 28 "c:\\coin3d\\include\\inventor\\qt\\soqtcomponent.h"
#line 1 "c:\\coin3d\\include\\inventor\\qt\\soqtobject.h"


























#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\assert.h"















#line 17 "c:\\programme\\microsoft visual studio\\vc98\\include\\assert.h"



















#line 37 "c:\\programme\\microsoft visual studio\\vc98\\include\\assert.h"




















extern "C" {
#line 59 "c:\\programme\\microsoft visual studio\\vc98\\include\\assert.h"

__declspec(dllimport) void __cdecl _assert(void *, void *, unsigned);


}
#line 65 "c:\\programme\\microsoft visual studio\\vc98\\include\\assert.h"



#line 69 "c:\\programme\\microsoft visual studio\\vc98\\include\\assert.h"
#line 28 "c:\\coin3d\\include\\inventor\\qt\\soqtobject.h"

#line 1 "c:\\coin3d\\include\\inventor\\sbbasic.h"


























































































#line 30 "c:\\coin3d\\include\\inventor\\qt\\soqtobject.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbstring.h"












































































































































#line 31 "c:\\coin3d\\include\\inventor\\qt\\soqtobject.h"
#line 1 "c:\\coin3d\\include\\inventor\\sotype.h"















































































































































#line 32 "c:\\coin3d\\include\\inventor\\qt\\soqtobject.h"

#line 1 "c:\\coin3d\\include\\inventor\\qt\\soqtbasic.h"












































































































































#line 34 "c:\\coin3d\\include\\inventor\\qt\\soqtobject.h"



class __declspec(dllimport) SoQtObject {
  static SoType classTypeId;

public:
  static void initClass(void);
  static SoType getClassTypeId(void);
  virtual SoType getTypeId(void) const = 0;
  SbBool isOfType(SoType type) const;

  static void init(void);

}; 

































































#line 115 "c:\\coin3d\\include\\inventor\\qt\\soqtobject.h"
#line 29 "c:\\coin3d\\include\\inventor\\qt\\soqtcomponent.h"


class QWidget;
#line 33 "c:\\coin3d\\include\\inventor\\qt\\soqtcomponent.h"











class SoQtComponent;
class SoQtCursor;

typedef void SoQtComponentCB(void * user, SoQtComponent * component);
typedef void SoQtComponentVisibilityCB(void * user, SbBool visible);



class __declspec(dllimport) SoQtComponent : public SoQtObject {
  public: static void initClass(void); static SoType getClassTypeId(void); virtual SoType getTypeId(void) const ; private: typedef SoQtObject inherited; static SoType classTypeId;

public:
  virtual ~SoQtComponent();

  virtual void show(void);
  virtual void hide(void);

  virtual void setComponentCursor(const SoQtCursor & cursor);
  static void setWidgetCursor(QWidget * w, const SoQtCursor & cursor);

  SbBool isFullScreen(void) const;
  SbBool setFullScreen(const SbBool onoff);

  SbBool isVisible(void);
  SbBool isTopLevelShell(void) const;

  QWidget * getWidget(void) const;
  QWidget * getBaseWidget(void) const;
  QWidget * getShellWidget(void) const;
  QWidget * getParentWidget(void) const;

  void setSize(const SbVec2s size);
  SbVec2s getSize(void) const;

  void setTitle(const char * const title);
  const char * getTitle(void) const;
  void setIconTitle(const char * const title);
  const char * getIconTitle(void) const;

  const char * getWidgetName(void) const;
  const char * getClassName(void) const;

  void setWindowCloseCallback(SoQtComponentCB * const func,
                              void * const user = 0);
  static SoQtComponent * getComponent(QWidget * widget);

  static void initClasses(void);

protected:
  SoQtComponent(QWidget * const parent = 0,
                   const char * const name = 0,
                   const SbBool embed = 1);

  virtual void afterRealizeHook(void);

  void setClassName(const char * const name);
  void setBaseWidget(QWidget * widget);

  void registerWidget(QWidget * widget);
  void unregisterWidget(QWidget * widget);

  virtual const char * getDefaultWidgetName(void) const;
  virtual const char * getDefaultTitle(void) const;
  virtual const char * getDefaultIconTitle(void) const;

  virtual void sizeChanged(const SbVec2s & size);

  void addVisibilityChangeCallback(SoQtComponentVisibilityCB * const func,
                                   void * const user = 0);
  void removeVisibilityChangeCallback(SoQtComponentVisibilityCB * const func,
                                      void * const user = 0);

private:
  class SoQtComponentP * pimpl;

  friend class SoGuiComponentP;
  friend class SoQtComponentP;
#line 122 "c:\\coin3d\\include\\inventor\\qt\\soqtcomponent.h"

  

















































};



#line 178 "c:\\coin3d\\include\\inventor\\qt\\soqtcomponent.h"
#line 30 "c:\\coin3d\\include\\inventor\\qt\\soqtglwidget.h"


class QEvent;
#line 34 "c:\\coin3d\\include\\inventor\\qt\\soqtglwidget.h"












enum GLModes {
  SO_GL_RGB      = 0x01, SO_GLX_RGB      = SO_GL_RGB,
  SO_GL_DOUBLE   = 0x02, SO_GLX_DOUBLE   = SO_GL_DOUBLE,
  SO_GL_ZBUFFER  = 0x04, SO_GLX_ZBUFFER  = SO_GL_ZBUFFER,
  SO_GL_OVERLAY  = 0x08, SO_GLX_OVERLAY  = SO_GL_OVERLAY,
  SO_GL_STEREO   = 0x10, SO_GLX_STEREO   = SO_GL_STEREO
};



class __declspec(dllimport) SoQtGLWidget : public SoQtComponent {
  public: static void initClass(void); static SoType getClassTypeId(void); virtual SoType getTypeId(void) const ; private: typedef SoQtComponent inherited; static SoType classTypeId;

public:

  void setBorder(const SbBool enable);
  SbBool isBorder(void) const;

  virtual void setDoubleBuffer(const SbBool enable);
  SbBool isDoubleBuffer(void) const;

  void setDrawToFrontBufferEnable(const SbBool enable);
  SbBool isDrawToFrontBufferEnable(void) const;
  
  void setQuadBufferStereo(const SbBool enable);
  SbBool isQuadBufferStereo(void) const;

  void setAccumulationBuffer(const SbBool enable);
  SbBool getAccumulationBuffer(void) const;

  void setStencilBuffer(const SbBool enable);
  SbBool getStencilBuffer(void) const;

  void setOverlayRender(const SbBool onoff);
  SbBool isOverlayRender(void) const;

  QWidget * getGLWidget(void) const;
  QWidget * getNormalWidget(void) const;
  QWidget * getOverlayWidget(void) const;

  SbBool hasOverlayGLArea(void) const;
  SbBool hasNormalGLArea(void) const;

  unsigned long getOverlayTransparentPixel(void);

  
  void getPointSizeLimits(SbVec2f & range, float & granularity);
  void getLineWidthLimits(SbVec2f & range, float & granularity);

protected:
  SoQtGLWidget(QWidget * const parent = 0,
                  const char * const name = 0,
                  const SbBool embed = 1,
                  const int glmodes = SO_GL_RGB,
                  const SbBool build = 1);
  ~SoQtGLWidget();

  virtual void processEvent(QEvent * event);

  QWidget * buildWidget(QWidget * parent);

  virtual void redraw(void) = 0;
  virtual void redrawOverlay(void);

  virtual void initGraphic(void);
  virtual void initOverlayGraphic(void);

  virtual void sizeChanged(const SbVec2s & size);
  virtual void widgetChanged(QWidget * w);

  void setGLSize(const SbVec2s size);
  SbVec2s getGLSize(void) const;
  float getGLAspectRatio(void) const;

  
  void setGlxSize(const SbVec2s size) { this->setGLSize(size); }
  SbVec2s getGlxSize(void) const { return this->getGLSize(); }
  float getGlxAspectRatio(void) const { return this->getGLAspectRatio(); }

  void setStereoBuffer(SbBool flag);
  SbBool isStereoBuffer(void) const;

  SbBool isRGBMode(void);

  SbBool waitForExpose;
  SbBool drawToFrontBuffer;

  void glLockNormal(void);
  void glUnlockNormal(void);

  void glLockOverlay(void);
  void glUnlockOverlay(void);

  void glSwapBuffers(void);
  void glFlushBuffer(void);

  virtual SbBool glScheduleRedraw(void);

private:
  class SoQtGLWidgetP * pimpl;

  friend class SoGuiGLWidgetP;
  friend class SoQtGLWidgetP;
#line 150 "c:\\coin3d\\include\\inventor\\qt\\soqtglwidget.h"

  







































};



#line 196 "c:\\coin3d\\include\\inventor\\qt\\soqtglwidget.h"
#line 35 "c:\\coin3d\\include\\inventor\\qt\\soqtrenderarea.h"

class SbColor;
class SoNode;
class SoSelection;

class SoQtDevice;



class SoQtRenderAreaP;

typedef SbBool SoQtRenderAreaEventCB(void * closure, QEvent * event);



class __declspec(dllimport) SoQtRenderArea : public SoQtGLWidget {
  public: static void initClass(void); static SoType getClassTypeId(void); virtual SoType getTypeId(void) const; static void * createInstance(void); private: typedef SoQtGLWidget inherited; static SoType classTypeId;

public:
  SoQtRenderArea(QWidget * parent = 0,
                    const char * name = 0,
                    SbBool embed = 1,
                    SbBool mouseInput = 1,
                    SbBool keyboardInput = 1);
  ~SoQtRenderArea();

  virtual void setSceneGraph(SoNode * scene);
  virtual SoNode * getSceneGraph(void);
  void setOverlaySceneGraph(SoNode * scene);
  SoNode * getOverlaySceneGraph(void);

  void setBackgroundColor(const SbColor & color);
  const SbColor & getBackgroundColor(void) const;
  void setBackgroundIndex(int idx);
  int getBackgroundIndex(void) const;
  void setOverlayBackgroundIndex(int idx);
  int getOverlayBackgroundIndex(void) const;
  void setColorMap(int start, int num, const SbColor * colors);
  void setOverlayColorMap(int start, int num, const SbColor * colors);
  void setViewportRegion(const SbViewportRegion & newRegion);
  const SbViewportRegion & getViewportRegion(void) const;
  void setTransparencyType(SoGLRenderAction::TransparencyType type);
  SoGLRenderAction::TransparencyType getTransparencyType(void) const;
  void setAntialiasing(SbBool smoothing, int numPasses);
  void getAntialiasing(SbBool & smoothing, int & numPasses) const;
  void setClearBeforeRender(SbBool enable, SbBool zbEnable = 1);
  SbBool isClearBeforeRender(void) const;
  SbBool isClearZBufferBeforeRender(void) const;
  void setClearBeforeOverlayRender(SbBool enable);
  SbBool isClearBeforeOverlayRender(void) const;
  void setAutoRedraw(SbBool enable);
  SbBool isAutoRedraw(void) const;
  void setRedrawPriority(uint32_t priority);
  uint32_t getRedrawPriority(void) const;
  static uint32_t getDefaultRedrawPriority(void);
  void render(void);
  void renderOverlay(void);
  void scheduleRedraw(void);
  void scheduleOverlayRedraw(void);
  void redrawOnSelectionChange(SoSelection * selection);
  void redrawOverlayOnSelectionChange(SoSelection * selection);
  void setEventCallback(SoQtRenderAreaEventCB * func, void * user = 0);
  void setSceneManager(SoSceneManager * manager);
  SoSceneManager * getSceneManager(void) const;
  void setOverlaySceneManager(SoSceneManager * manager);
  SoSceneManager * getOverlaySceneManager(void) const;
  void setGLRenderAction(SoGLRenderAction * action);
  SoGLRenderAction * getGLRenderAction(void) const;
  void setOverlayGLRenderAction(SoGLRenderAction * action);
  SoGLRenderAction * getOverlayGLRenderAction(void) const;

  SbBool sendSoEvent(const SoEvent * event);

  void registerDevice(SoQtDevice * device);
  void unregisterDevice(SoQtDevice * device);


protected:
  SoQtRenderArea(QWidget * parent,
                    const char * name,
                    SbBool embed,
                    SbBool mouseInput,
                    SbBool keyboardInput,
                    SbBool build);

  virtual void redraw(void);
  virtual void actualRedraw(void);
  virtual void redrawOverlay(void);
  virtual void actualOverlayRedraw(void);

  virtual SbBool processSoEvent(const SoEvent * const event);
  virtual void processEvent(QEvent * event);
  virtual void initGraphic(void);
  virtual void initOverlayGraphic(void);
  virtual void sizeChanged(const SbVec2s & size);
  virtual void widgetChanged(QWidget * widget);
  virtual void afterRealizeHook(void);

  QWidget * buildWidget(QWidget * parent);

  virtual const char * getDefaultWidgetName(void) const;
  virtual const char * getDefaultTitle(void) const;
  virtual const char * getDefaultIconTitle(void) const;

  virtual SbBool glScheduleRedraw(void);

private:
  class SoQtRenderAreaP * pimpl;

  friend class SoQtRenderAreaP;
#line 146 "c:\\coin3d\\include\\inventor\\qt\\soqtrenderarea.h"
};



#line 151 "c:\\coin3d\\include\\inventor\\qt\\soqtrenderarea.h"
#line 19 "h:\\c_projekte\\elansim\\headview.cpp"
#line 1 "c:\\coin3d\\include\\inventor\\nodes\\soperspectivecamera.h"


























#line 1 "c:\\coin3d\\include\\inventor\\nodes\\sosubnode.h"


























#line 1 "c:\\coin3d\\include\\inventor\\sbname.h"


































































#line 28 "c:\\coin3d\\include\\inventor\\nodes\\sosubnode.h"
#line 1 "c:\\coin3d\\include\\inventor\\sotype.h"















































































































































#line 29 "c:\\coin3d\\include\\inventor\\nodes\\sosubnode.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\sofielddata.h"


























#line 1 "c:\\coin3d\\include\\inventor\\sbbasic.h"


























































































#line 28 "c:\\coin3d\\include\\inventor\\fields\\sofielddata.h"
#line 1 "c:\\coin3d\\include\\inventor\\lists\\sblist.h"





































































































































































































































#line 29 "c:\\coin3d\\include\\inventor\\fields\\sofielddata.h"

class SbName;
class SoField;
class SoFieldContainer;
class SoInput;
class SoOutput;

class SoEnumEntry;
class SoFieldEntry;

class __declspec(dllimport) SoFieldData {
public:
  SoFieldData(void);
  SoFieldData(const SoFieldData & fd);
  SoFieldData(const SoFieldData * fd);
  SoFieldData(int numfields);
  ~SoFieldData();

  void addField(SoFieldContainer * base, const char * name,
                const SoField * field);

  void overlay(SoFieldContainer * to, const SoFieldContainer * from,
               SbBool copyconnections) const;

  int getNumFields(void) const;
  const SbName & getFieldName(int index) const;
  SoField * getField(const SoFieldContainer * object, int index) const;
  int getIndex(const SoFieldContainer * fc, const SoField * field) const;

  void addEnumValue(const char * enumname, const char * valuename, int value);
  void getEnumData(const char * enumname,
                   int & num, const int *& values, const SbName *& names);

  SbBool read(SoInput * in, SoFieldContainer * object,
              SbBool erroronunknownfield, SbBool & notbuiltin) const;
  SbBool read(SoInput * in, SoFieldContainer * object,
              const SbName & fieldname, SbBool & foundname) const;
  void write(SoOutput * out, const SoFieldContainer * object) const;
  void copy(const SoFieldData * src);
  SbBool isSame(const SoFieldContainer * c1,
                const SoFieldContainer * c2) const;

  SbBool readFieldDescriptions(SoInput * in, SoFieldContainer * object,
                               int numdescriptionsexpected,
                               const SbBool readfieldvalues = 1) const;
  void writeFieldDescriptions(SoOutput * out,
                              const SoFieldContainer * object) const;

private:
  SbBool hasField(const char * name) const;
  SbBool hasEnumValue(const char * enumname, const char * valuename);

  
  enum ControlWord {
    NOTBUILTIN = 0x40
  };

  int operator==(const SoFieldData * fd) const;
  int operator!=(const SoFieldData * fd) const { return ! operator==(fd); }
  int operator==(const SoFieldData & fd) const { return operator==(&fd); }
  int operator!=(const SoFieldData & fd) const { return ! operator==(&fd); }

  void freeResources(void);

  SbList<SoFieldEntry *> fields;
  SbList<SoEnumEntry *> enums;
};

#line 98 "c:\\coin3d\\include\\inventor\\fields\\sofielddata.h"
#line 30 "c:\\coin3d\\include\\inventor\\nodes\\sosubnode.h"
#line 1 "c:\\coin3d\\include\\inventor\\nodes\\sonode.h"


























#line 1 "c:\\coin3d\\include\\inventor\\fields\\sofieldcontainer.h"


























#line 1 "c:\\coin3d\\include\\inventor\\misc\\sobase.h"















































































































































#line 28 "c:\\coin3d\\include\\inventor\\fields\\sofieldcontainer.h"

class SbString;
class SoFieldData;
class SoFieldList;
class SoOutput;


class __declspec(dllimport) SoFieldContainer : public SoBase {
  typedef SoBase inherited;

public:
  static void initClass(void);
  static SoType getClassTypeId(void);

  void setToDefaults(void);
  SbBool hasDefaultValues(void) const;

  SbBool fieldsAreEqual(const SoFieldContainer * container) const;
  void copyFieldValues(const SoFieldContainer * container,
                       SbBool copyconnections = 0);

  SbBool set(const char * const fielddata);
  void get(SbString & fielddata);

  virtual int getFields(SoFieldList & l) const;
  virtual int getAllFields(SoFieldList & l) const;
  virtual SoField * getField(const SbName & name) const;
  virtual SoField * getEventIn(const SbName & name) const;
  virtual SoField * getEventOut(const SbName & name) const;
  SbBool getFieldName(const SoField * const field, SbName & name) const;

  SbBool enableNotify(const SbBool flag);
  SbBool isNotifyEnabled(void) const;

  SbBool set(const char * fielddata, SoInput * in);
  void get(SbString & fielddata, SoOutput * out);

  virtual void notify(SoNotList * l);

  virtual SbBool validateNewFieldValue(SoField * field, void * newval);

  virtual void addWriteReference(SoOutput * out, SbBool isfromfield = 0);
  virtual void writeInstance(SoOutput * out);

  SbBool getIsBuiltIn(void) const;
  virtual const SoFieldData * getFieldData(void) const;

  virtual void copyContents(const SoFieldContainer * from,
                            SbBool copyconnections);
  virtual SoFieldContainer * copyThroughConnection(void) const;

  static void initCopyDict(void);
  static void addCopy(const SoFieldContainer * orig,
                      const SoFieldContainer * copy);
  static SoFieldContainer * checkCopy(const SoFieldContainer * orig);
  static SoFieldContainer * findCopy(const SoFieldContainer * orig,
                                     const SbBool copyconnections);
  static void copyDone(void);

  void setUserData(void * userdata) const;
  void * getUserData(void) const;

protected:
  SoFieldContainer(void);
  ~SoFieldContainer();

  virtual SbBool readInstance(SoInput * in, unsigned short flags);
  SbBool isBuiltIn;

private:
  static SoType classTypeId;
  SbBool donotify;
};

#line 103 "c:\\coin3d\\include\\inventor\\fields\\sofieldcontainer.h"
#line 28 "c:\\coin3d\\include\\inventor\\nodes\\sonode.h"

class SoAction;
class SoCallbackAction;
class SoChildList;
class SoGLRenderAction;
class SoGetBoundingBoxAction;
class SoGetMatrixAction;
class SoGetPrimitiveCountAction;
class SoHandleEventAction;
class SoNodeList;
class SoNotList;
class SoOutput;
class SoPickAction;
class SoRayPickAction;
class SoSearchAction;
class SoWriteAction;
class SoAudioRenderAction;
class SbDict;

class __declspec(dllimport) SoNode : public SoFieldContainer {
  typedef SoFieldContainer inherited;

public:
  

  enum Stage { FIRST_INSTANCE, PROTO_INSTANCE, OTHER_INSTANCE };
#line 55 "c:\\coin3d\\include\\inventor\\nodes\\sonode.h"

  void setOverride(const SbBool state);
  SbBool isOverride(void) const;

  enum NodeType {
    INVENTOR     = 0x0000,
    VRML1        = 0x0001,
    VRML2        = 0x0002,
    INVENTOR_1   = 0x0004,
    INVENTOR_2_0 = 0x0008,
    INVENTOR_2_1 = 0x0010,
    INVENTOR_2_5 = 0x0020,
    INVENTOR_2_6 = 0x0040,
    COIN_1_0     = 0x0080,
    COIN_2_0     = 0x0100,
    EXTENSION    = 0x0200,
    COIN_2_2     = 0x0400,
    COIN_2_3     = 0x0800
  };

  static uint32_t getCompatibilityTypes(const SoType & nodetype);
  void setNodeType(const NodeType type);
  NodeType getNodeType(void) const;

  virtual SoNode * copy(SbBool copyconnections = 0) const;
  virtual SbBool affectsState(void) const;

  virtual void doAction(SoAction * action);
  virtual void GLRender(SoGLRenderAction * action);
  virtual void GLRenderBelowPath(SoGLRenderAction * action);
  virtual void GLRenderInPath(SoGLRenderAction * action);
  virtual void GLRenderOffPath(SoGLRenderAction * action);
  virtual void callback(SoCallbackAction * action);
  virtual void getBoundingBox(SoGetBoundingBoxAction * action);
  virtual void getMatrix(SoGetMatrixAction * action);
  virtual void handleEvent(SoHandleEventAction * action);
  virtual void pick(SoPickAction * action);
  virtual void rayPick(SoRayPickAction * action);
  virtual void search(SoSearchAction * action);
  virtual void write(SoWriteAction * action);
  virtual void audioRender(SoAudioRenderAction * action);
  virtual void getPrimitiveCount(SoGetPrimitiveCountAction * action);

  virtual void grabEventsSetup(void);
  virtual void grabEventsCleanup(void);

  virtual void startNotify(void);
  virtual void notify(SoNotList * l);

  uint32_t getNodeId(void) const;
  virtual SoChildList * getChildren(void) const;

  virtual void writeInstance(SoOutput * out);
  virtual SoNode * addToCopyDict(void) const;
  virtual void copyContents(const SoFieldContainer * from,
                            SbBool copyconnections);
  virtual SoFieldContainer * copyThroughConnection(void) const;


  static SoType getClassTypeId(void);
  static SoNode * getByName(const SbName & name);
  static int getByName(const SbName & name, SoNodeList & l);

  static void initClass(void);
  static void initClasses(void);

  static uint32_t getNextNodeId(void);
  static int getActionMethodIndex(const SoType type);

  static void getBoundingBoxS(SoAction * action, SoNode * node);
  static void GLRenderS(SoAction * action, SoNode * node);
  static void callbackS(SoAction * action, SoNode * node);
  static void getMatrixS(SoAction * action, SoNode * node);
  static void handleEventS(SoAction * action, SoNode * node);
  static void pickS(SoAction * action, SoNode * node);
  static void rayPickS(SoAction * action, SoNode * node);
  static void searchS(SoAction * action, SoNode * node);
  static void writeS(SoAction * action, SoNode * node);
  static void audioRenderS(SoAction * action, SoNode * node);
  static void getPrimitiveCountS(SoAction * action, SoNode * node);

protected:
  SoNode(void);
  virtual ~SoNode();

  virtual SbBool readInstance(SoInput * in, unsigned short flags);

  static const SoFieldData ** getFieldDataPtr(void);

  
  
  
  
  static void setNextActionMethodIndex(int index);
  static int getNextActionMethodIndex(void);
  static void incNextActionMethodIndex(void);

  static void setCompatibilityTypes(const SoType & nodetype, const uint32_t bitmask);

  uint32_t uniqueId;
  static uint32_t nextUniqueId;
  static int nextActionMethodIndex;

private:
  static SoType classTypeId;
  uint32_t stateflags;
  void clearStateFlags(const unsigned int bits);
  void setStateFlags(const unsigned int bits);
  SbBool getState(const unsigned int bits) const;
  static SbDict * compatibilitydict;
  static void cleanupClass(void);
};

#line 169 "c:\\coin3d\\include\\inventor\\nodes\\sonode.h"
#line 31 "c:\\coin3d\\include\\inventor\\nodes\\sosubnode.h"





























#line 61 "c:\\coin3d\\include\\inventor\\nodes\\sosubnode.h"




























































































































































#line 218 "c:\\coin3d\\include\\inventor\\nodes\\sosubnode.h"
#line 28 "c:\\coin3d\\include\\inventor\\nodes\\soperspectivecamera.h"
#line 1 "c:\\coin3d\\include\\inventor\\nodes\\socamera.h"


























#line 1 "c:\\coin3d\\include\\inventor\\nodes\\sosubnode.h"

























































































































































































































#line 28 "c:\\coin3d\\include\\inventor\\nodes\\socamera.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbviewportregion.h"









































































#line 29 "c:\\coin3d\\include\\inventor\\nodes\\socamera.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbviewvolume.h"



























































































































#line 30 "c:\\coin3d\\include\\inventor\\nodes\\socamera.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosfrotation.h"


























#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosfield.h"


























#line 1 "c:\\coin3d\\include\\inventor\\fields\\sofield.h"


























#line 1 "c:\\coin3d\\include\\inventor\\sotype.h"















































































































































#line 28 "c:\\coin3d\\include\\inventor\\fields\\sofield.h"
#line 1 "c:\\coin3d\\include\\inventor\\misc\\sonotification.h"





























































#line 29 "c:\\coin3d\\include\\inventor\\fields\\sofield.h"

class SbString;
class SoEngineOutput;
class SoFieldContainer;
class SoFieldConverter;
class SoFieldList;
class SoInput;
class SoOutput;

class __declspec(dllimport) SoField {

public:
  virtual ~SoField();

  static void initClass(void);
  static void initClasses(void);

  void setIgnored(SbBool ignore);
  SbBool isIgnored(void) const;

  void setDefault(SbBool def);
  SbBool isDefault(void) const;

  virtual SoType getTypeId(void) const = 0;

  static SoType getClassTypeId(void);
  SbBool isOfType(const SoType type) const;

  void enableConnection(SbBool flag);
  SbBool isConnectionEnabled(void) const;

  
  SbBool connectFrom(SoEngineOutput * master,
                     SbBool notnotify = 0, SbBool append = 0);
  SbBool appendConnection(SoEngineOutput * master, SbBool notnotify = 0);
  void disconnect(SoEngineOutput * engineoutput);
  SbBool isConnectedFromEngine(void) const;
  SbBool getConnectedEngine(SoEngineOutput *& master) const;

  
  SbBool connectFrom(SoField * master,
                     SbBool notnotify = 0, SbBool append = 0);
  SbBool appendConnection(SoField * master, SbBool notnotify = 0);
  void disconnect(SoField * field);
  SbBool isConnectedFromField(void) const;
  SbBool getConnectedField(SoField *& master) const;
  int getNumConnections(void) const;
  int getForwardConnections(SoFieldList & slavelist) const;
  int getConnections(SoFieldList & masterlist) const;

  void disconnect(void);
  SbBool isConnected(void) const;

  void setContainer(SoFieldContainer * cont);
  SoFieldContainer * getContainer(void) const;

  SbBool set(const char * valuestring);
  void get(SbString & valuestring);

  SbBool shouldWrite(void) const;

  virtual void touch(void);
  virtual void startNotify(void);
  virtual void notify(SoNotList * nlist);
  SbBool enableNotify(SbBool on);
  SbBool isNotifyEnabled(void) const;

  void addAuditor(void * f, SoNotRec::Type type);
  void removeAuditor(void * f, SoNotRec::Type type);

  int operator ==(const SoField & f) const;
  int operator !=(const SoField & f) const;

  virtual void connectionStatusChanged(int numconnections);
  SbBool isReadOnly(void) const;
  virtual SbBool isSame(const SoField & f) const = 0;
  virtual void copyFrom(const SoField & f) = 0;

  virtual void fixCopy(SbBool copyconnections);
  virtual SbBool referencesCopy(void) const;
  void copyConnection(const SoField * fromfield);

  virtual SbBool read(SoInput * in, const SbName & name);
  virtual void write(SoOutput * out, const SbName & name) const;

  virtual void countWriteRefs(SoOutput * out) const;

  
  enum FieldType {
    NORMAL_FIELD = 0,
    EVENTIN_FIELD,
    EVENTOUT_FIELD,
    EXPOSED_FIELD
  };

  void setFieldType(int type);
  int getFieldType(void) const;

  SbBool getDirty(void) const;
  void setDirty(SbBool dirty);

  void evaluate(void) const {
    if ((this->statusbits & (FLAG_EXTSTORAGE|FLAG_NEEDEVALUATION)) == 
        (FLAG_EXTSTORAGE|FLAG_NEEDEVALUATION)) this->evaluateField();
  }

protected:
  SoField(void);

  void valueChanged(SbBool resetdefault = 1);
  virtual void evaluateConnection(void) const;
  virtual SbBool readValue(SoInput * in) = 0;
  virtual void writeValue(SoOutput * out) const = 0;
  virtual SbBool readConnection(SoInput * in);
  virtual void writeConnection(SoOutput * out) const;

  SbBool isDestructing(void) const;

private:

  enum FieldFlags {
    FLAG_TYPEMASK = 0x0007,  
    FLAG_ISDEFAULT = 0x0008,
    FLAG_IGNORE = 0x0010,
    FLAG_EXTSTORAGE = 0x0020,
    FLAG_ENABLECONNECTS = 0x0040,
    FLAG_NEEDEVALUATION = 0x0080,
    FLAG_READONLY = 0x0100,
    FLAG_DONOTIFY = 0x0200,
    FLAG_ISDESTRUCTING = 0x0400,
    FLAG_ISEVALUATING = 0x0800,
    FLAG_ISNOTIFIED = 0x1000
  };

  void evaluateField(void) const;
  void extendStorageIfNecessary(void);
  SoFieldConverter * createConverter(SoType from) const;
  SoFieldContainer * resolveWriteConnection(SbName & mastername) const;

  void notifyAuditors(SoNotList * l);

  static SoType classTypeId;

  
  enum FileFormatFlags {
    IGNORED = 0x01,
    CONNECTED = 0x02,
    DEFAULT = 0x04,
    ALLFILEFLAGS = IGNORED|CONNECTED|DEFAULT
  };

  SbBool changeStatusBits(const unsigned int bits, const SbBool onoff);
  void clearStatusBits(const unsigned int bits);
  void setStatusBits(const unsigned int bits);
  SbBool getStatus(const unsigned int bits) const;
  unsigned int statusbits;
  union {
    SoFieldContainer * container;
    class SoConnectStorage * storage;
  };

  SbBool hasExtendedStorage(void) const;
};




#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosfield.h"













































#line 197 "c:\\coin3d\\include\\inventor\\fields\\sofield.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\somfield.h"


























#line 1 "c:\\coin3d\\include\\inventor\\fields\\sofield.h"








































































































































































































#line 28 "c:\\coin3d\\include\\inventor\\fields\\somfield.h"

class SoInput;
class SoOutput;

class __declspec(dllimport) SoMField : public SoField {
  typedef SoField inherited;

public:
  virtual ~SoMField();

  static SoType getClassTypeId(void);

  int getNum(void) const;
  void setNum(const int num);

  virtual void deleteValues(int start, int num = -1);
  virtual void insertSpace(int start, int num);

  SbBool set1(const int index, const char * const valuestring);
  void get1(const int index, SbString & valuestring);

  static void initClass(void);

  virtual void enableDeleteValues(void);
  virtual SbBool isDeleteValuesEnabled(void);

protected:
  SoMField(void);
  virtual void makeRoom(int newnum);


  virtual int fieldSizeof(void) const = 0;
  virtual void * valuesPtr(void) = 0;
  virtual void setValuesPtr(void * ptr) = 0;
  virtual void allocValues(int num);
#line 64 "c:\\coin3d\\include\\inventor\\fields\\somfield.h"

  int num;
  int maxNum;
  SbBool userDataIsUsed;

private:
  virtual void deleteAllValues(void) = 0;
  virtual void copyValue(int to, int from) = 0;
  virtual SbBool readValue(SoInput * in);
  virtual SbBool read1Value(SoInput * in, int idx) = 0;
  virtual void writeValue(SoOutput * out) const;
  virtual void write1Value(SoOutput * out, int idx) const = 0;
  virtual SbBool readBinaryValues(SoInput * in, int num);
  virtual void writeBinaryValues(SoOutput * out) const;
  virtual int getNumValuesPerLine(void) const;

  static SoType classTypeId;
};



inline int
SoMField::getNum(void) const
{
  this->evaluate();
  return this->num;
}

#line 93 "c:\\coin3d\\include\\inventor\\fields\\somfield.h"
#line 198 "c:\\coin3d\\include\\inventor\\fields\\sofield.h"
#line 199 "c:\\coin3d\\include\\inventor\\fields\\sofield.h"

#line 201 "c:\\coin3d\\include\\inventor\\fields\\sofield.h"
#line 28 "c:\\coin3d\\include\\inventor\\fields\\sosfield.h"

class __declspec(dllimport) SoSField : public SoField {
  typedef SoField inherited;

public:
  virtual ~SoSField();

  static void initClass(void);
  static SoType getClassTypeId(void);

protected:
  SoSField(void);

private:
  static SoType classTypeId;
};

#line 46 "c:\\coin3d\\include\\inventor\\fields\\sosfield.h"
#line 28 "c:\\coin3d\\include\\inventor\\fields\\sosfrotation.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosubfield.h"


























#line 1 "c:\\coin3d\\include\\inventor\\sbbasic.h"


























































































#line 28 "c:\\coin3d\\include\\inventor\\fields\\sosubfield.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbname.h"


































































#line 29 "c:\\coin3d\\include\\inventor\\fields\\sosubfield.h"
#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\assert.h"















#line 17 "c:\\programme\\microsoft visual studio\\vc98\\include\\assert.h"



















#line 37 "c:\\programme\\microsoft visual studio\\vc98\\include\\assert.h"




















extern "C" {
#line 59 "c:\\programme\\microsoft visual studio\\vc98\\include\\assert.h"

__declspec(dllimport) void __cdecl _assert(void *, void *, unsigned);


}
#line 65 "c:\\programme\\microsoft visual studio\\vc98\\include\\assert.h"



#line 69 "c:\\programme\\microsoft visual studio\\vc98\\include\\assert.h"
#line 30 "c:\\coin3d\\include\\inventor\\fields\\sosubfield.h"



#line 1 "c:\\coin3d\\include\\inventor\\fields\\sofield.h"








































































































































































































#line 34 "c:\\coin3d\\include\\inventor\\fields\\sosubfield.h"
#line 1 "c:\\coin3d\\include\\inventor\\soinput.h"


























#line 1 "c:\\coin3d\\include\\inventor\\system\\inttypes.h"


















































































































































































#line 28 "c:\\coin3d\\include\\inventor\\soinput.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbbasic.h"


























































































#line 29 "c:\\coin3d\\include\\inventor\\soinput.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbdict.h"


























































#line 30 "c:\\coin3d\\include\\inventor\\soinput.h"
#line 1 "c:\\coin3d\\include\\inventor\\lists\\sblist.h"





































































































































































































































#line 31 "c:\\coin3d\\include\\inventor\\soinput.h"


 
 #line 1 "c:\\coin3d\\include\\inventor\\sodb.h"


























#line 1 "c:\\coin3d\\include\\inventor\\sbbasic.h"


























































































#line 28 "c:\\coin3d\\include\\inventor\\sodb.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbstring.h"












































































































































#line 29 "c:\\coin3d\\include\\inventor\\sodb.h"
#line 1 "c:\\coin3d\\include\\inventor\\sotype.h"















































































































































#line 30 "c:\\coin3d\\include\\inventor\\sodb.h"
#line 1 "c:\\coin3d\\include\\inventor\\sensors\\sosensormanager.h"


























#line 1 "c:\\coin3d\\include\\inventor\\sbbasic.h"


























































































#line 28 "c:\\coin3d\\include\\inventor\\sensors\\sosensormanager.h"

class SoDelayQueueSensor;
class SoTimerQueueSensor;
class SoTimerSensor;
class SbTime;

class __declspec(dllimport) SoSensorManager {
public:
  SoSensorManager(void);
  ~SoSensorManager();

  void insertDelaySensor(SoDelayQueueSensor * s);
  void insertTimerSensor(SoTimerQueueSensor * s);
  void removeDelaySensor(SoDelayQueueSensor * s);
  void removeTimerSensor(SoTimerQueueSensor * s);

  void setChangedCallback(void (*func)(void *), void * data);

  void rescheduleTimer(SoTimerSensor * s);
  void removeRescheduledTimer(SoTimerQueueSensor * s);

  void processDelayQueue(SbBool isidle);
  void processImmediateQueue(void);
  void processTimerQueue(void);

  SbBool isDelaySensorPending(void);
  SbBool isTimerSensorPending(SbTime & tm);

  void setDelaySensorTimeout(const SbTime & t);
  const SbTime & getDelaySensorTimeout(void);

  int doSelect(int nfds, void * readfds, void * writefds,
               void * exceptfds, struct timeval * userTimeOut);

private:
  void notifyChanged(void);

  int mergeTimerQueues(void);
  int mergeDelayQueues(void);
  
  class SoSensorManagerP * pimpl;
  friend class SoSensorManagerP;
};

#line 73 "c:\\coin3d\\include\\inventor\\sensors\\sosensormanager.h"
#line 31 "c:\\coin3d\\include\\inventor\\sodb.h"

class SbName;
class SbTime;
class SoBase;
class SoField;
class SoInput;
class SoNode;
class SoPath;
class SoSeparator;
class SoVRMLGroup;
class SoGroup;

typedef void SoDBHeaderCB(void * data, SoInput * in);


class __declspec(dllimport) SoDB {
public:
  static void init(void);
  static void cleanup(void);

  static const char * getVersion(void);
  static SbBool read(SoInput * in, SoPath *& path);
  static SbBool read(SoInput * in, SoBase *& base);
  static SbBool read(SoInput * in, SoNode *& rootnode);
  static SoSeparator * readAll(SoInput * in);
  static SoVRMLGroup * readAllVRML(SoInput * in);
  static SbBool isValidHeader(const char * teststring);
  static SbBool registerHeader(const SbString & headerstring,
                               SbBool isbinary,
                               float ivversion,
                               SoDBHeaderCB * precallback,
                               SoDBHeaderCB * postcallback,
                               void * userdata = 0);
  static SbBool getHeaderData(const SbString & headerstring,
                              SbBool & isbinary,
                              float & ivversion,
                              SoDBHeaderCB *& precallback,
                              SoDBHeaderCB *& postcallback,
                              void *& userdata,
                              SbBool substringok = 0);
  static int getNumHeaders(void);
  static SbString getHeaderString(const int i);
  static SoField * createGlobalField(const SbName & name, SoType type);
  static SoField * getGlobalField(const SbName & name);
  static void renameGlobalField(const SbName & from, const SbName & to);

  static void setRealTimeInterval(const SbTime & interval);
  static const SbTime & getRealTimeInterval(void);
  static void enableRealTimeSensor(SbBool on);

  static SoSensorManager * getSensorManager(void);
  static void setDelaySensorTimeout(const SbTime & t);
  static const SbTime & getDelaySensorTimeout(void);
  static int doSelect(int nfds, void * readfds, void * writefds,
                      void * exceptfds, struct timeval * usertimeout);

  static void addConverter(SoType from, SoType to, SoType converter);
  static SoType getConverter(SoType from, SoType to);

  static SbBool isInitialized(void);

  static void startNotify(void);
  static SbBool isNotifying(void);
  static void endNotify(void);

  typedef SbBool ProgressCallbackType(const SbName & itemid, float fraction,
                                      SbBool interruptible, void * userdata);
  static void addProgressCallback(ProgressCallbackType * func, void * userdata);
  static void removeProgressCallback(ProgressCallbackType * func, void * userdata);

  static SbBool isMultiThread(void);
  static void readlock(void);
  static void readunlock(void);
  static void writelock(void);
  static void writeunlock(void);

private:
  static SoGroup * readAllWrapper(SoInput * in, const SoType & grouptype);
};

#line 112 "c:\\coin3d\\include\\inventor\\sodb.h"
#line 35 "c:\\coin3d\\include\\inventor\\soinput.h"
#line 36 "c:\\coin3d\\include\\inventor\\soinput.h"

class SoBase;
class SbString;
class SbTime;
class SbName;
class SbStringList;
class SoInput_FileInfo;
class SoProto;
class SoField;
class SoFieldContainer;

class __declspec(dllimport) SoInput {
public:
  SoInput(void);
  SoInput(SoInput * dictIn);

  SoProto * findProto(const SbName & name);
  void addProto(SoProto * proto);
  void pushProto(SoProto * proto);
  SoProto * getCurrentProto(void) const;
  void popProto(void);

  void addRoute(const SbName & fromnode, const SbName & fromfield,
                const SbName & tonode, const SbName & tofield);
  SbBool checkISReference(SoFieldContainer * container, const SbName & fieldname, 
                          SbBool & readok);
  
  virtual ~SoInput(void);

  virtual void setFilePointer(FILE * newFP);
  virtual SbBool openFile(const char * fileName, SbBool okIfNotFound = 0);
  virtual SbBool pushFile(const char * fileName);
  virtual void closeFile(void);
  virtual SbBool isValidFile(void);
  virtual SbBool isValidBuffer(void);
  virtual FILE * getCurFile(void) const;
  virtual const char * getCurFileName(void) const;
  virtual void setBuffer(void * bufpointer, size_t bufsize);
          void setStringArray(const char * strings[]);
  virtual size_t getNumBytesRead(void) const;
  virtual SbString getHeader(void);
  virtual float getIVVersion(void);
  virtual SbBool isBinary(void);

  virtual SbBool get(char & c);
  virtual SbBool getASCIIBuffer(char & c);
  virtual SbBool getASCIIFile(char & c);
  virtual SbBool readHex(uint32_t & l);
  virtual SbBool read(char & c);
  virtual SbBool read(char & c, SbBool skip);
  virtual SbBool read(SbString & s);
  virtual SbBool read(SbName & n, SbBool validIdent = 0);
  virtual SbBool read(int & i);
  virtual SbBool read(unsigned int & i);
  virtual SbBool read(short & s);
  virtual SbBool read(unsigned short & s);
  virtual SbBool read(float & f);
  virtual SbBool read(double & d);
  virtual SbBool readBinaryArray(unsigned char * c, int length);
  virtual SbBool readBinaryArray(int32_t * l, int length);
  virtual SbBool readBinaryArray(float * f, int length);
  virtual SbBool readBinaryArray(double * d, int length);
  virtual SbBool eof(void) const;

  SbBool isFileVRML1(void);
  SbBool isFileVRML2(void);
  virtual void resetFilePointer(FILE * fptr);

  virtual void getLocationString(SbString & string) const;
  virtual void putBack(const char c);
  virtual void putBack(const char * str);
  virtual void addReference(const SbName & name, SoBase * base,
                            SbBool addToGlobalDict = 1);
  virtual void removeReference(const SbName & name);
  virtual SoBase * findReference(const SbName & name) const;

  static void addDirectoryFirst(const char * dirName);
  static void addDirectoryLast(const char * dirName);
  static void addEnvDirectoriesFirst(const char * envVarName,
                                     const char * separator = ":\t ");
  static void addEnvDirectoriesLast(const char * envVarName,
                                    const char * separator = ":\t ");
  static void removeDirectory(const char * dirName);
  static void clearDirectories(void);
  static const SbStringList & getDirectories(void);

  static void init(void);

  static SbString getPathname(const char * const filename);
  static SbString getPathname(const SbString & s);
  static SbString getBasename(const char * const filename);
  static SbString getBasename(const SbString & s);

  static SbString searchForFile(const SbString & basename,
                                const SbStringList & directories,
                                const SbStringList & subdirectories);


protected:
  virtual SbBool popFile(void);
  void setIVVersion(float version);
  FILE * findFile(const char * fileName, SbString & fullName);
  void initFile(FILE * newFP, const char * fileName, SbString * fullName,
                SbBool openedHere, SbDict * refDict = (SbDict *) 0);
  SbBool checkHeader(SbBool bValidateBufferHeader = 0);
  SbBool fromBuffer(void) const;
  SbBool skipWhiteSpace(void);
  size_t freeBytesInBuf(void) const;
  SbBool readInteger(int32_t & l);
  SbBool readUnsignedInteger(uint32_t & l);
  SbBool readReal(double & d);
  SbBool readUnsignedIntegerString(char * str);
  int readDigits(char * str);
  int readHexDigits(char * str);
  int readChar(char * str, char charToRead);

  SbBool makeRoomInBuf(size_t nBytes);
  void convertShort(char * from, short * s);
  void convertInt32(char * from, int32_t * l);
  void convertFloat(char * from, float * f);
  void convertDouble(char * from, double * d);
  void convertShortArray(char * from, short * to, int len);
  void convertInt32Array(char * from, int32_t * to, int len);
  void convertFloatArray(char * from, float * to, int len);
  void convertDoubleArray(char * from, double * to, int len);
  SbBool isFileURL(const char * url);
  char * URLToFile(char * out_buf, const char * in_buf);
  SbBool IsURL(const char * c_strng);

  static void setDirectories(SbStringList * dirs);

private:
  friend class SoDB;

  static void clean(void);
  void constructorsCommon(void);

  static void addDirectoryIdx(const int idx, const char * dirName);
  static void addEnvDirectoriesIdx(int startidx, const char * envVarName,
                                   const char * separator);
  static SbStringList * dirsearchlist;

  SbList<SoInput_FileInfo *> filestack;
  SoInput_FileInfo * getTopOfStack(void) const;

  SbDict refdict;
};

#line 185 "c:\\coin3d\\include\\inventor\\soinput.h"
#line 35 "c:\\coin3d\\include\\inventor\\fields\\sosubfield.h"
#line 1 "c:\\coin3d\\include\\inventor\\sooutput.h"


























#line 1 "c:\\coin3d\\include\\inventor\\system\\inttypes.h"


















































































































































































#line 28 "c:\\coin3d\\include\\inventor\\sooutput.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbbasic.h"


























































































#line 29 "c:\\coin3d\\include\\inventor\\sooutput.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbstring.h"












































































































































#line 30 "c:\\coin3d\\include\\inventor\\sooutput.h"


class SbDict;
class SbName;
class SoBase;
class SoOutputP;
class SoProto;
class SoField;
class SoFieldContainer;

typedef void * SoOutputReallocCB(void * ptr, size_t newSize);

class __declspec(dllimport) SoOutput {
public:
  enum Stage { COUNT_REFS, WRITE };
  
  enum Annotations { ADDRESSES = 0x01, REF_COUNTS = 0x02 };

  SoOutput(void);
  SoOutput(SoOutput * dictOut);
  virtual ~SoOutput();

  virtual void setFilePointer(FILE * newFP);
  virtual FILE * getFilePointer(void) const;
  virtual SbBool openFile(const char * const fileName);
  virtual void closeFile(void);

  SbBool setCompression(const SbName & compmethod,
                        const float level = 0.5f);
  static const SbName * getAvailableCompressionMethods(unsigned int & num);

  virtual void setBuffer(void * bufPointer, size_t initSize,
                         SoOutputReallocCB * reallocFunc, int32_t offset = 0);
  virtual SbBool getBuffer(void * & bufPointer, size_t & nBytes) const;
  virtual size_t getBufferSize(void) const;
  virtual void resetBuffer(void);
  virtual void setBinary(const SbBool flag);
  virtual SbBool isBinary(void) const;
  virtual void setHeaderString(const SbString & str);
  virtual void resetHeaderString(void);
  virtual void setFloatPrecision(const int precision);

  void setStage(Stage stage);
  Stage getStage(void) const;

  void incrementIndent(const int levels = 1);
  void decrementIndent(const int levels = 1);

  virtual void write(const char c);
  virtual void write(const char * s);
  virtual void write(const SbString & s);
  virtual void write(const SbName & n);
  virtual void write(const int i);
  virtual void write(const unsigned int i);
  virtual void write(const short s);
  virtual void write(const unsigned short s);
  virtual void write(const float f);
  virtual void write(const double d);
  virtual void writeBinaryArray(const unsigned char * c, const int length);
  virtual void writeBinaryArray(const int32_t * const l, const int length);
  virtual void writeBinaryArray(const float * const f, const int length);
  virtual void writeBinaryArray(const double * const d, const int length);

  virtual void indent(void);
  virtual void reset(void);
  void setCompact(SbBool flag);
  SbBool isCompact(void) const;
  void setAnnotation(uint32_t bits);
  uint32_t getAnnotation(void);

  static SbString getDefaultASCIIHeader(void);
  static SbString getDefaultBinaryHeader(void);

  int addReference(const SoBase * base);
  int findReference(const SoBase * base) const;
  void setReference(const SoBase * base, int refid);

  void addDEFNode(SbName name);
  SbBool lookupDEFNode(SbName name);
  void removeDEFNode(SbName name);

  void pushProto(SoProto * proto);
  SoProto * getCurrentProto(void) const;
  void popProto(void);
  
  void addRoute(SoFieldContainer * from, const SbName & fromfield,
                SoFieldContainer * to, const SbName & tofield);
  void resolveRoutes(void);
  
protected:
  SbBool isToBuffer(void) const;
  size_t bytesInBuf(void) const;
  SbBool makeRoomInBuf(size_t nBytes);
  void convertShort(short s, char * to);
  void convertInt32(int32_t l, char * to);
  void convertFloat(float f, char * to);
  void convertDouble(double d, char * to);
  void convertShortArray(short * from, char * to, int len);
  void convertInt32Array(int32_t * from, char * to, int len);
  void convertFloatArray(float * from, char * to, int len);
  void convertDoubleArray(double * from, char * to, int len);

  static SbString padHeader(const SbString & inString);

  SbBool wroteHeader;

private:
  SoOutputP * pimpl;

  void constructorCommon(void);

  void checkHeader(void);
  void writeBytesWithPadding(const char * const p, const size_t nr);
  
  friend class SoBase; 
  void removeSoBase2IdRef(const SoBase * base);
};

#line 149 "c:\\coin3d\\include\\inventor\\sooutput.h"
#line 36 "c:\\coin3d\\include\\inventor\\fields\\sosubfield.h"
#line 37 "c:\\coin3d\\include\\inventor\\fields\\sosubfield.h"


































































































































































































































   









































































































































































































































#line 498 "c:\\coin3d\\include\\inventor\\fields\\sosubfield.h"
#line 29 "c:\\coin3d\\include\\inventor\\fields\\sosfrotation.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbrotation.h"












































































#line 30 "c:\\coin3d\\include\\inventor\\fields\\sosfrotation.h"

class __declspec(dllimport) SoSFRotation : public SoSField {
  typedef SoSField inherited;

  public: SoSFRotation(void); virtual ~SoSFRotation(); private: static SoType classTypeId; public: static void * createInstance(void); static SoType getClassTypeId(void); virtual SoType getTypeId(void) const; virtual void copyFrom(const SoField & field); const SoSFRotation & operator=(const SoSFRotation & field); virtual SbBool isSame(const SoField & field) const; private: virtual SbBool readValue(SoInput * in); virtual void writeValue(SoOutput * out) const; protected: SbRotation value; public: const SbRotation & getValue(void) const { this->evaluate(); return this->value; } void setValue(const SbRotation & newvalue); const SbRotation & operator=(const SbRotation & newvalue) { this->setValue(newvalue); return this->value; } int operator==(const SoSFRotation & field) const; int operator!=(const SoSFRotation & field) const { return ! operator==(field); };

public:
  static void initClass(void);

  void getValue(SbVec3f & axis, float & angle) const;
  void setValue(const float q0, const float q1, const float q2, const float q3);
  void setValue(const float q[4]);
  void setValue(const SbVec3f & axis, const float angle);
};

#line 46 "c:\\coin3d\\include\\inventor\\fields\\sosfrotation.h"
#line 31 "c:\\coin3d\\include\\inventor\\nodes\\socamera.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosfenum.h"


























#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosfield.h"













































#line 28 "c:\\coin3d\\include\\inventor\\fields\\sosfenum.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosubfield.h"

















































































































































































































































































































































































































































































































#line 29 "c:\\coin3d\\include\\inventor\\fields\\sosfenum.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbstring.h"












































































































































#line 30 "c:\\coin3d\\include\\inventor\\fields\\sosfenum.h"

class __declspec(dllimport) SoSFEnum : public SoSField {
  typedef SoSField inherited;

  public: SoSFEnum(void); virtual ~SoSFEnum(); private: static SoType classTypeId; public: static void * createInstance(void); static SoType getClassTypeId(void); virtual SoType getTypeId(void) const; virtual void copyFrom(const SoField & field); const SoSFEnum & operator=(const SoSFEnum & field); virtual SbBool isSame(const SoField & field) const; private: virtual SbBool readValue(SoInput * in); virtual void writeValue(SoOutput * out) const; protected: int value; public: int getValue(void) const { this->evaluate(); return this->value; } void setValue(int newvalue); int operator=(int newvalue) { this->setValue(newvalue); return this->value; } int operator==(const SoSFEnum & field) const; int operator!=(const SoSFEnum & field) const { return ! operator==(field); };

public:
  static void initClass(void);

  void setValue(const SbName name);
  void setEnums(const int num, const int * vals, const SbName * names);

  int getNumEnums(void) const;
  int getEnum(const int idx, SbName & name) const;

protected:
  virtual SbBool findEnumValue(const SbName & name, int & val);
  virtual SbBool findEnumName(int value, const SbName * & name) const;

  int numEnums;
  int * enumValues;
  SbName * enumNames;
  SbBool legalValuesSet;
};






















#line 77 "c:\\coin3d\\include\\inventor\\fields\\sosfenum.h"
#line 32 "c:\\coin3d\\include\\inventor\\nodes\\socamera.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosfvec3f.h"


























#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosfield.h"













































#line 28 "c:\\coin3d\\include\\inventor\\fields\\sosfvec3f.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosubfield.h"

















































































































































































































































































































































































































































































































#line 29 "c:\\coin3d\\include\\inventor\\fields\\sosfvec3f.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbvec3f.h"






































































































#line 30 "c:\\coin3d\\include\\inventor\\fields\\sosfvec3f.h"

class __declspec(dllimport) SoSFVec3f : public SoSField {
  typedef SoSField inherited;

  public: SoSFVec3f(void); virtual ~SoSFVec3f(); private: static SoType classTypeId; public: static void * createInstance(void); static SoType getClassTypeId(void); virtual SoType getTypeId(void) const; virtual void copyFrom(const SoField & field); const SoSFVec3f & operator=(const SoSFVec3f & field); virtual SbBool isSame(const SoField & field) const; private: virtual SbBool readValue(SoInput * in); virtual void writeValue(SoOutput * out) const; protected: SbVec3f value; public: const SbVec3f & getValue(void) const { this->evaluate(); return this->value; } void setValue(const SbVec3f & newvalue); const SbVec3f & operator=(const SbVec3f & newvalue) { this->setValue(newvalue); return this->value; } int operator==(const SoSFVec3f & field) const; int operator!=(const SoSFVec3f & field) const { return ! operator==(field); };

public:
  static void initClass(void);

  void setValue(const float x, const float y, const float z);
  void setValue(const float xyz[3]);
};

#line 44 "c:\\coin3d\\include\\inventor\\fields\\sosfvec3f.h"
#line 33 "c:\\coin3d\\include\\inventor\\nodes\\socamera.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosffloat.h"


























#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosfield.h"













































#line 28 "c:\\coin3d\\include\\inventor\\fields\\sosffloat.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosubfield.h"

















































































































































































































































































































































































































































































































#line 29 "c:\\coin3d\\include\\inventor\\fields\\sosffloat.h"

class __declspec(dllimport) SoSFFloat : public SoSField {
  typedef SoSField inherited;

  public: SoSFFloat(void); virtual ~SoSFFloat(); private: static SoType classTypeId; public: static void * createInstance(void); static SoType getClassTypeId(void); virtual SoType getTypeId(void) const; virtual void copyFrom(const SoField & field); const SoSFFloat & operator=(const SoSFFloat & field); virtual SbBool isSame(const SoField & field) const; private: virtual SbBool readValue(SoInput * in); virtual void writeValue(SoOutput * out) const; protected: float value; public: float getValue(void) const { this->evaluate(); return this->value; } void setValue(float newvalue); float operator=(float newvalue) { this->setValue(newvalue); return this->value; } int operator==(const SoSFFloat & field) const; int operator!=(const SoSFFloat & field) const { return ! operator==(field); };

public:
  static void initClass(void);
};

#line 40 "c:\\coin3d\\include\\inventor\\fields\\sosffloat.h"
#line 34 "c:\\coin3d\\include\\inventor\\nodes\\socamera.h"

#line 1 "c:\\coin3d\\include\\inventor\\sbvec3f.h"






































































































#line 36 "c:\\coin3d\\include\\inventor\\nodes\\socamera.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbbox3f.h"




























#line 1 "c:\\coin3d\\include\\inventor\\sbvec3f.h"






































































































#line 30 "c:\\coin3d\\include\\inventor\\sbbox3f.h"

class SbMatrix;

class __declspec(dllimport) SbBox3f {
public:
  SbBox3f(void);
  SbBox3f(const float minx, const float miny, const float minz,
          const float maxx, const float maxy, const float maxz);
  SbBox3f(const SbVec3f & min, const SbVec3f & max);
  ~SbBox3f();

  const SbVec3f & getMin(void) const;
  const SbVec3f & getMax(void) const;
  SbVec3f & getMin(void);
  SbVec3f & getMax(void);

  SbVec3f getCenter(void) const;

  void extendBy(const SbVec3f & point);
  void extendBy(const SbBox3f & box);

  SbBool intersect(const SbVec3f & point) const;
  SbBool intersect(const SbBox3f & box) const;

  void setBounds(const float minx, const float miny, const float minz,
                 const float maxx, const float maxy, const float maxz);
  void setBounds(const SbVec3f & min, const SbVec3f & max);
  void getBounds(float & minx, float & miny, float & minz,
                 float & maxx, float & maxy, float & maxz) const;
  void getBounds(SbVec3f & min, SbVec3f & max) const;

  void getOrigin(float & x0, float & y0, float & z0) const;
  void getSize(float & dx, float & dy, float & dz) const;

  void makeEmpty(void);
  SbBool isEmpty(void) const;
  SbBool hasVolume(void) const;

  void getSpan(const SbVec3f & dir, float & dmin, float & dmax) const;
  void transform(const SbMatrix & matrix);
  float getVolume(void) const;

  SbBool outside(const SbMatrix & mvp, int & cullbits) const;
  SbVec3f getClosestPoint(const SbVec3f & point) const;

  friend __declspec(dllimport) int operator ==(const SbBox3f & b1, const SbBox3f & b2);
  friend __declspec(dllimport) int operator !=(const SbBox3f & b1, const SbBox3f & b2);

  void print(FILE * file) const;

private:
  SbVec3f min, max;
};

__declspec(dllimport) int operator ==(const SbBox3f & b1, const SbBox3f & b2);
__declspec(dllimport) int operator !=(const SbBox3f & b1, const SbBox3f & b2);

#line 88 "c:\\coin3d\\include\\inventor\\sbbox3f.h"
#line 37 "c:\\coin3d\\include\\inventor\\nodes\\socamera.h"













class SoPath;

class SoCameraP;

class __declspec(dllimport) SoCamera : public SoNode {
  typedef SoNode inherited;

  public: static SoType getClassTypeId(void); virtual SoType getTypeId(void) const; private: static SoType classTypeId; protected: static const SoFieldData ** getFieldDataPtr(void); virtual const SoFieldData * getFieldData(void) const; private: static void atexit_cleanup(void); static const SoFieldData ** parentFieldData; static SoFieldData * fieldData; static unsigned int classinstances;

public:
  static void initClass(void);

  enum ViewportMapping {
    CROP_VIEWPORT_FILL_FRAME,
    CROP_VIEWPORT_LINE_FRAME,
    CROP_VIEWPORT_NO_FRAME,
    ADJUST_CAMERA,
    LEAVE_ALONE
  };

  SoSFEnum viewportMapping;
  SoSFVec3f position;
  SoSFRotation orientation;
  SoSFFloat aspectRatio;
  SoSFFloat nearDistance;
  SoSFFloat farDistance;
  SoSFFloat focalDistance;

  void pointAt(const SbVec3f & targetpoint);
  void pointAt(const SbVec3f & targetpoint, const SbVec3f & upvector);
  virtual void scaleHeight(float scalefactor) = 0;
  virtual SbViewVolume getViewVolume(float useaspectratio = 0.0f) const = 0;
  void viewAll(SoNode * const sceneroot, const SbViewportRegion & vpregion,
               const float slack = 1.0f);
  void viewAll(SoPath * const path, const SbViewportRegion & vpregion,
               const float slack = 1.0f);
  SbViewportRegion getViewportBounds(const SbViewportRegion & region) const;

  enum StereoMode {
    MONOSCOPIC,
    LEFT_VIEW,
    RIGHT_VIEW
  };

  void setStereoMode(StereoMode mode);
  StereoMode getStereoMode(void) const;

  void setStereoAdjustment(float adjustment);
  float getStereoAdjustment(void) const;
  void setBalanceAdjustment(float adjustment);
  float getBalanceAdjustment(void) const;

  virtual void doAction(SoAction * action);
  virtual void callback(SoCallbackAction * action);
  virtual void GLRender(SoGLRenderAction * action);
  virtual void audioRender(SoAudioRenderAction *action);
  virtual void getBoundingBox(SoGetBoundingBoxAction * action);
  virtual void handleEvent(SoHandleEventAction * action);
  virtual void rayPick(SoRayPickAction * action);
  virtual void getPrimitiveCount(SoGetPrimitiveCountAction * action);

protected:
  SoCamera(void);
  virtual ~SoCamera();

  virtual void viewBoundingBox(const SbBox3f & box, float aspect,
                               float slack) = 0;
  virtual void jitter(int numpasses, int curpass,
                      const SbViewportRegion & vpreg,
                      SbVec3f & jitteramount) const;

private:
  void getView(SoAction * action, SbViewVolume & resultvv,
               SbViewportRegion & resultvp,
               const SbBool considermodelmatrix = 1);

  void drawCroppedFrame(SoGLRenderAction * action,
                        const int viewportmapping,
                        const SbViewportRegion & oldvp,
                        const SbViewportRegion & newvp);

  void lookAt(const SbVec3f & dir, const SbVec3f & up);

  StereoMode stereomode;
  float stereoadjustment;
  float balanceadjustment;
private:
  SoCameraP *pimpl;
  friend class SoCameraP;
};

#line 142 "c:\\coin3d\\include\\inventor\\nodes\\socamera.h"
#line 29 "c:\\coin3d\\include\\inventor\\nodes\\soperspectivecamera.h"

class __declspec(dllimport) SoPerspectiveCamera : public SoCamera {
  typedef SoCamera inherited;

  public: static SoType getClassTypeId(void); virtual SoType getTypeId(void) const; private: static SoType classTypeId; protected: static const SoFieldData ** getFieldDataPtr(void); virtual const SoFieldData * getFieldData(void) const; private: static void atexit_cleanup(void); static const SoFieldData ** parentFieldData; static SoFieldData * fieldData; static unsigned int classinstances; private: static void * createInstance(void);

public:
  static void initClass(void);
  SoPerspectiveCamera(void);

  SoSFFloat heightAngle;

  virtual void scaleHeight(float scalefactor);
  virtual SbViewVolume getViewVolume(float useaspectratio = 0.0f) const;

protected:
  virtual ~SoPerspectiveCamera();

  virtual void viewBoundingBox(const SbBox3f & box, float aspect, float slack);
};

#line 51 "c:\\coin3d\\include\\inventor\\nodes\\soperspectivecamera.h"
#line 20 "h:\\c_projekte\\elansim\\headview.cpp"
#line 1 "c:\\coin3d\\include\\inventor\\nodes\\sonode.h"








































































































































































#line 21 "h:\\c_projekte\\elansim\\headview.cpp"
#line 1 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlgroup.h"


























#line 1 "c:\\coin3d\\include\\inventor\\nodes\\sosubnode.h"

























































































































































































































#line 28 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlgroup.h"
#line 1 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlparent.h"


























#line 1 "c:\\coin3d\\include\\inventor\\nodes\\sogroup.h"


























#line 1 "c:\\coin3d\\include\\inventor\\nodes\\sosubnode.h"

























































































































































































































#line 28 "c:\\coin3d\\include\\inventor\\nodes\\sogroup.h"

class SoGroupP;

class __declspec(dllimport) SoGroup : public SoNode {
  typedef SoNode inherited;

  public: static SoType getClassTypeId(void); virtual SoType getTypeId(void) const; private: static SoType classTypeId; protected: static const SoFieldData ** getFieldDataPtr(void); virtual const SoFieldData * getFieldData(void) const; private: static void atexit_cleanup(void); static const SoFieldData ** parentFieldData; static SoFieldData * fieldData; static unsigned int classinstances; private: static void * createInstance(void);

public:
  static void initClass(void);
  SoGroup(void);

  SoGroup(int nchildren);
 
  virtual void addChild(SoNode * node);
  virtual void insertChild(SoNode * child, int newchildindex);
  virtual SoNode * getChild(int index) const;
  virtual int findChild(const SoNode * node) const;
  virtual int getNumChildren(void) const;
  virtual void removeChild(int childindex);
  virtual void removeChild(SoNode * child);
  virtual void removeAllChildren(void);
  virtual void replaceChild(int index, SoNode * newchild);
  virtual void replaceChild(SoNode * oldchild, SoNode * newchild);

  virtual void doAction(SoAction * action);
  virtual void GLRender(SoGLRenderAction * action);
  virtual void callback(SoCallbackAction * action);
  virtual void getBoundingBox(SoGetBoundingBoxAction * action);
  virtual void getMatrix(SoGetMatrixAction * action);
  virtual void handleEvent(SoHandleEventAction * action);
  virtual void pick(SoPickAction * action);
  virtual void search(SoSearchAction * action);
  virtual void write(SoWriteAction * action);
  virtual void getPrimitiveCount(SoGetPrimitiveCountAction * action);
  virtual void audioRender(SoAudioRenderAction * action);
  virtual SoChildList * getChildren(void) const;

protected:
  virtual ~SoGroup();

  virtual SbBool readInstance(SoInput * in, unsigned short flags);
  virtual SbBool readChildren(SoInput * in);

  virtual void copyContents(const SoFieldContainer * from,
                            SbBool copyconnections);

  SoChildList * children;

private:
  friend class SoUnknownNode; 
  SoGroupP * pimpl;
};

#line 83 "c:\\coin3d\\include\\inventor\\nodes\\sogroup.h"
#line 28 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlparent.h"
#line 1 "c:\\coin3d\\include\\inventor\\nodes\\sosubnode.h"

























































































































































































































#line 29 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlparent.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\somfnode.h"


























#line 1 "c:\\coin3d\\include\\inventor\\fields\\somfield.h"




























































































#line 28 "c:\\coin3d\\include\\inventor\\fields\\somfnode.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosubfield.h"

















































































































































































































































































































































































































































































































#line 29 "c:\\coin3d\\include\\inventor\\fields\\somfnode.h"

class SoNode;

class __declspec(dllimport) SoMFNode : public SoMField {
  typedef SoMField inherited;

  public: SoMFNode(void); virtual ~SoMFNode(); private: static SoType classTypeId; public: static void * createInstance(void); static SoType getClassTypeId(void); virtual SoType getTypeId(void) const; virtual void copyFrom(const SoField & field); const SoMFNode & operator=(const SoMFNode & field); virtual SbBool isSame(const SoField & field) const; private: virtual SbBool read1Value(SoInput * in, int idx); virtual void write1Value(SoOutput * out, int idx) const; protected: virtual void deleteAllValues(void); virtual void copyValue(int to, int from); virtual int fieldSizeof(void) const; virtual void * valuesPtr(void); virtual void setValuesPtr(void * ptr); virtual void allocValues(int num); SoNode * * values; public: SoNode * operator[](const int idx) const { this->evaluate(); return this->values[idx]; } const SoNode * * getValues(const int start) const { this->evaluate(); return (const SoNode * *)(this->values + start); } int find(SoNode * value, SbBool addifnotfound = 0); void setValues(const int start, const int num, const SoNode * * newvals); void set1Value(const int idx, SoNode * value); void setValue(SoNode * value); SoNode * operator=(SoNode * val) { this->setValue(val); return val; } SbBool operator==(const SoMFNode & field) const; SbBool operator!=(const SoMFNode & field) const { return !operator==(field); } SoNode * * startEditing(void) { this->evaluate(); return this->values; } void finishEditing(void) { this->valueChanged(); };

public:
  static void initClass(void);

  virtual void fixCopy(SbBool copyconnections);
  virtual SbBool referencesCopy(void) const;

  void addNode(SoNode * node);
  void insertNode(SoNode * node, int idx);
  SoNode * getNode(int idx) const;
  int findNode(const SoNode * node) const;
  int getNumNodes(void) const;
  void removeNode(int index);
  void removeNode(SoNode * node);
  void removeAllNodes(void);
  void replaceNode(int idx, SoNode * newnode);
  void replaceNode(SoNode * oldnode, SoNode * newnode);
  
  virtual void deleteValues(int start, int num = -1);
  virtual void insertSpace(int start, int num);

private:
  virtual void countWriteRefs(SoOutput * out) const;
};

#line 62 "c:\\coin3d\\include\\inventor\\fields\\somfnode.h"
#line 30 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlparent.h"

class SoVRMLParentP;
class SoSensor;

class __declspec(dllimport) SoVRMLParent : public SoGroup
{
  typedef SoGroup inherited;
  public: static SoType getClassTypeId(void); virtual SoType getTypeId(void) const; private: static SoType classTypeId; protected: static const SoFieldData ** getFieldDataPtr(void); virtual const SoFieldData * getFieldData(void) const; private: static void atexit_cleanup(void); static const SoFieldData ** parentFieldData; static SoFieldData * fieldData; static unsigned int classinstances;

public:
  static void initClass(void);

  SoMFNode children;

  virtual SbBool affectsState(void) const;
  virtual void addChild(SoNode * child);
  virtual void insertChild(SoNode * child, int idx);
  virtual SoNode * getChild(int idx) const;
  virtual int findChild(const SoNode * child) const;
  virtual int getNumChildren(void) const;
  virtual void removeChild(int idx);
  virtual void removeChild(SoNode * child);
  virtual void removeAllChildren(void);
  virtual void replaceChild(int idx, SoNode * child);
  virtual void replaceChild(SoNode * old, SoNode * child);
  virtual SoChildList * getChildren(void) const;

  virtual void doAction(SoAction * action);
  virtual void search(SoSearchAction * action);
  virtual void write(SoWriteAction * action);
  virtual void getPrimitiveCount(SoGetPrimitiveCountAction * action);

  static void updateChildList(const SoNode * const * nodes, const int numnodes,
                              SoChildList & cl);
  static void updateChildList(SoNode * nodewithsfnode,
                              SoChildList & cl);

protected:
  SoVRMLParent(void);
  SoVRMLParent(int approxchildren);
  virtual ~SoVRMLParent();

  SoMFNode addChildren;
  SoMFNode removeChildren;

  virtual void notify(SoNotList * list);
  virtual SbBool readInstance(SoInput * in, unsigned short flags);
  virtual void copyContents(const SoFieldContainer * from, SbBool copyConn);

private:
  static void field_sensor_cb(void * data, SoSensor * sensor);
  void commonConstructor(void);
  void processAddChildren(void);
  void processRemoveChildren(void);
  SoFieldData * makeWriteData(void);
  
  SoVRMLParentP * pimpl;
}; 

#line 90 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlparent.h"
#line 29 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlgroup.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosfenum.h"












































































#line 30 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlgroup.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosfvec3f.h"











































#line 31 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlgroup.h"

class SoState;
class SoVRMLGroupP;

class __declspec(dllimport) SoVRMLGroup : public SoVRMLParent
{
  typedef SoVRMLParent inherited;
  public: static SoType getClassTypeId(void); virtual SoType getTypeId(void) const; private: static SoType classTypeId; protected: static const SoFieldData ** getFieldDataPtr(void); virtual const SoFieldData * getFieldData(void) const; private: static void atexit_cleanup(void); static const SoFieldData ** parentFieldData; static SoFieldData * fieldData; static unsigned int classinstances; private: static void * createInstance(void);

public:
  static void initClass(void);
  SoVRMLGroup(void);
  SoVRMLGroup(int numChildren);

  enum CacheEnabled {
    OFF,
    ON,
    AUTO
  };

  SoSFEnum renderCaching;
  SoSFEnum boundingBoxCaching;
  SoSFEnum renderCulling;
  SoSFEnum pickCulling;
  SoSFVec3f bboxCenter;
  SoSFVec3f bboxSize;

  static void setNumRenderCaches(int num);
  static int getNumRenderCaches(void);

  virtual void doAction(SoAction * action);
  virtual void callback(SoCallbackAction * action);
  virtual void GLRender(SoGLRenderAction * action);
  virtual void getBoundingBox(SoGetBoundingBoxAction * action);
  virtual void getMatrix(SoGetMatrixAction * action);
  virtual void rayPick(SoRayPickAction * action);
  virtual void search(SoSearchAction * action);
  virtual void write(SoWriteAction * action);
  virtual void getPrimitiveCount(SoGetPrimitiveCountAction * action);
  virtual void audioRender(SoAudioRenderAction * action);

  virtual void GLRenderBelowPath(SoGLRenderAction * action);
  virtual void GLRenderInPath(SoGLRenderAction * action);
  virtual void GLRenderOffPath(SoGLRenderAction * action);

  virtual void notify(SoNotList * list);

protected:
  virtual ~SoVRMLGroup();

  virtual SbBool cullTest(SoState * state);

  static int numRenderCaches;

private:
  SoVRMLGroupP * pimpl;

  SbBool cullTestNoPush(SoState * state);
  void commonConstructor(void);

}; 

#line 94 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlgroup.h"
#line 22 "h:\\c_projekte\\elansim\\headview.cpp"
#line 1 "c:\\coin3d\\include\\inventor\\sblinear.h"



























































#line 23 "h:\\c_projekte\\elansim\\headview.cpp"
#line 1 "c:\\coin3d\\include\\inventor\\actions\\sosearchaction.h"


























#line 1 "c:\\coin3d\\include\\inventor\\actions\\soaction.h"











































































































































































#line 28 "c:\\coin3d\\include\\inventor\\actions\\sosearchaction.h"
#line 1 "c:\\coin3d\\include\\inventor\\actions\\sosubaction.h"


























































































































#line 29 "c:\\coin3d\\include\\inventor\\actions\\sosearchaction.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbname.h"


































































#line 30 "c:\\coin3d\\include\\inventor\\actions\\sosearchaction.h"
#line 1 "c:\\coin3d\\include\\inventor\\lists\\sopathlist.h"
















































#line 31 "c:\\coin3d\\include\\inventor\\actions\\sosearchaction.h"

class __declspec(dllimport) SoSearchAction : public SoAction {
  typedef SoAction inherited;

  public: virtual SoType getTypeId(void) const; static SoType getClassTypeId(void); static void addMethod(const SoType type, SoActionMethod method); static void enableElement(const SoType type, const int stackindex); protected: virtual const SoEnabledElementsList & getEnabledElements(void) const; static SoEnabledElementsList * getClassEnabledElements(void); static SoActionMethodList * getClassActionMethods(void); private: static void atexit_cleanup(void); static SoEnabledElementsList * enabledElements; static SoActionMethodList * methods; static SoType classTypeId;

public:
  SoSearchAction(void);
  virtual ~SoSearchAction();

  static void initClass(void);

  enum LookFor { NODE = 1, TYPE = 2, NAME = 4 };
  enum Interest { FIRST, LAST, ALL };

  void setNode(SoNode * const node);
  SoNode * getNode(void) const;
  void setType(const SoType type, const SbBool chkderived = 1);
  SoType getType(SbBool & chkderived) const;
  void setName(const SbName name);
  SbName getName(void) const;
  void setFind(const int what);
  int getFind(void) const;
  void setInterest(const Interest interest);
  Interest getInterest(void) const;
  void setSearchingAll(const SbBool searchall);
  SbBool isSearchingAll(void) const;
  SoPath * getPath(void) const;
  SoPathList & getPaths(void);
  void reset(void);

  void setFound(void);
  SbBool isFound(void) const;
  void addPath(SoPath * const path);

  
  
  static SbBool duringSearchAll;

protected:
  virtual void beginTraversal(SoNode * node);

private:
  int lookfor;
  Interest interest;
  SbBool searchall, chkderived;
  SoNode * node;
  SoType type;
  SbName name;
  SoPath * path;
  SoPathList paths;
};

#line 85 "c:\\coin3d\\include\\inventor\\actions\\sosearchaction.h"
#line 24 "h:\\c_projekte\\elansim\\headview.cpp"
#line 1 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmltransform.h"


























#line 1 "c:\\coin3d\\include\\inventor\\nodes\\sosubnode.h"

























































































































































































































#line 28 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmltransform.h"
#line 1 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlgroup.h"





























































































#line 29 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmltransform.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosfvec3f.h"











































#line 30 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmltransform.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosfrotation.h"













































#line 31 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmltransform.h"

class __declspec(dllimport) SoVRMLTransform : public SoVRMLGroup
{
  typedef SoVRMLGroup inherited;
  public: static SoType getClassTypeId(void); virtual SoType getTypeId(void) const; private: static SoType classTypeId; protected: static const SoFieldData ** getFieldDataPtr(void); virtual const SoFieldData * getFieldData(void) const; private: static void atexit_cleanup(void); static const SoFieldData ** parentFieldData; static SoFieldData * fieldData; static unsigned int classinstances; private: static void * createInstance(void);

public:
  static void initClass(void);
  SoVRMLTransform(void);
  SoVRMLTransform(int children);

  SoSFVec3f translation;
  SoSFRotation rotation;
  SoSFVec3f scale;
  SoSFRotation scaleOrientation;
  SoSFVec3f center;

  void pointAt(const SbVec3f & from, const SbVec3f & to);
  void getScaleSpaceMatrix(SbMatrix & matrix, SbMatrix & inverse) const;
  void getRotationSpaceMatrix(SbMatrix & matrix, SbMatrix & inverse) const;
  void getTranslationSpaceMatrix(SbMatrix & matrix, SbMatrix & inverse) const;

  void multLeft(const SbMatrix & matrix);
  void multRight(const SbMatrix & matrix);

  void combineLeft(SoVRMLTransform * leftnode);
  void combineRight(SoVRMLTransform * rightnode);

  void setMatrix(const SbMatrix & matrix);

  void recenter(const SbVec3f & newcenter);

  virtual void doAction(SoAction * action);
  virtual void callback(SoCallbackAction * action);
  virtual void getBoundingBox(SoGetBoundingBoxAction * action);
  virtual void getMatrix(SoGetMatrixAction * action);
  virtual void rayPick(SoRayPickAction * action);
  virtual void getPrimitiveCount(SoGetPrimitiveCountAction * action);
  virtual void audioRender(SoAudioRenderAction * action);

  virtual void GLRenderBelowPath(SoGLRenderAction * action);
  virtual void GLRenderInPath(SoGLRenderAction * action);

  virtual void notify(SoNotList * list);

protected:
  virtual ~SoVRMLTransform();

private:
  void commonConstructor(void);
  void applyMatrix(SoState * state);
}; 

#line 85 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmltransform.h"
#line 25 "h:\\c_projekte\\elansim\\headview.cpp"
#line 1 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlcylinder.h"


























#line 1 "c:\\coin3d\\include\\inventor\\nodes\\sosubnode.h"

























































































































































































































#line 28 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlcylinder.h"
#line 1 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlgeometry.h"


























#line 1 "c:\\coin3d\\include\\inventor\\nodes\\soshape.h"


























#line 1 "c:\\coin3d\\include\\inventor\\nodes\\sosubnode.h"

























































































































































































































#line 28 "c:\\coin3d\\include\\inventor\\nodes\\soshape.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbmatrix.h"




















































































































#line 29 "c:\\coin3d\\include\\inventor\\nodes\\soshape.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbvec2s.h"
















































































#line 30 "c:\\coin3d\\include\\inventor\\nodes\\soshape.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbbox3f.h"























































































#line 31 "c:\\coin3d\\include\\inventor\\nodes\\soshape.h"

class SoPrimitiveVertex;
class SoDetail;
class SoPickedPoint;
class SoFaceDetail;
class SoState;
class SoTextureCoordinateElement;
class SbVec2f;
class SoMaterialBundle;
class SoBoundingBoxCache;

class __declspec(dllimport) SoShape : public SoNode {
  typedef SoNode inherited;

  public: static SoType getClassTypeId(void); virtual SoType getTypeId(void) const; private: static SoType classTypeId; protected: static const SoFieldData ** getFieldDataPtr(void); virtual const SoFieldData * getFieldData(void) const; private: static void atexit_cleanup(void); static const SoFieldData ** parentFieldData; static SoFieldData * fieldData; static unsigned int classinstances;

public:
  static void initClass(void);

  enum TriangleShape {
    TRIANGLE_STRIP, TRIANGLE_FAN, TRIANGLES, POLYGON,
    
    QUADS, QUAD_STRIP, POINTS, LINES, LINE_STRIP
  };

  virtual SbBool affectsState(void) const;
  virtual void notify(SoNotList * nl);

  virtual void getBoundingBox(SoGetBoundingBoxAction * action);
  virtual void GLRender(SoGLRenderAction * action);
  virtual void rayPick(SoRayPickAction * action);
  virtual void callback(SoCallbackAction * action);
  virtual void computeBBox(SoAction * action, SbBox3f & box,
                           SbVec3f & center) =  0;
  virtual void getPrimitiveCount(SoGetPrimitiveCountAction * action);

  static void getScreenSize(SoState * const state, const SbBox3f & boundingbox,
                            SbVec2s & rectsize);
  static float getDecimatedComplexity(SoState * state, float complexity);
  const SoBoundingBoxCache * getBoundingBoxCache(void) const;
  
protected:
  SoShape(void);
  virtual ~SoShape();

  float getComplexityValue(SoAction * action);
  virtual void generatePrimitives(SoAction * action) =  0;
  virtual SbBool shouldGLRender(SoGLRenderAction * action);
  void beginSolidShape(SoGLRenderAction * action);
  void endSolidShape(SoGLRenderAction * action);
  void GLRenderBoundingBox(SoGLRenderAction * action);
  SbBool shouldPrimitiveCount(SoGetPrimitiveCountAction * action);

  SbBool shouldRayPick(SoRayPickAction * const action);
  void computeObjectSpaceRay(SoRayPickAction * const action);
  void computeObjectSpaceRay(SoRayPickAction * const action,
                             const SbMatrix & matrix);
  virtual SoDetail * createTriangleDetail(SoRayPickAction * action,
                                          const SoPrimitiveVertex * v1,
                                          const SoPrimitiveVertex * v2,
                                          const SoPrimitiveVertex * v3,
                                          SoPickedPoint * pp);
  virtual SoDetail * createLineSegmentDetail(SoRayPickAction * action,
                                             const SoPrimitiveVertex * v1,
                                             const SoPrimitiveVertex * v2,
                                             SoPickedPoint * pp);
  virtual SoDetail * createPointDetail(SoRayPickAction * action,
                                       const SoPrimitiveVertex * v,
                                       SoPickedPoint * pp);

  void invokeTriangleCallbacks(SoAction * const action,
                               const SoPrimitiveVertex * const v1,
                               const SoPrimitiveVertex * const v2,
                               const SoPrimitiveVertex * const v3);
  void invokeLineSegmentCallbacks(SoAction * const action,
                                  const SoPrimitiveVertex * const v1,
                                  const SoPrimitiveVertex * const v2);
  void invokePointCallbacks(SoAction * const action,
                            const SoPrimitiveVertex * const v);
  void beginShape(SoAction * const action, const TriangleShape shapetype,
                  SoDetail * const detail = 0);
  void shapeVertex(const SoPrimitiveVertex * const v);
  void endShape(void);

  void generateVertex(SoPrimitiveVertex * const pv,
                      const SbVec3f & point,
                      const SbBool useTexFunc,
                      const SoTextureCoordinateElement * const tce,
                      const float s,
                      const float t,
                      const SbVec3f & normal);
  void generateVertex(SoPrimitiveVertex * const pv,
                      const SbVec3f & point,
                      const SbBool useTexFunc,
                      const SoTextureCoordinateElement * const tce,
                      const float s,
                      const float t,
                      const float r,
                      const SbVec3f & normal);

private:
  class SoShapeP * pimpl;

  void getBBox(SoAction * action, SbBox3f & box, SbVec3f & center);
  void rayPickBoundingBox(SoRayPickAction * action);
  friend class soshape_primdata;           
  friend class so_generate_prim_private;   
};

#line 141 "c:\\coin3d\\include\\inventor\\nodes\\soshape.h"
#line 28 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlgeometry.h"
#line 1 "c:\\coin3d\\include\\inventor\\nodes\\sosubnode.h"

























































































































































































































#line 29 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlgeometry.h"

class SoVRMLGeometryP;

class __declspec(dllimport) SoVRMLGeometry : public SoShape
{
  typedef SoShape inherited;
  public: static SoType getClassTypeId(void); virtual SoType getTypeId(void) const; private: static SoType classTypeId; protected: static const SoFieldData ** getFieldDataPtr(void); virtual const SoFieldData * getFieldData(void) const; private: static void atexit_cleanup(void); static const SoFieldData ** parentFieldData; static SoFieldData * fieldData; static unsigned int classinstances;

public:
  static void initClass(void);

  virtual void search(SoSearchAction * action);
  virtual void copyContents(const SoFieldContainer * from, SbBool copyConn);

protected:
  SoVRMLGeometry(void);
  virtual ~SoVRMLGeometry();

  void setupShapeHints(SoState * state, const SbBool ccw, const SbBool solid);
  virtual SbBool shouldGLRender(SoGLRenderAction * action);
  virtual SoChildList * getChildren(void) const;
  virtual void notify(SoNotList * list);

private:
  SoVRMLGeometryP * pimpl;
};

#line 57 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlgeometry.h"
#line 29 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlcylinder.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosffloat.h"







































#line 30 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlcylinder.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosfbool.h"


























#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosfield.h"













































#line 28 "c:\\coin3d\\include\\inventor\\fields\\sosfbool.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosubfield.h"

















































































































































































































































































































































































































































































































#line 29 "c:\\coin3d\\include\\inventor\\fields\\sosfbool.h"

class __declspec(dllimport) SoSFBool : public SoSField {
  typedef SoSField inherited;

  public: SoSFBool(void); virtual ~SoSFBool(); private: static SoType classTypeId; public: static void * createInstance(void); static SoType getClassTypeId(void); virtual SoType getTypeId(void) const; virtual void copyFrom(const SoField & field); const SoSFBool & operator=(const SoSFBool & field); virtual SbBool isSame(const SoField & field) const; private: virtual SbBool readValue(SoInput * in); virtual void writeValue(SoOutput * out) const; protected: SbBool value; public: SbBool getValue(void) const { this->evaluate(); return this->value; } void setValue(SbBool newvalue); SbBool operator=(SbBool newvalue) { this->setValue(newvalue); return this->value; } int operator==(const SoSFBool & field) const; int operator!=(const SoSFBool & field) const { return ! operator==(field); };

public:
  static void initClass(void);
};

#line 40 "c:\\coin3d\\include\\inventor\\fields\\sosfbool.h"
#line 31 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlcylinder.h"

class __declspec(dllimport) SoVRMLCylinder : public SoVRMLGeometry
{
  typedef SoVRMLGeometry inherited;
  public: static SoType getClassTypeId(void); virtual SoType getTypeId(void) const; private: static SoType classTypeId; protected: static const SoFieldData ** getFieldDataPtr(void); virtual const SoFieldData * getFieldData(void) const; private: static void atexit_cleanup(void); static const SoFieldData ** parentFieldData; static SoFieldData * fieldData; static unsigned int classinstances; private: static void * createInstance(void);

public:
  static void initClass(void);
  SoVRMLCylinder(void);

  SoSFFloat radius;
  SoSFFloat height;
  SoSFBool side;
  SoSFBool top;
  SoSFBool bottom;

  virtual void GLRender(SoGLRenderAction * action);
  virtual void rayPick(SoRayPickAction * action);
  virtual void getPrimitiveCount(SoGetPrimitiveCountAction * action);

protected:
  virtual ~SoVRMLCylinder();

  virtual void generatePrimitives(SoAction * action);
  virtual void computeBBox(SoAction * action, SbBox3f & box,
                           SbVec3f & center);

}; 

#line 61 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlcylinder.h"
#line 26 "h:\\c_projekte\\elansim\\headview.cpp"
#line 1 "c:\\coin3d\\include\\inventor\\nodes\\sodirectionallight.h"


























#line 1 "c:\\coin3d\\include\\inventor\\nodes\\sosubnode.h"

























































































































































































































#line 28 "c:\\coin3d\\include\\inventor\\nodes\\sodirectionallight.h"
#line 1 "c:\\coin3d\\include\\inventor\\nodes\\solight.h"


























#line 1 "c:\\coin3d\\include\\inventor\\nodes\\sosubnode.h"

























































































































































































































#line 28 "c:\\coin3d\\include\\inventor\\nodes\\solight.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosfbool.h"







































#line 29 "c:\\coin3d\\include\\inventor\\nodes\\solight.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosffloat.h"







































#line 30 "c:\\coin3d\\include\\inventor\\nodes\\solight.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosfcolor.h"


























#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosfield.h"













































#line 28 "c:\\coin3d\\include\\inventor\\fields\\sosfcolor.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosubfield.h"

















































































































































































































































































































































































































































































































#line 29 "c:\\coin3d\\include\\inventor\\fields\\sosfcolor.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbcolor.h"



















































#line 30 "c:\\coin3d\\include\\inventor\\fields\\sosfcolor.h"

class __declspec(dllimport) SoSFColor : public SoSField {
  typedef SoSField inherited;

  public: SoSFColor(void); virtual ~SoSFColor(); private: static SoType classTypeId; public: static void * createInstance(void); static SoType getClassTypeId(void); virtual SoType getTypeId(void) const; virtual void copyFrom(const SoField & field); const SoSFColor & operator=(const SoSFColor & field); virtual SbBool isSame(const SoField & field) const; private: virtual SbBool readValue(SoInput * in); virtual void writeValue(SoOutput * out) const; protected: SbColor value; public: const SbColor & getValue(void) const { this->evaluate(); return this->value; } void setValue(const SbColor & newvalue); const SbColor & operator=(const SbColor & newvalue) { this->setValue(newvalue); return this->value; } int operator==(const SoSFColor & field) const; int operator!=(const SoSFColor & field) const { return ! operator==(field); };

public:
  static void initClass(void);

  void setValue(const SbVec3f & vec);
  void setValue(const float red, const float green, const float blue);
  void setValue(const float rgb[3]);
  void setHSVValue(const float h, const float s, const float v);
  void setHSVValue(const float hsv[3]);
};

#line 47 "c:\\coin3d\\include\\inventor\\fields\\sosfcolor.h"
#line 31 "c:\\coin3d\\include\\inventor\\nodes\\solight.h"

class __declspec(dllimport) SoLight : public SoNode {
  typedef SoNode inherited;

  public: static SoType getClassTypeId(void); virtual SoType getTypeId(void) const; private: static SoType classTypeId; protected: static const SoFieldData ** getFieldDataPtr(void); virtual const SoFieldData * getFieldData(void) const; private: static void atexit_cleanup(void); static const SoFieldData ** parentFieldData; static SoFieldData * fieldData; static unsigned int classinstances;

public:
  static void initClass(void);

  SoSFBool on;
  SoSFFloat intensity;
  SoSFColor color;

  virtual void callback(SoCallbackAction * action);

protected:
  SoLight(void);
  virtual ~SoLight();
};

#line 52 "c:\\coin3d\\include\\inventor\\nodes\\solight.h"
#line 29 "c:\\coin3d\\include\\inventor\\nodes\\sodirectionallight.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosfvec3f.h"











































#line 30 "c:\\coin3d\\include\\inventor\\nodes\\sodirectionallight.h"

class __declspec(dllimport) SoDirectionalLight : public SoLight {
  typedef SoLight inherited;

  public: static SoType getClassTypeId(void); virtual SoType getTypeId(void) const; private: static SoType classTypeId; protected: static const SoFieldData ** getFieldDataPtr(void); virtual const SoFieldData * getFieldData(void) const; private: static void atexit_cleanup(void); static const SoFieldData ** parentFieldData; static SoFieldData * fieldData; static unsigned int classinstances; private: static void * createInstance(void);

public:
  static void initClass(void);
  SoDirectionalLight(void);

  SoSFVec3f direction;

  virtual void GLRender(SoGLRenderAction * action);

protected:
  virtual ~SoDirectionalLight();
};

#line 49 "c:\\coin3d\\include\\inventor\\nodes\\sodirectionallight.h"
#line 27 "h:\\c_projekte\\elansim\\headview.cpp"
#line 1 "c:\\coin3d\\include\\inventor\\sbviewportregion.h"









































































#line 28 "h:\\c_projekte\\elansim\\headview.cpp"
#line 1 "c:\\coin3d\\include\\inventor\\nodes\\socamera.h"













































































































































#line 29 "h:\\c_projekte\\elansim\\headview.cpp"
#line 1 "c:\\coin3d\\include\\inventor\\sbvec3f.h"






































































































#line 30 "h:\\c_projekte\\elansim\\headview.cpp"
#line 1 "c:\\coin3d\\include\\inventor\\sbrotation.h"












































































#line 31 "h:\\c_projekte\\elansim\\headview.cpp"
#line 1 "c:\\coin3d\\include\\inventor\\sbmatrix.h"




















































































































#line 32 "h:\\c_projekte\\elansim\\headview.cpp"
#line 1 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlcolor.h"


























#line 1 "c:\\coin3d\\include\\inventor\\nodes\\sosubnode.h"

























































































































































































































#line 28 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlcolor.h"
#line 1 "c:\\coin3d\\include\\inventor\\nodes\\sonode.h"








































































































































































#line 29 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlcolor.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\somfcolor.h"


























#line 1 "c:\\coin3d\\include\\inventor\\fields\\somfield.h"




























































































#line 28 "c:\\coin3d\\include\\inventor\\fields\\somfcolor.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosubfield.h"

















































































































































































































































































































































































































































































































#line 29 "c:\\coin3d\\include\\inventor\\fields\\somfcolor.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbcolor.h"



















































#line 30 "c:\\coin3d\\include\\inventor\\fields\\somfcolor.h"

class __declspec(dllimport) SoMFColor : public SoMField {
    typedef SoMField inherited;

  public: SoMFColor(void); virtual ~SoMFColor(); private: static SoType classTypeId; public: static void * createInstance(void); static SoType getClassTypeId(void); virtual SoType getTypeId(void) const; virtual void copyFrom(const SoField & field); const SoMFColor & operator=(const SoMFColor & field); virtual SbBool isSame(const SoField & field) const; private: virtual SbBool read1Value(SoInput * in, int idx); virtual void write1Value(SoOutput * out, int idx) const; protected: virtual void deleteAllValues(void); virtual void copyValue(int to, int from); virtual int fieldSizeof(void) const; virtual void * valuesPtr(void); virtual void setValuesPtr(void * ptr); virtual void allocValues(int num); SbColor * values; public: const SbColor & operator[](const int idx) const { this->evaluate(); return this->values[idx]; } const SbColor * getValues(const int start) const { this->evaluate(); return (const SbColor *)(this->values + start); } int find(const SbColor & value, SbBool addifnotfound = 0); void setValues(const int start, const int num, const SbColor * newvals); void set1Value(const int idx, const SbColor & value); void setValue(const SbColor & value); const SbColor & operator=(const SbColor & val) { this->setValue(val); return val; } SbBool operator==(const SoMFColor & field) const; SbBool operator!=(const SoMFColor & field) const { return !operator==(field); } SbColor * startEditing(void) { this->evaluate(); return this->values; } void finishEditing(void) { this->valueChanged(); };

  void setValuesPointer(const int num, const float * userdata); void setValuesPointer(const int num, float * userdata);
  void setValuesPointer(const int num, const SbColor * userdata); void setValuesPointer(const int num, SbColor * userdata);

public:
  static void initClass(void);

  void setValues(const int start, const int num, const float rgb[][3]);
  void setHSVValues(const int start, const int num, const float hsv[][3]);

  void setValue(const SbVec3f & vec);
  void setValue(const float r, const float g, const float b);
  void setValue(const float rgb[3]);

  void setHSVValue(const float h, const float s, const float v);
  void setHSVValue(const float hsv[3]);

  void set1Value(const int idx, const SbVec3f & vec);
  void set1Value(const int idx, const float r, const float g, const float b);
  void set1Value(const int idx, const float rgb[3]);

  void set1HSVValue(const int idx, const float h, const float s, const float v);
  void set1HSVValue(const int idx, const float hsv[3]);
};

#line 61 "c:\\coin3d\\include\\inventor\\fields\\somfcolor.h"
#line 30 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlcolor.h"

class SoVRMLColorP;

class __declspec(dllimport) SoVRMLColor : public SoNode
{
  typedef SoNode inherited;
  public: static SoType getClassTypeId(void); virtual SoType getTypeId(void) const; private: static SoType classTypeId; protected: static const SoFieldData ** getFieldDataPtr(void); virtual const SoFieldData * getFieldData(void) const; private: static void atexit_cleanup(void); static const SoFieldData ** parentFieldData; static SoFieldData * fieldData; static unsigned int classinstances; private: static void * createInstance(void);

public:
  static void initClass(void);
  SoVRMLColor(void);

  SoMFColor color;

  virtual void doAction(SoAction * action);
  virtual void GLRender(SoGLRenderAction * action);
  virtual void callback(SoCallbackAction * action);

protected:
  virtual ~SoVRMLColor();

private:
  SoVRMLColorP * pimpl;
}; 

#line 56 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlcolor.h"
#line 33 "h:\\c_projekte\\elansim\\headview.cpp"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\somfcolor.h"




























































#line 34 "h:\\c_projekte\\elansim\\headview.cpp"
#line 1 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlindexedfaceset.h"


























#line 1 "c:\\coin3d\\include\\inventor\\nodes\\sosubnode.h"

























































































































































































































#line 28 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlindexedfaceset.h"
#line 1 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlindexedshape.h"


























#line 1 "c:\\coin3d\\include\\inventor\\nodes\\sosubnode.h"

























































































































































































































#line 28 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlindexedshape.h"
#line 1 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlvertexshape.h"


























#line 1 "c:\\coin3d\\include\\inventor\\nodes\\sosubnode.h"

























































































































































































































#line 28 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlvertexshape.h"
#line 1 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlgeometry.h"
























































#line 29 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlvertexshape.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosfnode.h"































#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosfield.h"













































#line 33 "c:\\coin3d\\include\\inventor\\fields\\sosfnode.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosubfield.h"

















































































































































































































































































































































































































































































































#line 34 "c:\\coin3d\\include\\inventor\\fields\\sosfnode.h"

class SoNode;


class __declspec(dllimport) SoSFNode : public SoSField {
  typedef SoSField inherited;

  public: SoSFNode(void); virtual ~SoSFNode(); private: static SoType classTypeId; public: static void * createInstance(void); static SoType getClassTypeId(void); virtual SoType getTypeId(void) const; virtual void copyFrom(const SoField & field); const SoSFNode & operator=(const SoSFNode & field); virtual SbBool isSame(const SoField & field) const; private: virtual SbBool readValue(SoInput * in); virtual void writeValue(SoOutput * out) const; protected: SoNode * value; public: SoNode * getValue(void) const { this->evaluate(); return this->value; } void setValue(SoNode * newvalue); SoNode * operator=(SoNode * newvalue) { this->setValue(newvalue); return this->value; } int operator==(const SoSFNode & field) const; int operator!=(const SoSFNode & field) const { return ! operator==(field); };

public:
  static void initClass(void);

  virtual void fixCopy(SbBool copyconnections);
  virtual SbBool referencesCopy(void) const;

private:
  virtual void countWriteRefs(SoOutput * out) const;

  
  friend class SoMFNode;
};

#line 57 "c:\\coin3d\\include\\inventor\\fields\\sosfnode.h"

#line 30 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlvertexshape.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosfbool.h"







































#line 31 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlvertexshape.h"
#line 1 "c:\\coin3d\\include\\inventor\\elements\\somaterialbindingelement.h"


























#line 1 "c:\\coin3d\\include\\inventor\\elements\\soint32element.h"


























#line 1 "c:\\coin3d\\include\\inventor\\elements\\sosubelement.h"


























#line 1 "c:\\coin3d\\include\\inventor\\sbbasic.h"


























































































#line 28 "c:\\coin3d\\include\\inventor\\elements\\sosubelement.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbname.h"


































































#line 29 "c:\\coin3d\\include\\inventor\\elements\\sosubelement.h"
#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\assert.h"















#line 17 "c:\\programme\\microsoft visual studio\\vc98\\include\\assert.h"



















#line 37 "c:\\programme\\microsoft visual studio\\vc98\\include\\assert.h"




















extern "C" {
#line 59 "c:\\programme\\microsoft visual studio\\vc98\\include\\assert.h"

__declspec(dllimport) void __cdecl _assert(void *, void *, unsigned);


}
#line 65 "c:\\programme\\microsoft visual studio\\vc98\\include\\assert.h"



#line 69 "c:\\programme\\microsoft visual studio\\vc98\\include\\assert.h"
#line 30 "c:\\coin3d\\include\\inventor\\elements\\sosubelement.h"

#line 1 "c:\\coin3d\\include\\inventor\\elements\\soelement.h"


























#line 1 "c:\\coin3d\\include\\inventor\\sbbasic.h"


























































































#line 28 "c:\\coin3d\\include\\inventor\\elements\\soelement.h"
#line 1 "c:\\coin3d\\include\\inventor\\sotype.h"















































































































































#line 29 "c:\\coin3d\\include\\inventor\\elements\\soelement.h"
#line 1 "c:\\coin3d\\include\\inventor\\misc\\sostate.h"


























#line 1 "c:\\coin3d\\include\\inventor\\sbbasic.h"


























































































#line 28 "c:\\coin3d\\include\\inventor\\misc\\sostate.h"

#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\assert.h"















#line 17 "c:\\programme\\microsoft visual studio\\vc98\\include\\assert.h"



















#line 37 "c:\\programme\\microsoft visual studio\\vc98\\include\\assert.h"




















extern "C" {
#line 59 "c:\\programme\\microsoft visual studio\\vc98\\include\\assert.h"

__declspec(dllimport) void __cdecl _assert(void *, void *, unsigned);


}
#line 65 "c:\\programme\\microsoft visual studio\\vc98\\include\\assert.h"



#line 69 "c:\\programme\\microsoft visual studio\\vc98\\include\\assert.h"
#line 30 "c:\\coin3d\\include\\inventor\\misc\\sostate.h"

class SoAction;
class SoTypeList;
class SoElement;

class __declspec(dllimport) SoState {
public:
  SoState(SoAction * action,
          const SoTypeList & enabledelements);
  ~SoState(void);

  SoAction * getAction(void) const;

  SoElement * getElement(const int stackindex);
  const SoElement * getConstElement(const int stackindex) const;

  void push(void);
  void pop(void);

  void print(FILE * const file = (&_iob[1])) const;

  SbBool isElementEnabled(const int stackindex) const;

  int getDepth(void) const;

  void setCacheOpen(const SbBool flag);
  SbBool isCacheOpen(void) const;

  SoElement * getElementNoPush(const int stackindex) const;

private:
  SoElement ** stack;
  int numstacks;
  SbBool cacheopen;
  class SoStateP * pimpl;  
};



inline SbBool
SoState::isElementEnabled(const int stackindex) const
{
  return (stackindex < this->numstacks) && (this->stack[stackindex] != 0);
}

inline const SoElement *
SoState::getConstElement(const int stackindex) const
{
  (void)( (this->isElementEnabled(stackindex)) || (_assert("this->isElementEnabled(stackindex)", "c:\\coin3d\\include\\inventor\\misc\\sostate.h", 78), 0) );
  return this->stack[stackindex];
}

inline SbBool 
SoState::isCacheOpen(void) const
{
  return this->cacheopen;
}

inline SoElement *
SoState::getElementNoPush(const int stackindex) const
{
  (void)( (this->isElementEnabled(stackindex)) || (_assert("this->isElementEnabled(stackindex)", "c:\\coin3d\\include\\inventor\\misc\\sostate.h", 91), 0) );
  return this->stack[stackindex];
}


#line 97 "c:\\coin3d\\include\\inventor\\misc\\sostate.h"
#line 30 "c:\\coin3d\\include\\inventor\\elements\\soelement.h"


class SoNode;

class __declspec(dllimport) SoElement {
public:
  static void initClass(void);

  static SoType getClassTypeId(void);
  static int getClassStackIndex(void);
  const SoType getTypeId(void) const;
  int getStackIndex(void) const;

  virtual void init(SoState * state);

  virtual void push(SoState * state);
  virtual void pop(SoState * state, const SoElement * prevTopElement);

  virtual SbBool matches(const SoElement * element) const = 0;
  virtual SoElement * copyMatchInfo(void) const = 0;

  static void initElements(void); 

  static int getNumStackIndices(void);
  static SoType getIdFromStackIndex(const int stackIndex);

  void setDepth(const int depth);

  int getDepth(void) const;

  virtual void print(FILE * file = (&_iob[1])) const;
  virtual ~SoElement();

protected:
  SoElement(void);
  static int classStackIndex;

  static SoElement * getElement(SoState * const state, const int stackIndex);
  static const SoElement * getConstElement(SoState * const state, const int stackIndex);
  
  void capture(SoState * const state) const;

  virtual void captureThis(SoState * state) const;

  void setTypeId(const SoType typeId);
  void setStackIndex(const int index);

  SoType typeId;
  int stackIndex;

  static int createStackIndex(const SoType id);
  static SoTypeList * stackToType;

  int depth;

  SoElement * getNextInStack(void) const;
  SoElement * getNextFree(void) const;

private:

  static SoType classTypeId;

  friend class SoState; 
  static void cleanup(void);
  SoElement * nextup;
  SoElement * nextdown;
};



inline SoElement *
SoElement::getElement(SoState * const state,
                      const int stackIndex)
{
  return state->getElement(stackIndex);
}

inline void 
SoElement::capture(SoState * const state) const
{
  if (state->isCacheOpen()) this->captureThis(state);
}

inline const SoElement *
SoElement::getConstElement(SoState * const state,
                           const int stackIndex)
{
  const SoElement * element = state->getConstElement(stackIndex);
  element->capture(state);
  return element;
}

#line 123 "c:\\coin3d\\include\\inventor\\elements\\soelement.h"
#line 32 "c:\\coin3d\\include\\inventor\\elements\\sosubelement.h"















































































#line 112 "c:\\coin3d\\include\\inventor\\elements\\sosubelement.h"
#line 28 "c:\\coin3d\\include\\inventor\\elements\\soint32element.h"
#line 1 "c:\\coin3d\\include\\inventor\\system\\inttypes.h"


















































































































































































#line 29 "c:\\coin3d\\include\\inventor\\elements\\soint32element.h"

class __declspec(dllimport) SoInt32Element : public SoElement {
  typedef SoElement inherited;

  public: static SoType getClassTypeId(void); static int getClassStackIndex(void); protected: SoInt32Element(void); private: static int classStackIndex; static SoType classTypeId;
public:
  static void initClass(void);
protected:
  virtual ~SoInt32Element();

public: 
  virtual void init(SoState * state);

  virtual SbBool matches(const SoElement * element) const;
  virtual SoElement * copyMatchInfo(void) const;

  virtual void print(FILE * file) const;

  static  void set(const int index, SoState * const state,
                    SoNode * const node, const int32_t value);
  static  void set(const int index, SoState * const state,
                    const int32_t value);
  static  int32_t get(const int index, SoState * const state);
  virtual void setElt(int32_t value);

protected:
  int32_t data;

};

#line 60 "c:\\coin3d\\include\\inventor\\elements\\soint32element.h"
#line 28 "c:\\coin3d\\include\\inventor\\elements\\somaterialbindingelement.h"

class __declspec(dllimport) SoMaterialBindingElement : public SoInt32Element {
  typedef SoInt32Element inherited;

  public: static SoType getClassTypeId(void); static int getClassStackIndex(void); protected: SoMaterialBindingElement(void); private: static int classStackIndex; static SoType classTypeId; public: static void * createInstance(void);
public:
  static void initClass(void);
protected:
  virtual ~SoMaterialBindingElement();

public:

  enum Binding {
    OVERALL = 2,
    PER_PART = 3,
    PER_PART_INDEXED = 4,
    PER_FACE = 5,
    PER_FACE_INDEXED = 6,
    PER_VERTEX = 7,
    PER_VERTEX_INDEXED = 8,
    DEFAULT = OVERALL,
    NONE = OVERALL
  }; 

  virtual void init(SoState * state);

  static  void set(SoState * const state, SoNode * const node,
                   const Binding binding);
  static  void set(SoState * const state, const Binding binding);
  static  Binding get(SoState * const state);
  static  Binding getDefault();

};

#line 63 "c:\\coin3d\\include\\inventor\\elements\\somaterialbindingelement.h"
#line 32 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlvertexshape.h"

class SoNormalCache;
class SoNormalBundle;
class SoState;
class SoCoordinateElement;
class SoVRMLVertexShapeP;

class __declspec(dllimport) SoVRMLVertexShape : public SoVRMLGeometry
{
  typedef SoVRMLGeometry inherited;
  public: static SoType getClassTypeId(void); virtual SoType getTypeId(void) const; private: static SoType classTypeId; protected: static const SoFieldData ** getFieldDataPtr(void); virtual const SoFieldData * getFieldData(void) const; private: static void atexit_cleanup(void); static const SoFieldData ** parentFieldData; static SoFieldData * fieldData; static unsigned int classinstances;

public:
  static void initClass(void);

  SoSFNode coord;
  SoSFNode texCoord;
  SoSFNode normal;
  SoSFNode color;
  SoSFBool colorPerVertex;
  SoSFBool normalPerVertex;

  enum Binding {
    OVERALL             = SoMaterialBindingElement::OVERALL,
    PER_PART            = SoMaterialBindingElement::PER_PART,
    PER_PART_INDEXED    = SoMaterialBindingElement::PER_PART_INDEXED,
    PER_FACE            = SoMaterialBindingElement::PER_FACE,
    PER_FACE_INDEXED    = SoMaterialBindingElement::PER_FACE_INDEXED,
    PER_VERTEX          = SoMaterialBindingElement::PER_VERTEX,
    PER_VERTEX_INDEXED  = SoMaterialBindingElement::PER_VERTEX_INDEXED
  };

  virtual SbBool generateDefaultNormals(SoState * s, SoNormalBundle * nb);
  virtual SbBool generateDefaultNormals(SoState * s, SoNormalCache * nc);

  virtual void doAction(SoAction * action);
  virtual void GLRender(SoGLRenderAction * action);
  virtual void getBoundingBox(SoGetBoundingBoxAction * action);
  virtual void callback(SoCallbackAction * action);
  virtual void pick(SoPickAction * action);

  virtual void notify(SoNotList * list);

protected:
  SoVRMLVertexShape(void);
  virtual ~SoVRMLVertexShape();

  virtual SbBool shouldGLRender(SoGLRenderAction * action);

  void setNormalCache(SoState * s, int numNormals, SbVec3f * normals);
  SoNormalCache * getNormalCache(void) const;

  SoNormalCache * generateAndReadLockNormalCache(SoState * const state);
  void getVertexData(SoState * state,
                     const SoCoordinateElement *& coords,
                     const SbVec3f *& normals,
                     const SbBool neednormals);

  void readLockNormalCache(void);
  void readUnlockNormalCache(void);

private:

  void writeLockNormalCache(void);
  void writeUnlockNormalCache(void);
  
  SoVRMLVertexShapeP * pimpl;
}; 

#line 102 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlvertexshape.h"
#line 29 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlindexedshape.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\somfint32.h"


























#line 1 "c:\\coin3d\\include\\inventor\\fields\\somfield.h"




























































































#line 28 "c:\\coin3d\\include\\inventor\\fields\\somfint32.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosubfield.h"

















































































































































































































































































































































































































































































































#line 29 "c:\\coin3d\\include\\inventor\\fields\\somfint32.h"

class __declspec(dllimport) SoMFInt32 : public SoMField {
  typedef SoMField inherited;

  public: SoMFInt32(void); virtual ~SoMFInt32(); private: static SoType classTypeId; public: static void * createInstance(void); static SoType getClassTypeId(void); virtual SoType getTypeId(void) const; virtual void copyFrom(const SoField & field); const SoMFInt32 & operator=(const SoMFInt32 & field); virtual SbBool isSame(const SoField & field) const; private: virtual SbBool read1Value(SoInput * in, int idx); virtual void write1Value(SoOutput * out, int idx) const; protected: virtual void deleteAllValues(void); virtual void copyValue(int to, int from); virtual int fieldSizeof(void) const; virtual void * valuesPtr(void); virtual void setValuesPtr(void * ptr); virtual void allocValues(int num); int32_t * values; public: int32_t operator[](const int idx) const { this->evaluate(); return this->values[idx]; } const int32_t * getValues(const int start) const { this->evaluate(); return (const int32_t *)(this->values + start); } int find(int32_t value, SbBool addifnotfound = 0); void setValues(const int start, const int num, const int32_t * newvals); void set1Value(const int idx, int32_t value); void setValue(int32_t value); int32_t operator=(int32_t val) { this->setValue(val); return val; } SbBool operator==(const SoMFInt32 & field) const; SbBool operator!=(const SoMFInt32 & field) const { return !operator==(field); } int32_t * startEditing(void) { this->evaluate(); return this->values; } void finishEditing(void) { this->valueChanged(); };

  void setValuesPointer(const int num, const int32_t * userdata); void setValuesPointer(const int num, int32_t * userdata);

public:
  static void initClass(void);

private:
  virtual int getNumValuesPerLine(void) const;
};

#line 45 "c:\\coin3d\\include\\inventor\\fields\\somfint32.h"
#line 30 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlindexedshape.h"

class __declspec(dllimport) SoVRMLIndexedShape : public SoVRMLVertexShape
{
  typedef SoVRMLVertexShape inherited;
  public: static SoType getClassTypeId(void); virtual SoType getTypeId(void) const; private: static SoType classTypeId; protected: static const SoFieldData ** getFieldDataPtr(void); virtual const SoFieldData * getFieldData(void) const; private: static void atexit_cleanup(void); static const SoFieldData ** parentFieldData; static SoFieldData * fieldData; static unsigned int classinstances;

public:
  static void initClass(void);

  SoMFInt32 coordIndex;
  SoMFInt32 colorIndex;
  SoMFInt32 normalIndex;
  SoMFInt32 texCoordIndex;

protected:
  SoVRMLIndexedShape(void);
  virtual ~SoVRMLIndexedShape();

  virtual void notify(SoNotList * list);
  virtual void computeBBox(SoAction * action,
                           SbBox3f & box, SbVec3f & center);

  SbBool getVertexData(SoState * state,
                       const SoCoordinateElement *& coords,
                       const SbVec3f *& normals,
                       const int32_t *& cindices,
                       const int32_t *& nindices,
                       const int32_t *& tindices,
                       const int32_t *& mindices,
                       int & numcindices,
                       const SbBool neednormals,
                       SbBool & normalcacheused);

};

#line 66 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlindexedshape.h"
#line 29 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlindexedfaceset.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosfbool.h"







































#line 30 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlindexedfaceset.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosffloat.h"







































#line 31 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlindexedfaceset.h"




class SoVRMLIndexedFaceSetP;

class __declspec(dllimport) SoVRMLIndexedFaceSet : public SoVRMLIndexedShape
{
  typedef SoVRMLIndexedShape inherited;
  public: static SoType getClassTypeId(void); virtual SoType getTypeId(void) const; private: static SoType classTypeId; protected: static const SoFieldData ** getFieldDataPtr(void); virtual const SoFieldData * getFieldData(void) const; private: static void atexit_cleanup(void); static const SoFieldData ** parentFieldData; static SoFieldData * fieldData; static unsigned int classinstances; private: static void * createInstance(void);

public:
  static void initClass(void);
  SoVRMLIndexedFaceSet(void);

  SoSFBool ccw;
  SoSFBool solid;
  SoSFBool convex;
  SoSFFloat creaseAngle;

  virtual void GLRender( SoGLRenderAction * action );
  virtual void getPrimitiveCount( SoGetPrimitiveCountAction * action );

  virtual SbBool generateDefaultNormals(SoState * s, SoNormalBundle * nb );
  virtual SbBool generateDefaultNormals(SoState * state, SoNormalCache * nc);

protected:
  virtual ~SoVRMLIndexedFaceSet();

  virtual void generatePrimitives( SoAction * action );


private:

  enum Binding {
    OVERALL,
    NONE = OVERALL,
    PER_FACE,
    PER_FACE_INDEXED,
    PER_VERTEX,
    PER_VERTEX_INDEXED
  };

  Binding findMaterialBinding(SoState * state) const;
  Binding findNormalBinding(SoState * state) const;

  virtual void notify(SoNotList * list);
  
  SbBool useConvexCache(SoAction * action, 
                        const SbVec3f * normals, 
                        const int32_t * nindices, 
                        const SbBool normalsfromcache);
  
  SoVRMLIndexedFaceSetP * pimpl;
};

#line 88 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlindexedfaceset.h"
#line 35 "h:\\c_projekte\\elansim\\headview.cpp"
#line 1 "c:\\coin3d\\include\\inventor\\misc\\sochildlist.h"


























#line 1 "c:\\coin3d\\include\\inventor\\lists\\sonodelist.h"













































#line 28 "c:\\coin3d\\include\\inventor\\misc\\sochildlist.h"
#line 1 "c:\\coin3d\\include\\inventor\\lists\\sblist.h"





































































































































































































































#line 29 "c:\\coin3d\\include\\inventor\\misc\\sochildlist.h"

class SoPath;
class SoAction;

class __declspec(dllimport) SoChildList : public SoNodeList {
  typedef SoNodeList inherited;

public:
  SoChildList(SoNode * const parent);
  SoChildList(SoNode * const parent, const int size);
  SoChildList(SoNode * const parent, const SoChildList & cl);
  ~SoChildList();

  void append(SoNode * const node);
  void insert(SoNode * const ptr, const int addbefore);
  void remove(const int index);
  void truncate(const int length);
  void copy(const SoChildList & cl);
  void set(const int index, SoNode * const node);

  void traverseInPath(SoAction * const action, const int numindices,
                      const int * indices);
  void traverse(SoAction * const action);
  void traverse(SoAction * const action, const int index);
  void traverse(SoAction * const action, SoNode * node);
  void traverse(SoAction * const action, const int first, const int last);
  
public:
  void addPathAuditor(SoPath * const path);
  void removePathAuditor(SoPath * const path);

private:
  SoNode * parent;
  SbList<SoPath *> auditors;
};

#line 66 "c:\\coin3d\\include\\inventor\\misc\\sochildlist.h"
#line 36 "h:\\c_projekte\\elansim\\headview.cpp"
#line 1 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlshape.h"


























#line 1 "c:\\coin3d\\include\\inventor\\nodes\\sosubnode.h"

























































































































































































































#line 28 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlshape.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosfnode.h"

























































#line 29 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlshape.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosfenum.h"












































































#line 30 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlshape.h"

class SoVRMLShapeP;

class __declspec(dllimport) SoVRMLShape : public SoNode
{
  typedef SoNode inherited;
  public: static SoType getClassTypeId(void); virtual SoType getTypeId(void) const; private: static SoType classTypeId; protected: static const SoFieldData ** getFieldDataPtr(void); virtual const SoFieldData * getFieldData(void) const; private: static void atexit_cleanup(void); static const SoFieldData ** parentFieldData; static SoFieldData * fieldData; static unsigned int classinstances; private: static void * createInstance(void);

public:
  static void initClass(void);
  SoVRMLShape(void);

  enum CacheEnabled {
    OFF,
    ON,
    AUTO
  };

  SoSFNode appearance;
  SoSFNode geometry;
  SoSFEnum renderCaching;
  SoSFEnum boundingBoxCaching;

  static void setNumRenderCaches(int num);
  static int getNumRenderCaches(void);

  virtual SbBool affectsState(void) const;

  virtual void doAction(SoAction * action);
  virtual void callback(SoCallbackAction * action);
  virtual void GLRender(SoGLRenderAction * action);
  virtual void getBoundingBox(SoGetBoundingBoxAction * action);
  virtual void rayPick(SoRayPickAction * action);
  virtual void search(SoSearchAction * action);
  virtual void write(SoWriteAction * action);
  virtual void getPrimitiveCount(SoGetPrimitiveCountAction * action);

  virtual SoChildList * getChildren(void) const;

  virtual void notify(SoNotList * list);
  virtual void copyContents(const SoFieldContainer * from, SbBool copyConn);

protected:
  virtual ~SoVRMLShape();

private:
  static int numrendercaches;
  SoVRMLShapeP * pimpl;

}; 

#line 82 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlshape.h"
#line 37 "h:\\c_projekte\\elansim\\headview.cpp"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\somfvec3f.h"


























#line 1 "c:\\coin3d\\include\\inventor\\fields\\somfield.h"




























































































#line 28 "c:\\coin3d\\include\\inventor\\fields\\somfvec3f.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosubfield.h"

















































































































































































































































































































































































































































































































#line 29 "c:\\coin3d\\include\\inventor\\fields\\somfvec3f.h"
#line 1 "c:\\coin3d\\include\\inventor\\sbvec3f.h"






































































































#line 30 "c:\\coin3d\\include\\inventor\\fields\\somfvec3f.h"

class __declspec(dllimport) SoMFVec3f : public SoMField {
  typedef SoMField inherited;

  public: SoMFVec3f(void); virtual ~SoMFVec3f(); private: static SoType classTypeId; public: static void * createInstance(void); static SoType getClassTypeId(void); virtual SoType getTypeId(void) const; virtual void copyFrom(const SoField & field); const SoMFVec3f & operator=(const SoMFVec3f & field); virtual SbBool isSame(const SoField & field) const; private: virtual SbBool read1Value(SoInput * in, int idx); virtual void write1Value(SoOutput * out, int idx) const; protected: virtual void deleteAllValues(void); virtual void copyValue(int to, int from); virtual int fieldSizeof(void) const; virtual void * valuesPtr(void); virtual void setValuesPtr(void * ptr); virtual void allocValues(int num); SbVec3f * values; public: const SbVec3f & operator[](const int idx) const { this->evaluate(); return this->values[idx]; } const SbVec3f * getValues(const int start) const { this->evaluate(); return (const SbVec3f *)(this->values + start); } int find(const SbVec3f & value, SbBool addifnotfound = 0); void setValues(const int start, const int num, const SbVec3f * newvals); void set1Value(const int idx, const SbVec3f & value); void setValue(const SbVec3f & value); const SbVec3f & operator=(const SbVec3f & val) { this->setValue(val); return val; } SbBool operator==(const SoMFVec3f & field) const; SbBool operator!=(const SoMFVec3f & field) const { return !operator==(field); } SbVec3f * startEditing(void) { this->evaluate(); return this->values; } void finishEditing(void) { this->valueChanged(); };

  void setValuesPointer(const int num, const float * userdata); void setValuesPointer(const int num, float * userdata);
  void setValuesPointer(const int num, const SbVec3f * userdata); void setValuesPointer(const int num, SbVec3f * userdata);

public:
  static void initClass(void);

  void setValues(const int start, const int num, const float xyz[][3]);
  void set1Value(const int idx, const float x, const float y, const float z);
  void set1Value(const int idx, const float xyz[3]);
  void setValue(const float x, const float y, const float z);
  void setValue(const float xyz[3]);
};

#line 50 "c:\\coin3d\\include\\inventor\\fields\\somfvec3f.h"
#line 38 "h:\\c_projekte\\elansim\\headview.cpp"
#line 1 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlcoordinate.h"


























#line 1 "c:\\coin3d\\include\\inventor\\nodes\\sosubnode.h"

























































































































































































































#line 28 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlcoordinate.h"
#line 1 "c:\\coin3d\\include\\inventor\\nodes\\sonode.h"








































































































































































#line 29 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlcoordinate.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\somfvec3f.h"

















































#line 30 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlcoordinate.h"


class __declspec(dllimport) SoVRMLCoordinate : public SoNode
{
  typedef SoNode inherited;
  public: static SoType getClassTypeId(void); virtual SoType getTypeId(void) const; private: static SoType classTypeId; protected: static const SoFieldData ** getFieldDataPtr(void); virtual const SoFieldData * getFieldData(void) const; private: static void atexit_cleanup(void); static const SoFieldData ** parentFieldData; static SoFieldData * fieldData; static unsigned int classinstances; private: static void * createInstance(void);

public:
  static void initClass(void);
  SoVRMLCoordinate(void);

  SoMFVec3f point;

  virtual void doAction( SoAction * action );
  virtual void GLRender( SoGLRenderAction * action );
  virtual void getBoundingBox( SoGetBoundingBoxAction * action );
  virtual void callback( SoCallbackAction * action );
  virtual void pick( SoPickAction * action );

protected:
  virtual ~SoVRMLCoordinate();

}; 

#line 55 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlcoordinate.h"
#line 39 "h:\\c_projekte\\elansim\\headview.cpp"
#line 1 "c:\\coin3d\\include\\inventor\\nodes\\sospotlight.h"


























#line 1 "c:\\coin3d\\include\\inventor\\nodes\\sosubnode.h"

























































































































































































































#line 28 "c:\\coin3d\\include\\inventor\\nodes\\sospotlight.h"
#line 1 "c:\\coin3d\\include\\inventor\\nodes\\solight.h"



















































#line 29 "c:\\coin3d\\include\\inventor\\nodes\\sospotlight.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosfvec3f.h"











































#line 30 "c:\\coin3d\\include\\inventor\\nodes\\sospotlight.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosffloat.h"







































#line 31 "c:\\coin3d\\include\\inventor\\nodes\\sospotlight.h"

class __declspec(dllimport) SoSpotLight : public SoLight {
  typedef SoLight inherited;

  public: static SoType getClassTypeId(void); virtual SoType getTypeId(void) const; private: static SoType classTypeId; protected: static const SoFieldData ** getFieldDataPtr(void); virtual const SoFieldData * getFieldData(void) const; private: static void atexit_cleanup(void); static const SoFieldData ** parentFieldData; static SoFieldData * fieldData; static unsigned int classinstances; private: static void * createInstance(void);

public:
  static void initClass(void);
  SoSpotLight(void);

  SoSFVec3f location;
  SoSFVec3f direction;
  SoSFFloat dropOffRate;
  SoSFFloat cutOffAngle;

  virtual void GLRender(SoGLRenderAction * action);

protected:
  virtual ~SoSpotLight();
};

#line 53 "c:\\coin3d\\include\\inventor\\nodes\\sospotlight.h"
#line 40 "h:\\c_projekte\\elansim\\headview.cpp"
#line 1 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlelevationgrid.h"


























#line 1 "c:\\coin3d\\include\\inventor\\nodes\\sosubnode.h"

























































































































































































































#line 28 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlelevationgrid.h"
#line 1 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlgeometry.h"
























































#line 29 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlelevationgrid.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosfbool.h"







































#line 30 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlelevationgrid.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosffloat.h"







































#line 31 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlelevationgrid.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosfint32.h"


























#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosfield.h"













































#line 28 "c:\\coin3d\\include\\inventor\\fields\\sosfint32.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosubfield.h"

















































































































































































































































































































































































































































































































#line 29 "c:\\coin3d\\include\\inventor\\fields\\sosfint32.h"

class __declspec(dllimport) SoSFInt32 : public SoSField {
  typedef SoSField inherited;

  public: SoSFInt32(void); virtual ~SoSFInt32(); private: static SoType classTypeId; public: static void * createInstance(void); static SoType getClassTypeId(void); virtual SoType getTypeId(void) const; virtual void copyFrom(const SoField & field); const SoSFInt32 & operator=(const SoSFInt32 & field); virtual SbBool isSame(const SoField & field) const; private: virtual SbBool readValue(SoInput * in); virtual void writeValue(SoOutput * out) const; protected: int32_t value; public: int32_t getValue(void) const { this->evaluate(); return this->value; } void setValue(int32_t newvalue); int32_t operator=(int32_t newvalue) { this->setValue(newvalue); return this->value; } int operator==(const SoSFInt32 & field) const; int operator!=(const SoSFInt32 & field) const { return ! operator==(field); };

public:
  static void initClass(void);
};

#line 40 "c:\\coin3d\\include\\inventor\\fields\\sosfint32.h"
#line 32 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlelevationgrid.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosfbool.h"







































#line 33 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlelevationgrid.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosffloat.h"







































#line 34 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlelevationgrid.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\somffloat.h"


























#line 1 "c:\\coin3d\\include\\inventor\\fields\\somfield.h"




























































































#line 28 "c:\\coin3d\\include\\inventor\\fields\\somffloat.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosubfield.h"

















































































































































































































































































































































































































































































































#line 29 "c:\\coin3d\\include\\inventor\\fields\\somffloat.h"

class __declspec(dllimport) SoMFFloat : public SoMField {
  typedef SoMField inherited;

  public: SoMFFloat(void); virtual ~SoMFFloat(); private: static SoType classTypeId; public: static void * createInstance(void); static SoType getClassTypeId(void); virtual SoType getTypeId(void) const; virtual void copyFrom(const SoField & field); const SoMFFloat & operator=(const SoMFFloat & field); virtual SbBool isSame(const SoField & field) const; private: virtual SbBool read1Value(SoInput * in, int idx); virtual void write1Value(SoOutput * out, int idx) const; protected: virtual void deleteAllValues(void); virtual void copyValue(int to, int from); virtual int fieldSizeof(void) const; virtual void * valuesPtr(void); virtual void setValuesPtr(void * ptr); virtual void allocValues(int num); float * values; public: float operator[](const int idx) const { this->evaluate(); return this->values[idx]; } const float * getValues(const int start) const { this->evaluate(); return (const float *)(this->values + start); } int find(float value, SbBool addifnotfound = 0); void setValues(const int start, const int num, const float * newvals); void set1Value(const int idx, float value); void setValue(float value); float operator=(float val) { this->setValue(val); return val; } SbBool operator==(const SoMFFloat & field) const; SbBool operator!=(const SoMFFloat & field) const { return !operator==(field); } float * startEditing(void) { this->evaluate(); return this->values; } void finishEditing(void) { this->valueChanged(); };

  void setValuesPointer(const int num, const float * userdata); void setValuesPointer(const int num, float * userdata);

public:
  static void initClass(void);

private:
  virtual int getNumValuesPerLine(void) const;
};

#line 45 "c:\\coin3d\\include\\inventor\\fields\\somffloat.h"
#line 35 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlelevationgrid.h"
#line 1 "c:\\coin3d\\include\\inventor\\fields\\sosfnode.h"

























































#line 36 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlelevationgrid.h"

class SoChildList;

class SoVRMLElevationGridP;

class __declspec(dllimport) SoVRMLElevationGrid : public SoVRMLGeometry
{
  typedef SoVRMLGeometry inherited;
  public: static SoType getClassTypeId(void); virtual SoType getTypeId(void) const; private: static SoType classTypeId; protected: static const SoFieldData ** getFieldDataPtr(void); virtual const SoFieldData * getFieldData(void) const; private: static void atexit_cleanup(void); static const SoFieldData ** parentFieldData; static SoFieldData * fieldData; static unsigned int classinstances; private: static void * createInstance(void);

public:
  static void initClass(void);
  SoVRMLElevationGrid(void);

  SoSFBool ccw;
  SoSFBool solid;
  SoSFFloat creaseAngle;
  SoSFInt32 zDimension;
  SoSFInt32 xDimension;
  SoSFFloat zSpacing;
  SoSFFloat xSpacing;
  SoMFFloat height;
  SoSFNode texCoord;
  SoSFNode normal;
  SoSFNode color;
  SoSFBool colorPerVertex;
  SoSFBool normalPerVertex;

  virtual void GLRender(SoGLRenderAction * action);
  virtual void rayPick(SoRayPickAction * action);
  virtual void getPrimitiveCount(SoGetPrimitiveCountAction * action);

protected:
  virtual ~SoVRMLElevationGrid(void);

  virtual void notify(SoNotList * list);
  virtual void generatePrimitives( SoAction * action );
  virtual void computeBBox(SoAction * action, SbBox3f & bbox,
                           SbVec3f & center);

private:
  friend class SoVRMLElevationGridP;

  enum Binding {
    OVERALL,
    PER_QUAD,
    PER_VERTEX
  };

  Binding findMaterialBinding(void) const;
  Binding findNormalBinding(void) const;

  const SbVec3f * updateNormalCache(Binding & nbind);

  SoVRMLElevationGridP * pimpl;

}; 

#line 95 "c:\\coin3d\\include\\inventor\\vrmlnodes\\sovrmlelevationgrid.h"
#line 41 "h:\\c_projekte\\elansim\\headview.cpp"

#line 1 "c:\\qt\\include\\qcstring.h"















































































































































































































































































































































































































#line 43 "h:\\c_projekte\\elansim\\headview.cpp"
#line 1 "c:\\qt\\include\\qfile.h"









































#line 1 "c:\\qt\\include\\qiodevice.h"



























































































































































#line 43 "c:\\qt\\include\\qfile.h"
#line 1 "c:\\qt\\include\\qstring.h"
























































































































































































































































































































































































































































































































































































































































































































































































































































#line 44 "c:\\qt\\include\\qfile.h"

#line 46 "c:\\qt\\include\\qfile.h"

class QDir;


class __declspec(dllimport) QFile : public QIODevice			
{
public:
    QFile();
    QFile( const QString &name );
   ~QFile();

    QString	name()	const;
    void	setName( const QString &name );

    typedef QCString (*EncoderFn)( const QString &fileName );
    typedef QString (*DecoderFn)( const QCString &localfileName );
    static QCString encodeName( const QString &fileName );
    static QString decodeName( const QCString &localFileName );
    static void setEncodingFunction( EncoderFn );
    static void setDecodingFunction( DecoderFn );

    bool	exists()   const;
    static bool exists( const QString &fileName );

    bool	remove();
    static bool remove( const QString &fileName );

    bool	open( int );
    bool	open( int, FILE * );
    bool	open( int, int );
    void	close();
    void	flush();

    uint	size()	const;
    int		at()	const;
    bool	at( int );
    bool	atEnd() const;

    int		readBlock( char *data, uint len );
    int		writeBlock( const char *data, uint len );
    int		writeBlock( const QByteArray& data )
		    { return QIODevice::writeBlock(data); }
    int		readLine( char *data, uint maxlen );
    int		readLine( QString &, uint maxlen );

    int		getch();
    int		putch( int );
    int		ungetch( int );

    int		handle() const;

protected:
    QString	fn;
    FILE       *fh;
    int		fd;
    int		length;
    bool	ext_f;
    void * 	d;

private:
    void	init();
    QCString ungetchBuffer;

private:	



#line 114 "c:\\qt\\include\\qfile.h"
};


inline QString QFile::name() const
{ return fn; }

inline int QFile::at() const
{ return ioIndex; }


#line 125 "c:\\qt\\include\\qfile.h"
#line 44 "h:\\c_projekte\\elansim\\headview.cpp"


#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\fstream"



#pragma once
#line 6 "c:\\programme\\microsoft visual studio\\vc98\\include\\fstream"



#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\istream"



#pragma once
#line 6 "c:\\programme\\microsoft visual studio\\vc98\\include\\istream"



#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\ostream"



#pragma once
#line 6 "c:\\programme\\microsoft visual studio\\vc98\\include\\ostream"



#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\ios"



#pragma once
#line 6 "c:\\programme\\microsoft visual studio\\vc98\\include\\ios"



#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\streambuf"



#pragma once
#line 6 "c:\\programme\\microsoft visual studio\\vc98\\include\\streambuf"



#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\xlocnum"



#pragma once
#line 6 "c:\\programme\\microsoft visual studio\\vc98\\include\\xlocnum"



#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\cerrno"



#pragma once
#line 6 "c:\\programme\\microsoft visual studio\\vc98\\include\\cerrno"








 #line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\errno.h"
















#pragma once
#line 19 "c:\\programme\\microsoft visual studio\\vc98\\include\\errno.h"






#line 26 "c:\\programme\\microsoft visual studio\\vc98\\include\\errno.h"



extern "C" {
#line 31 "c:\\programme\\microsoft visual studio\\vc98\\include\\errno.h"


















#line 50 "c:\\programme\\microsoft visual studio\\vc98\\include\\errno.h"















__declspec(dllimport) extern int * __cdecl _errno(void);



#line 70 "c:\\programme\\microsoft visual studio\\vc98\\include\\errno.h"
















































}
#line 120 "c:\\programme\\microsoft visual studio\\vc98\\include\\errno.h"

#line 122 "c:\\programme\\microsoft visual studio\\vc98\\include\\errno.h"
#line 15 "c:\\programme\\microsoft visual studio\\vc98\\include\\cerrno"
#line 16 "c:\\programme\\microsoft visual studio\\vc98\\include\\cerrno"
#line 17 "c:\\programme\\microsoft visual studio\\vc98\\include\\cerrno"





#line 10 "c:\\programme\\microsoft visual studio\\vc98\\include\\xlocnum"
#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\climits"



#pragma once
#line 6 "c:\\programme\\microsoft visual studio\\vc98\\include\\climits"




#line 11 "c:\\programme\\microsoft visual studio\\vc98\\include\\climits"





#line 11 "c:\\programme\\microsoft visual studio\\vc98\\include\\xlocnum"
#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\cstdio"



#pragma once
#line 6 "c:\\programme\\microsoft visual studio\\vc98\\include\\cstdio"








 
#line 16 "c:\\programme\\microsoft visual studio\\vc98\\include\\cstdio"
#line 17 "c:\\programme\\microsoft visual studio\\vc98\\include\\cstdio"





#line 12 "c:\\programme\\microsoft visual studio\\vc98\\include\\xlocnum"
#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\cstdlib"



#pragma once
#line 6 "c:\\programme\\microsoft visual studio\\vc98\\include\\cstdlib"








 
#line 16 "c:\\programme\\microsoft visual studio\\vc98\\include\\cstdlib"
#line 17 "c:\\programme\\microsoft visual studio\\vc98\\include\\cstdlib"





#line 13 "c:\\programme\\microsoft visual studio\\vc98\\include\\xlocnum"
#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\xiosbase"



#pragma once
#line 6 "c:\\programme\\microsoft visual studio\\vc98\\include\\xiosbase"



#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\xlocale"



#pragma once
#line 6 "c:\\programme\\microsoft visual studio\\vc98\\include\\xlocale"




#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\cstring"



#pragma once
#line 6 "c:\\programme\\microsoft visual studio\\vc98\\include\\cstring"








 
#line 16 "c:\\programme\\microsoft visual studio\\vc98\\include\\cstring"
#line 17 "c:\\programme\\microsoft visual studio\\vc98\\include\\cstring"





#line 11 "c:\\programme\\microsoft visual studio\\vc98\\include\\xlocale"
#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdexcept"



#pragma once
#line 6 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdexcept"



#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\exception"
















#pragma once
#line 19 "c:\\programme\\microsoft visual studio\\vc98\\include\\exception"



#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\xstddef"



#pragma once
#line 6 "c:\\programme\\microsoft visual studio\\vc98\\include\\xstddef"




 #line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\yvals.h"



#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\use_ansi.h"















#pragma once
#line 18 "c:\\programme\\microsoft visual studio\\vc98\\include\\use_ansi.h"







#pragma comment(lib,"msvcprtd")


#line 29 "c:\\programme\\microsoft visual studio\\vc98\\include\\use_ansi.h"







#line 37 "c:\\programme\\microsoft visual studio\\vc98\\include\\use_ansi.h"







#line 45 "c:\\programme\\microsoft visual studio\\vc98\\include\\use_ansi.h"

#line 47 "c:\\programme\\microsoft visual studio\\vc98\\include\\use_ansi.h"
#line 5 "c:\\programme\\microsoft visual studio\\vc98\\include\\yvals.h"











#pragma pack(push,8)
#line 18 "c:\\programme\\microsoft visual studio\\vc98\\include\\yvals.h"

 #pragma warning(4: 4018 4114 4146 4244 4245)
 #pragma warning(4: 4663 4664 4665)
 #pragma warning(disable: 4237 4284 4290 4514)
		
 
  
  
  
  
 



#line 33 "c:\\programme\\microsoft visual studio\\vc98\\include\\yvals.h"
namespace std {
		
 
typedef bool _Bool;
 #line 38 "c:\\programme\\microsoft visual studio\\vc98\\include\\yvals.h"
		



		






		
 
  
  
 


#line 57 "c:\\programme\\microsoft visual studio\\vc98\\include\\yvals.h"

		
 
class __declspec(dllimport) _Lockit
	{	
public:
  
   
	_Lockit();
	~_Lockit();
  





#line 74 "c:\\programme\\microsoft visual studio\\vc98\\include\\yvals.h"
	};
 #line 76 "c:\\programme\\microsoft visual studio\\vc98\\include\\yvals.h"
		




};

#pragma pack(pop)
#line 85 "c:\\programme\\microsoft visual studio\\vc98\\include\\yvals.h"

#line 87 "c:\\programme\\microsoft visual studio\\vc98\\include\\yvals.h"





#line 11 "c:\\programme\\microsoft visual studio\\vc98\\include\\xstddef"
#line 12 "c:\\programme\\microsoft visual studio\\vc98\\include\\xstddef"
#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\cstddef"



#pragma once
#line 6 "c:\\programme\\microsoft visual studio\\vc98\\include\\cstddef"




 
 
 


#line 16 "c:\\programme\\microsoft visual studio\\vc98\\include\\cstddef"
#line 17 "c:\\programme\\microsoft visual studio\\vc98\\include\\cstddef"





#line 13 "c:\\programme\\microsoft visual studio\\vc98\\include\\xstddef"











#pragma pack(push,8)
#line 26 "c:\\programme\\microsoft visual studio\\vc98\\include\\xstddef"
namespace std {
		
 
 
 
 
 
 
 
 
 
		
		
 
 
		


 
 
 
 
 
		
enum _Uninitialized {_Noinit};
		
__declspec(dllimport) void __cdecl _Nomemory();
};

#pragma pack(pop)
#line 57 "c:\\programme\\microsoft visual studio\\vc98\\include\\xstddef"

#line 59 "c:\\programme\\microsoft visual studio\\vc98\\include\\xstddef"





#line 23 "c:\\programme\\microsoft visual studio\\vc98\\include\\exception"
#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\eh.h"













#pragma once
#line 16 "c:\\programme\\microsoft visual studio\\vc98\\include\\eh.h"






#line 23 "c:\\programme\\microsoft visual studio\\vc98\\include\\eh.h"





#pragma pack(push,8)
#line 30 "c:\\programme\\microsoft visual studio\\vc98\\include\\eh.h"


























typedef void (__cdecl *terminate_function)();
typedef void (__cdecl *unexpected_function)();
typedef void (__cdecl *terminate_handler)();
typedef void (__cdecl *unexpected_handler)();


struct _EXCEPTION_POINTERS;
typedef void (__cdecl *_se_translator_function)(unsigned int, struct _EXCEPTION_POINTERS*);
#line 65 "c:\\programme\\microsoft visual studio\\vc98\\include\\eh.h"


__declspec(dllimport) __declspec(noreturn) void __cdecl terminate(void);
__declspec(dllimport) __declspec(noreturn) void __cdecl unexpected(void);



#line 73 "c:\\programme\\microsoft visual studio\\vc98\\include\\eh.h"

__declspec(dllimport) terminate_function __cdecl set_terminate(terminate_function);
__declspec(dllimport) unexpected_function __cdecl set_unexpected(unexpected_function);

__declspec(dllimport) _se_translator_function __cdecl _set_se_translator(_se_translator_function);
#line 79 "c:\\programme\\microsoft visual studio\\vc98\\include\\eh.h"


#pragma pack(pop)
#line 83 "c:\\programme\\microsoft visual studio\\vc98\\include\\eh.h"

#line 85 "c:\\programme\\microsoft visual studio\\vc98\\include\\eh.h"
#line 24 "c:\\programme\\microsoft visual studio\\vc98\\include\\exception"


#pragma pack(push,8)
#line 28 "c:\\programme\\microsoft visual studio\\vc98\\include\\exception"

 

#line 32 "c:\\programme\\microsoft visual studio\\vc98\\include\\exception"















typedef const char *__exString;

class __declspec(dllimport) exception
{
public:
    exception();
    exception(const __exString&);
    exception(const exception&);
    exception& operator= (const exception&);
    virtual ~exception();
    virtual __exString what() const;
private:
    __exString _m_what;
    int _m_doFree;
};
namespace std {
using ::exception;

		
class __declspec(dllimport) bad_exception : public exception {
public:
	bad_exception(const char *_S = "bad exception") throw ()
		: exception(_S) {}
	virtual ~bad_exception() throw ()
		{}
protected:
	virtual void _Doraise() const
		{throw (*this); }
	};

__declspec(dllimport) bool __cdecl uncaught_exception();

};






#pragma pack(pop)
#line 88 "c:\\programme\\microsoft visual studio\\vc98\\include\\exception"

#line 90 "c:\\programme\\microsoft visual studio\\vc98\\include\\exception"






#line 10 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdexcept"
#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\xstring"



#pragma once
#line 6 "c:\\programme\\microsoft visual studio\\vc98\\include\\xstring"



#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\xmemory"



#pragma once
#line 6 "c:\\programme\\microsoft visual studio\\vc98\\include\\xmemory"




#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\new"



#pragma once
#line 6 "c:\\programme\\microsoft visual studio\\vc98\\include\\new"






#pragma pack(push,8)
#line 14 "c:\\programme\\microsoft visual studio\\vc98\\include\\new"
namespace std {
		
class __declspec(dllimport) bad_alloc : public exception {
public:
	bad_alloc(const char *_S = "bad allocation") throw ()
		: exception(_S) {}
	virtual ~bad_alloc() throw ()
		{}
protected:
	virtual void _Doraise() const
		{throw (*this); }
	};
		
struct nothrow_t {};
extern __declspec(dllimport) const nothrow_t nothrow;
};

typedef void (__cdecl *new_handler)();

		
void __cdecl operator delete(void *) throw ();
void *__cdecl operator new(size_t) throw (std::bad_alloc);
void *__cdecl operator new(size_t, const std::nothrow_t&)
	throw ();



inline void *__cdecl operator new(size_t, void *_P)
	{return (_P); }

inline void __cdecl operator delete(void *, void *)
	{return; }
#line 47 "c:\\programme\\microsoft visual studio\\vc98\\include\\new"
#line 48 "c:\\programme\\microsoft visual studio\\vc98\\include\\new"


__declspec(dllimport)
#line 52 "c:\\programme\\microsoft visual studio\\vc98\\include\\new"
	new_handler __cdecl set_new_handler(new_handler) throw ();


#pragma pack(pop)
#line 57 "c:\\programme\\microsoft visual studio\\vc98\\include\\new"

#line 59 "c:\\programme\\microsoft visual studio\\vc98\\include\\new"





#line 11 "c:\\programme\\microsoft visual studio\\vc98\\include\\xmemory"


#pragma pack(push,8)
#line 15 "c:\\programme\\microsoft visual studio\\vc98\\include\\xmemory"
 #line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\utility"



#pragma once
#line 6 "c:\\programme\\microsoft visual studio\\vc98\\include\\utility"



#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\iosfwd"



#pragma once
#line 6 "c:\\programme\\microsoft visual studio\\vc98\\include\\iosfwd"





#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\cwchar"



#pragma once
#line 6 "c:\\programme\\microsoft visual studio\\vc98\\include\\cwchar"




 
 #line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\wchar.h"


















#pragma once
#line 21 "c:\\programme\\microsoft visual studio\\vc98\\include\\wchar.h"









#line 31 "c:\\programme\\microsoft visual studio\\vc98\\include\\wchar.h"



#pragma pack(push,8)
#line 36 "c:\\programme\\microsoft visual studio\\vc98\\include\\wchar.h"


extern "C" {
#line 40 "c:\\programme\\microsoft visual studio\\vc98\\include\\wchar.h"

























#line 66 "c:\\programme\\microsoft visual studio\\vc98\\include\\wchar.h"











































































typedef unsigned long _fsize_t; 

#line 144 "c:\\programme\\microsoft visual studio\\vc98\\include\\wchar.h"



struct _wfinddata_t {
        unsigned attrib;
        time_t   time_create;   
        time_t   time_access;   
        time_t   time_write;
        _fsize_t size;
        wchar_t  name[260];
};



struct _wfinddatai64_t {
        unsigned attrib;
        time_t   time_create;   
        time_t   time_access;   
        time_t   time_write;
        __int64  size;
        wchar_t  name[260];
};
#line 167 "c:\\programme\\microsoft visual studio\\vc98\\include\\wchar.h"
#line 168 "c:\\programme\\microsoft visual studio\\vc98\\include\\wchar.h"


#line 171 "c:\\programme\\microsoft visual studio\\vc98\\include\\wchar.h"













__declspec(dllimport) extern unsigned short _ctype[];
__declspec(dllimport) extern unsigned short *_pctype;

__declspec(dllimport) extern wctype_t *_pwctype;
#line 189 "c:\\programme\\microsoft visual studio\\vc98\\include\\wchar.h"
#line 190 "c:\\programme\\microsoft visual studio\\vc98\\include\\wchar.h"








                                
















__declspec(dllimport) int __cdecl iswalpha(wint_t);
__declspec(dllimport) int __cdecl iswupper(wint_t);
__declspec(dllimport) int __cdecl iswlower(wint_t);
__declspec(dllimport) int __cdecl iswdigit(wint_t);
__declspec(dllimport) int __cdecl iswxdigit(wint_t);
__declspec(dllimport) int __cdecl iswspace(wint_t);
__declspec(dllimport) int __cdecl iswpunct(wint_t);
__declspec(dllimport) int __cdecl iswalnum(wint_t);
__declspec(dllimport) int __cdecl iswprint(wint_t);
__declspec(dllimport) int __cdecl iswgraph(wint_t);
__declspec(dllimport) int __cdecl iswcntrl(wint_t);
__declspec(dllimport) int __cdecl iswascii(wint_t);
__declspec(dllimport) int __cdecl isleadbyte(int);

__declspec(dllimport) wchar_t __cdecl towupper(wchar_t);
__declspec(dllimport) wchar_t __cdecl towlower(wchar_t);

__declspec(dllimport) int __cdecl iswctype(wint_t, wctype_t);


__declspec(dllimport) int __cdecl is_wctype(wint_t, wctype_t);



#line 240 "c:\\programme\\microsoft visual studio\\vc98\\include\\wchar.h"





__declspec(dllimport) int __cdecl _wchdir(const wchar_t *);
__declspec(dllimport) wchar_t * __cdecl _wgetcwd(wchar_t *, int);
__declspec(dllimport) wchar_t * __cdecl _wgetdcwd(int, wchar_t *, int);
__declspec(dllimport) int __cdecl _wmkdir(const wchar_t *);
__declspec(dllimport) int __cdecl _wrmdir(const wchar_t *);


#line 253 "c:\\programme\\microsoft visual studio\\vc98\\include\\wchar.h"





__declspec(dllimport) int __cdecl _waccess(const wchar_t *, int);
__declspec(dllimport) int __cdecl _wchmod(const wchar_t *, int);
__declspec(dllimport) int __cdecl _wcreat(const wchar_t *, int);
__declspec(dllimport) long __cdecl _wfindfirst(wchar_t *, struct _wfinddata_t *);
__declspec(dllimport) int __cdecl _wfindnext(long, struct _wfinddata_t *);
__declspec(dllimport) int __cdecl _wunlink(const wchar_t *);
__declspec(dllimport) int __cdecl _wrename(const wchar_t *, const wchar_t *);
__declspec(dllimport) int __cdecl _wopen(const wchar_t *, int, ...);
__declspec(dllimport) int __cdecl _wsopen(const wchar_t *, int, int, ...);
__declspec(dllimport) wchar_t * __cdecl _wmktemp(wchar_t *);


__declspec(dllimport) long __cdecl _wfindfirsti64(wchar_t *, struct _wfinddatai64_t *);
__declspec(dllimport) int __cdecl _wfindnexti64(long, struct _wfinddatai64_t *);
#line 273 "c:\\programme\\microsoft visual studio\\vc98\\include\\wchar.h"


#line 276 "c:\\programme\\microsoft visual studio\\vc98\\include\\wchar.h"





__declspec(dllimport) wchar_t * __cdecl _wsetlocale(int, const wchar_t *);


#line 285 "c:\\programme\\microsoft visual studio\\vc98\\include\\wchar.h"





__declspec(dllimport) int __cdecl _wexecl(const wchar_t *, const wchar_t *, ...);
__declspec(dllimport) int __cdecl _wexecle(const wchar_t *, const wchar_t *, ...);
__declspec(dllimport) int __cdecl _wexeclp(const wchar_t *, const wchar_t *, ...);
__declspec(dllimport) int __cdecl _wexeclpe(const wchar_t *, const wchar_t *, ...);
__declspec(dllimport) int __cdecl _wexecv(const wchar_t *, const wchar_t * const *);
__declspec(dllimport) int __cdecl _wexecve(const wchar_t *, const wchar_t * const *, const wchar_t * const *);
__declspec(dllimport) int __cdecl _wexecvp(const wchar_t *, const wchar_t * const *);
__declspec(dllimport) int __cdecl _wexecvpe(const wchar_t *, const wchar_t * const *, const wchar_t * const *);
__declspec(dllimport) int __cdecl _wspawnl(int, const wchar_t *, const wchar_t *, ...);
__declspec(dllimport) int __cdecl _wspawnle(int, const wchar_t *, const wchar_t *, ...);
__declspec(dllimport) int __cdecl _wspawnlp(int, const wchar_t *, const wchar_t *, ...);
__declspec(dllimport) int __cdecl _wspawnlpe(int, const wchar_t *, const wchar_t *, ...);
__declspec(dllimport) int __cdecl _wspawnv(int, const wchar_t *, const wchar_t * const *);
__declspec(dllimport) int __cdecl _wspawnve(int, const wchar_t *, const wchar_t * const *,
        const wchar_t * const *);
__declspec(dllimport) int __cdecl _wspawnvp(int, const wchar_t *, const wchar_t * const *);
__declspec(dllimport) int __cdecl _wspawnvpe(int, const wchar_t *, const wchar_t * const *,
        const wchar_t * const *);
__declspec(dllimport) int __cdecl _wsystem(const wchar_t *);


#line 312 "c:\\programme\\microsoft visual studio\\vc98\\include\\wchar.h"





















inline int __cdecl iswalpha(wint_t _C) {return (iswctype(_C,(0x0100|0x1|0x2))); }
inline int __cdecl iswupper(wint_t _C) {return (iswctype(_C,0x1)); }
inline int __cdecl iswlower(wint_t _C) {return (iswctype(_C,0x2)); }
inline int __cdecl iswdigit(wint_t _C) {return (iswctype(_C,0x4)); }
inline int __cdecl iswxdigit(wint_t _C) {return (iswctype(_C,0x80)); }
inline int __cdecl iswspace(wint_t _C) {return (iswctype(_C,0x8)); }
inline int __cdecl iswpunct(wint_t _C) {return (iswctype(_C,0x10)); }
inline int __cdecl iswalnum(wint_t _C) {return (iswctype(_C,(0x0100|0x1|0x2)|0x4)); }
inline int __cdecl iswprint(wint_t _C)
        {return (iswctype(_C,0x40|0x10|(0x0100|0x1|0x2)|0x4)); }
inline int __cdecl iswgraph(wint_t _C)
        {return (iswctype(_C,0x10|(0x0100|0x1|0x2)|0x4)); }
inline int __cdecl iswcntrl(wint_t _C) {return (iswctype(_C,0x20)); }
inline int __cdecl iswascii(wint_t _C) {return ((unsigned)(_C) < 0x80); }


inline int __cdecl isleadbyte(int _C)
        {return (_pctype[(unsigned char)(_C)] & 0x8000); }
#line 352 "c:\\programme\\microsoft visual studio\\vc98\\include\\wchar.h"
#line 353 "c:\\programme\\microsoft visual studio\\vc98\\include\\wchar.h"

#line 355 "c:\\programme\\microsoft visual studio\\vc98\\include\\wchar.h"



































struct _stat {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };



struct stat {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };
#line 420 "c:\\programme\\microsoft visual studio\\vc98\\include\\wchar.h"


struct _stati64 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        __int64 st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };
#line 436 "c:\\programme\\microsoft visual studio\\vc98\\include\\wchar.h"


#line 439 "c:\\programme\\microsoft visual studio\\vc98\\include\\wchar.h"






__declspec(dllimport) int __cdecl _wstat(const wchar_t *, struct _stat *);


__declspec(dllimport) int __cdecl _wstati64(const wchar_t *, struct _stati64 *);
#line 450 "c:\\programme\\microsoft visual studio\\vc98\\include\\wchar.h"


#line 453 "c:\\programme\\microsoft visual studio\\vc98\\include\\wchar.h"

#line 455 "c:\\programme\\microsoft visual studio\\vc98\\include\\wchar.h"








































































































#line 560 "c:\\programme\\microsoft visual studio\\vc98\\include\\wchar.h"






























































struct tm {
        int tm_sec;     
        int tm_min;     
        int tm_hour;    
        int tm_mday;    
        int tm_mon;     
        int tm_year;    
        int tm_wday;    
        int tm_yday;    
        int tm_isdst;   
        };

#line 635 "c:\\programme\\microsoft visual studio\\vc98\\include\\wchar.h"





__declspec(dllimport) wchar_t * __cdecl _wasctime(const struct tm *);
__declspec(dllimport) wchar_t * __cdecl _wctime(const time_t *);
__declspec(dllimport) size_t __cdecl wcsftime(wchar_t *, size_t, const wchar_t *,
        const struct tm *);
__declspec(dllimport) wchar_t * __cdecl _wstrdate(wchar_t *);
__declspec(dllimport) wchar_t * __cdecl _wstrtime(wchar_t *);


#line 649 "c:\\programme\\microsoft visual studio\\vc98\\include\\wchar.h"



typedef int mbstate_t;
typedef wchar_t _Wint_t;

__declspec(dllimport) wint_t __cdecl btowc(int);
__declspec(dllimport) size_t __cdecl mbrlen(const char *, size_t, mbstate_t *);
__declspec(dllimport) size_t __cdecl mbrtowc(wchar_t *, const char *, size_t, mbstate_t *);
__declspec(dllimport) size_t __cdecl mbsrtowcs(wchar_t *, const char **, size_t, mbstate_t *);

__declspec(dllimport) size_t __cdecl wcrtomb(char *, wchar_t, mbstate_t *);
__declspec(dllimport) size_t __cdecl wcsrtombs(char *, const wchar_t **, size_t, mbstate_t *);
__declspec(dllimport) int __cdecl wctob(wint_t);


inline int fwide(FILE *, int _M)
        {return (_M); }
inline int mbsinit(const mbstate_t *)
        {return (1); }
inline const wchar_t *wmemchr(const wchar_t *_S, wchar_t _C, size_t _N)
        {for (; 0 < _N; ++_S, --_N)
                if (*_S == _C)
                        return (_S);
        return (0); }
inline int wmemcmp(const wchar_t *_S1, const wchar_t *_S2, size_t _N)
        {for (; 0 < _N; ++_S1, ++_S2, --_N)
                if (*_S1 != *_S2)
                        return (*_S1 < *_S2 ? -1 : +1);
        return (0); }
inline wchar_t *wmemcpy(wchar_t *_S1, const wchar_t *_S2, size_t _N)
        {wchar_t *_Su1 = _S1;
        for (; 0 < _N; ++_Su1, ++_S2, --_N)
                *_Su1 = *_S2;
        return (_S1); }
inline wchar_t *wmemmove(wchar_t *_S1, const wchar_t *_S2, size_t _N)
        {wchar_t *_Su1 = _S1;
        if (_S2 < _Su1 && _Su1 < _S2 + _N)
                for (_Su1 += _N, _S2 += _N; 0 < _N; --_N)
                        *--_Su1 = *--_S2;
        else
                for (; 0 < _N; --_N)
                        *_Su1++ = *_S2++;
        return (_S1); }
inline wchar_t *wmemset(wchar_t *_S, wchar_t _C, size_t _N)
        {wchar_t *_Su = _S;
        for (; 0 < _N; ++_Su, --_N)
                *_Su = _C;
        return (_S); }
}       
inline wchar_t *wmemchr(wchar_t *_S, wchar_t _C, size_t _N)
        {return ((wchar_t *)wmemchr((const wchar_t *)_S, _C, _N)); }
inline wchar_t *wcschr(wchar_t *_S, wchar_t _C)
        {return ((wchar_t *)wcschr((const wchar_t *)_S, _C)); }
inline wchar_t *wcspbrk(wchar_t *_S, const wchar_t *_P)
        {return ((wchar_t *)wcspbrk((const wchar_t *)_S, _P)); }
inline wchar_t *wcsrchr(wchar_t *_S, wchar_t _C)
        {return ((wchar_t *)wcsrchr((const wchar_t *)_S, _C)); }
inline wchar_t *wcsstr(wchar_t *_S, const wchar_t *_P)
        {return ((wchar_t *)wcsstr((const wchar_t *)_S, _P)); }
#line 710 "c:\\programme\\microsoft visual studio\\vc98\\include\\wchar.h"


#pragma pack(pop)
#line 714 "c:\\programme\\microsoft visual studio\\vc98\\include\\wchar.h"

#line 716 "c:\\programme\\microsoft visual studio\\vc98\\include\\wchar.h"













#line 730 "c:\\programme\\microsoft visual studio\\vc98\\include\\wchar.h"
#line 12 "c:\\programme\\microsoft visual studio\\vc98\\include\\cwchar"
 


#line 16 "c:\\programme\\microsoft visual studio\\vc98\\include\\cwchar"
#line 17 "c:\\programme\\microsoft visual studio\\vc98\\include\\cwchar"





#line 12 "c:\\programme\\microsoft visual studio\\vc98\\include\\iosfwd"



#pragma pack(push,8)
#line 17 "c:\\programme\\microsoft visual studio\\vc98\\include\\iosfwd"
namespace std {
                
typedef long streamoff;
const streamoff _BADOFF = -1;
typedef int streamsize;
extern __declspec(dllimport) const fpos_t _Fpz;
                
template<class _St>
        class fpos {
        typedef fpos<_St> _Myt;
public:

        fpos(streamoff _O = 0)
                : _Off(_O), _Fpos(_Fpz)
                {_Lockit _Lk;
                _State = _Stz; }



#line 37 "c:\\programme\\microsoft visual studio\\vc98\\include\\iosfwd"
        fpos(_St _S, fpos_t _F)
                : _Off(0), _Fpos(_F), _State(_S) {}
        _St state() const
                {return (_State); }
        void state(_St _S)
                {_State = _S; }
        fpos_t get_fpos_t() const
                {return (_Fpos); }
        operator streamoff() const
                {return (_Off + ((long)(_Fpos))); }
        streamoff operator-(const _Myt& _R) const
                {return ((streamoff)*this - (streamoff)_R); }
        _Myt& operator+=(streamoff _O)
                {_Off += _O;
                return (*this); }
        _Myt& operator-=(streamoff _O)
                {_Off -= _O;
                return (*this); }
        _Myt operator+(streamoff _O) const
                {_Myt _Tmp = *this;
                return (_Tmp += _O); }
        _Myt operator-(streamoff _O) const
                {_Myt _Tmp = *this;
                return (_Tmp -= _O); }
        bool operator==(const _Myt& _R) const
                {return ((streamoff)*this == (streamoff)_R); }
        bool operator!=(const _Myt& _R) const
                {return (!(*this == _R)); }
private:
        static _St _Stz;
        streamoff _Off;
        fpos_t _Fpos;
        _St _State;
        };
template<class _St>
        _St fpos<_St>::_Stz;
typedef fpos<mbstate_t> streampos;
typedef streampos wstreampos;
                
template<class _E>
        struct char_traits {
        typedef _E char_type;
        typedef _E int_type;
        typedef streampos pos_type;
        typedef streamoff off_type;
        typedef mbstate_t state_type;
        static void __cdecl assign(_E& _X, const _E& _Y)
                {_X = _Y; }
        static bool __cdecl eq(const _E& _X, const _E& _Y)
                {return (_X == _Y); }
        static bool __cdecl lt(const _E& _X, const _E& _Y)
                {return (_X < _Y); }
        static int __cdecl compare(const _E *_U, const _E *_V, size_t _N)
                {for (size_t _I = 0; _I < _N; ++_I, ++_U, ++_V)
                        if (!eq(*_U, *_V))
                                return (lt(*_U, *_V) ? -1 : +1);
                return (0); }
        static size_t __cdecl length(const _E *_U)
                {size_t _N;
                for (_N = 0; !eq(*_U, _E(0)); ++_U)
                        ++_N;
                return (_N); }
        static _E * __cdecl copy(_E *_U, const _E *_V, size_t _N)
                {_E *_S = _U;
                for (; 0 < _N; --_N, ++_U, ++_V)
                        assign(*_U, *_V);
                return (_S); }
        static const _E * __cdecl find(const _E *_U, size_t _N,
                const _E& _C)
                {for (; 0 < _N; --_N, ++_U)
                        if (eq(*_U, _C))
                                return (_U);
                return (0); }
        static _E * __cdecl move(_E *_U, const _E *_V, size_t _N)
                {_E *_Ans = _U;
                if (_V < _U && _U < _V + _N)
                        for (_U += _N, _V += _N; 0 < _N; --_N)
                                assign(*--_U, *--_V);
                else
                        for (; 0 < _N; --_N, ++_U, ++_V)
                                assign(*_U, *_V);
                return (_Ans); }
        static _E * __cdecl assign(_E *_U, size_t _N, const _E& _C)
                {_E *_Ans = _U;
                for (; 0 < _N; --_N, ++_U)
                        assign(*_U, _C);
                return (_Ans); }
        static _E __cdecl to_char_type(const int_type& _C)
                {return ((_E)_C); }
        static int_type __cdecl to_int_type(const _E& _C)
                {return ((int_type)_C); }
        static bool __cdecl eq_int_type(const int_type& _X,
                const int_type& _Y)
                {return (_X == _Y); }
        static int_type __cdecl eof()
                {return ((-1)); }
        static int_type __cdecl not_eof(const int_type& _C)
                {return (_C != eof() ? _C : !eof()); }
        };
                
template<> struct __declspec(dllimport) char_traits<wchar_t> {
        typedef wchar_t _E;
        typedef _E char_type;   
        typedef wint_t int_type;
        typedef streampos pos_type;
        typedef streamoff off_type;
        typedef mbstate_t state_type;
        static void __cdecl assign(_E& _X, const _E& _Y)
                {_X = _Y; }
        static bool __cdecl eq(const _E& _X, const _E& _Y)
                {return (_X == _Y); }
        static bool __cdecl lt(const _E& _X, const _E& _Y)
                {return (_X < _Y); }
        static int __cdecl compare(const _E *_U, const _E *_V, size_t _N)
                {return (wmemcmp(_U, _V, _N)); }
        static size_t __cdecl length(const _E *_U)
                {return (wcslen(_U)); }
        static _E *__cdecl copy(_E *_U, const _E *_V, size_t _N)
                {return (wmemcpy(_U, _V, _N)); }
        static const _E * __cdecl find(const _E *_U, size_t _N,
                const _E& _C)
                {return ((const _E *)wmemchr(_U, _C, _N)); }
        static _E * __cdecl move(_E *_U, const _E *_V, size_t _N)
                {return (wmemmove(_U, _V, _N)); }
        static _E * __cdecl assign(_E *_U, size_t _N, const _E& _C)
                {return (wmemset(_U, _C, _N)); }
        static _E __cdecl to_char_type(const int_type& _C)
                {return ((_E)_C); }
        static int_type __cdecl to_int_type(const _E& _C)
                {return ((int_type)_C); }
        static bool __cdecl eq_int_type(const int_type& _X,
                const int_type& _Y)
                {return (_X == _Y); }
        static int_type __cdecl eof()
                {return ((wint_t)(0xFFFF)); }
        static int_type __cdecl not_eof(const int_type& _C)
                {return (_C != eof() ? _C : !eof()); }
        };
                
template<> struct __declspec(dllimport) char_traits<char> {
        typedef char _E;
        typedef _E char_type;
        typedef int int_type;
        typedef streampos pos_type;
        typedef streamoff off_type;
        typedef mbstate_t state_type;
        static void __cdecl assign(_E& _X, const _E& _Y)
                {_X = _Y; }
        static bool __cdecl eq(const _E& _X, const _E& _Y)
                {return (_X == _Y); }
        static bool __cdecl lt(const _E& _X, const _E& _Y)
                {return (_X < _Y); }
        static int __cdecl compare(const _E *_U, const _E *_V, size_t _N)
                {return (memcmp(_U, _V, _N)); }
        static size_t __cdecl length(const _E *_U)
                {return (qstrlen(_U)); }
        static _E * __cdecl copy(_E *_U, const _E *_V, size_t _N)
                {return ((_E *)memcpy(_U, _V, _N)); }
        static const _E * __cdecl find(const _E *_U, size_t _N,
                const _E& _C)
                {return ((const _E *)memchr(_U, _C, _N)); }
        static _E * __cdecl move(_E *_U, const _E *_V, size_t _N)
                {return ((_E *)memmove(_U, _V, _N)); }
        static _E * __cdecl assign(_E *_U, size_t _N, const _E& _C)
                {return ((_E *)memset(_U, _C, _N)); }
        static _E __cdecl to_char_type(const int_type& _C)
                {return ((_E)_C); }
        static int_type __cdecl to_int_type(const _E& _C)
                {return ((int_type)((unsigned char)_C)); }
        static bool __cdecl eq_int_type(const int_type& _X,
                const int_type& _Y)
                {return (_X == _Y); }
        static int_type __cdecl eof()
                {return ((-1)); }
        static int_type __cdecl not_eof(const int_type& _C)
                {return (_C != eof() ? _C : !eof()); }
        };
                
template<class T>
        class allocator;
class ios_base;
template<class _E, class _Tr = char_traits<_E> >
        class basic_ios;
template<class _E, class _Tr = char_traits<_E> >
        class istreambuf_iterator;
template<class _E, class _Tr = char_traits<_E> >
        class ostreambuf_iterator;
template<class _E, class _Tr = char_traits<_E> >
        class basic_streambuf;
template<class _E, class _Tr = char_traits<_E> >
        class basic_istream;
template<class _E, class _Tr = char_traits<_E> >
        class basic_ostream;
template<class _E, class _Tr = char_traits<_E> >
        class basic_iostream;
template<class _E, class _Tr = char_traits<_E>,
        class _A = allocator<_E> >
        class basic_stringbuf;
template<class _E, class _Tr = char_traits<_E>,
        class _A = allocator<_E> >
        class basic_istringstream;
template<class _E, class _Tr = char_traits<_E>,
        class _A = allocator<_E> >
        class basic_ostringstream;
template<class _E, class _Tr = char_traits<_E>,
        class _A = allocator<_E> >
        class basic_stringstream;
template<class _E, class _Tr = char_traits<_E> >
        class basic_filebuf;
template<class _E, class _Tr = char_traits<_E> >
        class basic_ifstream;
template<class _E, class _Tr = char_traits<_E> >
        class basic_ofstream;
template<class _E, class _Tr = char_traits<_E> >
        class basic_fstream;

                
typedef basic_ios<char, char_traits<char> > ios;
typedef basic_streambuf<char, char_traits<char> > streambuf;
typedef basic_istream<char, char_traits<char> > istream;
typedef basic_ostream<char, char_traits<char> > ostream;
typedef basic_iostream<char, char_traits<char> > iostream;
typedef basic_stringbuf<char, char_traits<char>,
        allocator<char> > stringbuf;
typedef basic_istringstream<char, char_traits<char>,
        allocator<char> > istringstream;
typedef basic_ostringstream<char, char_traits<char>,
        allocator<char> > ostringstream;
typedef basic_stringstream<char, char_traits<char>,
        allocator<char> > stringstream;
typedef basic_filebuf<char, char_traits<char> > filebuf;
typedef basic_ifstream<char, char_traits<char> > ifstream;
typedef basic_ofstream<char, char_traits<char> > ofstream;
typedef basic_fstream<char, char_traits<char> > fstream;
                
typedef basic_ios<wchar_t, char_traits<wchar_t> > wios;
typedef basic_streambuf<wchar_t, char_traits<wchar_t> >
        wstreambuf;
typedef basic_istream<wchar_t, char_traits<wchar_t> > wistream;
typedef basic_ostream<wchar_t, char_traits<wchar_t> > wostream;
typedef basic_iostream<wchar_t, char_traits<wchar_t> > wiostream;
typedef basic_stringbuf<wchar_t, char_traits<wchar_t>,
        allocator<wchar_t> > wstringbuf;
typedef basic_istringstream<wchar_t, char_traits<wchar_t>,
        allocator<wchar_t> > wistringstream;
typedef basic_ostringstream<wchar_t, char_traits<wchar_t>,
        allocator<wchar_t> > wostringstream;
typedef basic_stringstream<wchar_t, char_traits<wchar_t>,
        allocator<wchar_t> > wstringstream;
typedef basic_filebuf<wchar_t, char_traits<wchar_t> > wfilebuf;
typedef basic_ifstream<wchar_t, char_traits<wchar_t> > wifstream;
typedef basic_ofstream<wchar_t, char_traits<wchar_t> > wofstream;
typedef basic_fstream<wchar_t, char_traits<wchar_t> > wfstream;


template<class _E, class _II >
    class num_get;
template<class _E, class _OI >
    class num_put;
template<class _E>
    class collate;

typedef num_get<char, istreambuf_iterator<char, char_traits<char> > > numget;
typedef num_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t> > >
                                                                                                                                          wnumget;
typedef num_put<char, ostreambuf_iterator<char, char_traits<char> > > numput;
typedef num_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t> > >
                                                                                                                                          wnumput;
typedef collate<char> ncollate;
typedef collate<wchar_t> wcollate;

#line 309 "c:\\programme\\microsoft visual studio\\vc98\\include\\iosfwd"

};

#pragma pack(pop)
#line 314 "c:\\programme\\microsoft visual studio\\vc98\\include\\iosfwd"

#line 316 "c:\\programme\\microsoft visual studio\\vc98\\include\\iosfwd"





#line 10 "c:\\programme\\microsoft visual studio\\vc98\\include\\utility"


#pragma pack(push,8)
#line 14 "c:\\programme\\microsoft visual studio\\vc98\\include\\utility"
namespace std {
		
template<class _T1, class _T2> struct pair {
	typedef _T1 first_type;
	typedef _T2 second_type;
	pair()
		: first(_T1()), second(_T2()) {}
	pair(const _T1& _V1, const _T2& _V2)
		: first(_V1), second(_V2) {}
	template<class U, class V> pair(const pair<U, V> &p)
		: first(p.first), second(p.second) {}
	_T1 first;
	_T2 second;
	};
template<class _T1, class _T2> inline
	bool __cdecl operator==(const pair<_T1, _T2>& _X,
		const pair<_T1, _T2>& _Y)
	{return (_X.first == _Y.first && _X.second == _Y.second); }
template<class _T1, class _T2> inline
	bool __cdecl operator!=(const pair<_T1, _T2>& _X,
		const pair<_T1, _T2>& _Y)
	{return (!(_X == _Y)); }
template<class _T1, class _T2> inline
	bool __cdecl operator<(const pair<_T1, _T2>& _X,
		const pair<_T1, _T2>& _Y)
	{return (_X.first < _Y.first ||
		!(_Y.first < _X.first) && _X.second < _Y.second); }
template<class _T1, class _T2> inline
	bool __cdecl operator>(const pair<_T1, _T2>& _X,
		const pair<_T1, _T2>& _Y)
	{return (_Y < _X); }
template<class _T1, class _T2> inline
	bool __cdecl operator<=(const pair<_T1, _T2>& _X,
		const pair<_T1, _T2>& _Y)
	{return (!(_Y < _X)); }
template<class _T1, class _T2> inline
	bool __cdecl operator>=(const pair<_T1, _T2>& _X,
		const pair<_T1, _T2>& _Y)
	{return (!(_X < _Y)); }
template<class _T1, class _T2> inline
	pair<_T1, _T2> __cdecl make_pair(const _T1& _X, const _T2& _Y)
	{return (pair<_T1, _T2>(_X, _Y)); }
		
struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag
	: public input_iterator_tag {};
struct bidirectional_iterator_tag
	: public forward_iterator_tag {};
struct random_access_iterator_tag
	: public bidirectional_iterator_tag  {};
		
template<class _C, class _Ty, class _D = ptrdiff_t>
	struct iterator {
	typedef _C iterator_category;
	typedef _Ty value_type;
	typedef _D distance_type;
	};
template<class _Ty, class _D>
	struct _Bidit : public iterator<bidirectional_iterator_tag,
		_Ty, _D> {};
template<class _Ty, class _D>
	struct _Ranit : public iterator<random_access_iterator_tag,
		_Ty, _D> {};
		
template<class _It>
	struct iterator_traits {
	typedef _It::iterator_category iterator_category;
	typedef _It::value_type value_type;
	typedef _It::distance_type distance_type;
	};
		
template<class _C, class _Ty, class _D> inline
	_C __cdecl _Iter_cat(const iterator<_C, _Ty, _D>&)
	{_C _IterCatTag;
	 _C* _pIterCatTag;
	_pIterCatTag = &_IterCatTag;	
	return (_IterCatTag); }
template<class _Ty> inline
	random_access_iterator_tag __cdecl _Iter_cat(const _Ty *)
	{random_access_iterator_tag _RandIterTag;
	 random_access_iterator_tag* _pRandIterTag;
	_pRandIterTag = &_RandIterTag;	
	return (_RandIterTag); }
		
template<class _II> inline
	ptrdiff_t __cdecl distance(_II _F, _II _L)
	{ptrdiff_t _N = 0;
	_Distance(_F, _L, _N, _Iter_cat(_F));
	return (_N); }
template<class _II, class _D> inline
	void __cdecl _Distance(_II _F, _II _L, _D& _N)
	{_Distance(_F, _L, _N, _Iter_cat(_F)); }
template<class _II, class _D> inline
	void __cdecl _Distance(_II _F, _II _L, _D& _N, input_iterator_tag)
	{for (; _F != _L; ++_F)
		++_N; }
template<class _II, class _D> inline
	void __cdecl _Distance(_II _F, _II _L, _D& _N, forward_iterator_tag)
	{for (; _F != _L; ++_F)
		++_N; }
template<class _II, class _D> inline
	void __cdecl _Distance(_II _F, _II _L, _D& _N,
		bidirectional_iterator_tag)
	{for (; _F != _L; ++_F)
		++_N; }
template<class _RI, class _D> inline
	void __cdecl _Distance(_RI _F, _RI _L, _D& _N,
		random_access_iterator_tag)
	{_N += _L - _F; }
		
template<class _RI,
	class _Ty,
	class _Rt = _Ty&,
	class _Pt = _Ty *,
	class _D = ptrdiff_t>
	class reverse_iterator : public _Ranit<_Ty, _D> {
public:
	typedef reverse_iterator<_RI, _Ty, _Rt, _Pt, _D> _Myt;
	typedef _RI iter_type;
	typedef _Rt reference_type;
	typedef _Pt pointer_type;
	reverse_iterator()
		{}
	explicit reverse_iterator(_RI _X)
		: current(_X) {}
	_RI base() const
		{return (current); }
	_Rt operator*() const
		{return (*(current - 1)); }
	_Pt operator->() const
		{return (&**this); }
	_Myt& operator++()
		{--current;
		return (*this); }
	_Myt operator++(int)
		{_Myt _Tmp = *this;
		--current;
		return (_Tmp); }
	_Myt& operator--()
		{++current;
		return (*this); }
	_Myt operator--(int)
		{_Myt _Tmp = *this;
		++current;
		return (_Tmp); }
	_Myt& operator+=(_D _N)
		{current -= _N;
		return (*this); }
	_Myt operator+(_D _N) const
		{return (_Myt(current - _N)); }
	_Myt& operator-=(_D _N)
		{current += _N;
		return (*this); }
	_Myt operator-(_D _N) const
		{return (_Myt(current + _N)); }
	_Rt operator[](_D _N) const
		{return (*(*this + _N)); }
protected:
	_RI current;
	};
template<class _RI, class _Ty, class _Rt, class _Pt,
	class _D> inline
	bool __cdecl operator==(
		const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _X,
		const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _Y)
	{return (_X.base() == _Y.base()); }
template<class _RI, class _Ty, class _Rt, class _Pt,
	class _D> inline
	bool __cdecl operator!=(
		const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _X,
		const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _Y)
	{return (!(_X == _Y)); }
template<class _RI, class _Ty, class _Rt, class _Pt,
	class _D> inline
	bool __cdecl operator<(
		const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _X,
		const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _Y)
	{return (_Y.base() < _X.base()); }
template<class _RI, class _Ty, class _Rt, class _Pt,
	class _D> inline
	bool __cdecl operator>(
		const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _X,
		const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _Y)
	{return (_Y < _X); }
template<class _RI, class _Ty, class _Rt, class _Pt,
	class _D> inline
	bool __cdecl operator<=(
		const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _X,
		const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _Y)
	{return (!(_Y < _X)); }
template<class _RI, class _Ty, class _Rt, class _Pt,
	class _D> inline
	bool __cdecl operator>=(
		const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _X,
		const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _Y)
	{return (!(_X < _Y)); }
template<class _RI, class _Ty, class _Rt, class _Pt,
	class _D> inline
	_D __cdecl operator-(
		const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _X,
		const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _Y)
	{return (_Y.base() - _X.base()); }
template<class _RI, class _Ty, class _Rt, class _Pt,
	class _D> inline
	reverse_iterator<_RI, _Ty, _Rt, _Pt, _D> __cdecl operator+(_D _N,
		const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _Y)
	{return (reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>(
		_Y.base() - _N)); }
		
template<class _E, class _Tr = char_traits<_E> >
	class istreambuf_iterator
		: public iterator<input_iterator_tag, _E, _Tr::off_type> {
public:
	typedef istreambuf_iterator<_E, _Tr> _Myt;
	typedef _E char_type;
	typedef _Tr traits_type;
	typedef _Tr::int_type int_type;
	typedef basic_streambuf<_E, _Tr> streambuf_type;
	typedef basic_istream<_E, _Tr> istream_type;
	istreambuf_iterator(streambuf_type *_Sb = 0) throw ()
		: _Sbuf(_Sb), _Got(_Sb == 0) {}
	istreambuf_iterator(istream_type& _I) throw ()
		: _Sbuf(_I.rdbuf()), _Got(_I.rdbuf() == 0) {}
	const _E& operator*() const
		{if (!_Got)
			((_Myt *)this)->_Peek();
		return (_Val); }
	const _E *operator->() const
		{return (&**this); }
	_Myt& operator++()
		{_Inc();
		return (*this); }
	_Myt operator++(int)
		{if (!_Got)
			_Peek();
		_Myt _Tmp = *this;
		_Inc();
		return (_Tmp); }
	bool equal(const _Myt& _X) const
		{if (!_Got)
			((_Myt *)this)->_Peek();
		if (!_X._Got)
			((_Myt *)&_X)->_Peek();
		return (_Sbuf == 0 && _X._Sbuf == 0
			|| _Sbuf != 0 && _X._Sbuf != 0); }
private:
	void _Inc()
		{if (_Sbuf == 0
			|| _Tr::eq_int_type(_Tr::eof(), _Sbuf->sbumpc()))
			_Sbuf = 0, _Got = true;
		else
			_Got = false; }
	_E _Peek()
		{int_type _C;
		if (_Sbuf == 0
			|| _Tr::eq_int_type(_Tr::eof(), _C = _Sbuf->sgetc()))
			_Sbuf = 0;
		else
			_Val = _Tr::to_char_type(_C);
		_Got = true;
		return (_Val); }
	streambuf_type *_Sbuf;
	bool _Got;
	_E _Val;
	};
template<class _E, class _Tr> inline
	bool __cdecl operator==(const istreambuf_iterator<_E, _Tr>& _X,
		const istreambuf_iterator<_E, _Tr>& _Y)
	{return (_X.equal(_Y)); }
template<class _E, class _Tr> inline
	bool __cdecl operator!=(const istreambuf_iterator<_E, _Tr>& _X,
		const istreambuf_iterator<_E, _Tr>& _Y)
	{return (!(_X == _Y)); }
		
template<class _E, class _Tr = char_traits<_E> >
	class ostreambuf_iterator
		: public iterator<output_iterator_tag, void, void> {
	typedef ostreambuf_iterator<_E, _Tr> _Myt;
public:
	typedef _E char_type;
	typedef _Tr traits_type;
	typedef basic_streambuf<_E, _Tr> streambuf_type;
	typedef basic_ostream<_E, _Tr> ostream_type;
	ostreambuf_iterator(streambuf_type *_Sb) throw ()
		: _Failed(false), _Sbuf(_Sb) {}
	ostreambuf_iterator(ostream_type& _O) throw ()
		: _Failed(false), _Sbuf(_O.rdbuf()) {}
	_Myt& operator=(_E _X)
		{if (_Sbuf == 0
			|| _Tr::eq_int_type(_Tr::eof(), _Sbuf->sputc(_X)))
			_Failed = true;
		return (*this); }
	_Myt& operator*()
		{return (*this); }
	_Myt& operator++()
		{return (*this); }
	_Myt& operator++(int)
		{return (*this); }
	bool failed() const throw ()
		{return (_Failed); }
private:
	bool _Failed;
	streambuf_type *_Sbuf;
	};
		
	namespace rel_ops {
template<class _Ty> inline
	bool __cdecl operator!=(const _Ty& _X, const _Ty& _Y)
	{return (!(_X == _Y)); }
template<class _Ty> inline
	bool __cdecl operator>(const _Ty& _X, const _Ty& _Y)
	{return (_Y < _X); }
template<class _Ty> inline
	bool __cdecl operator<=(const _Ty& _X, const _Ty& _Y)
	{return (!(_Y < _X)); }
template<class _Ty> inline
	bool __cdecl operator>=(const _Ty& _X, const _Ty& _Y)
	{return (!(_X < _Y)); }
	};
};

#pragma pack(pop)
#line 338 "c:\\programme\\microsoft visual studio\\vc98\\include\\utility"

#line 340 "c:\\programme\\microsoft visual studio\\vc98\\include\\utility"






















#line 16 "c:\\programme\\microsoft visual studio\\vc98\\include\\xmemory"

 
 
 
#line 21 "c:\\programme\\microsoft visual studio\\vc98\\include\\xmemory"
 
 
namespace std {
		
template<class _Ty> inline
	_Ty  *_Allocate(ptrdiff_t _N, _Ty  *)
	{if (_N < 0)
		_N = 0;
	return ((_Ty  *)operator new(
		(size_t)_N * sizeof (_Ty))); }
		
template<class _T1, class _T2> inline
	void _Construct(_T1  *_P, const _T2& _V)
	{new ((void  *)_P) _T1(_V); }
		
template<class _Ty> inline
	void _Destroy(_Ty  *_P)
	{(_P)->~_Ty(); }
inline void _Destroy(char  *_P)
	{}
inline void _Destroy(wchar_t  *_P)
	{}
		
template<class _Ty>
	class allocator {
public:
	typedef size_t size_type;
	typedef ptrdiff_t difference_type;
	typedef _Ty  *pointer;
	typedef const _Ty  *const_pointer;
	typedef _Ty & reference;
	typedef const _Ty & const_reference;
	typedef _Ty value_type;
	pointer address(reference _X) const
		{return (&_X); }
	const_pointer address(const_reference _X) const
		{return (&_X); }
	pointer allocate(size_type _N, const void *)
		{return (_Allocate((difference_type)_N, (pointer)0)); }
	char  *_Charalloc(size_type _N)
		{return (_Allocate((difference_type)_N,
			(char  *)0)); }
	void deallocate(void  *_P, size_type)
		{operator delete(_P); }
	void construct(pointer _P, const _Ty& _V)
		{_Construct(_P, _V); }
	void destroy(pointer _P)
		{_Destroy(_P); }
	size_t max_size() const
		{size_t _N = (size_t)(-1) / sizeof (_Ty);
		return (0 < _N ? _N : 1); }
	};
template<class _Ty, class _U> inline
	bool operator==(const allocator<_Ty>&, const allocator<_U>&)
	{return (true); }
template<class _Ty, class _U> inline
	bool operator!=(const allocator<_Ty>&, const allocator<_U>&)
	{return (false); }
		
template<> class __declspec(dllimport) allocator<void> {
public:
	typedef void _Ty;
	typedef _Ty  *pointer;
	typedef const _Ty  *const_pointer;
	typedef _Ty value_type;
	};
};

#pragma pack(pop)
#line 91 "c:\\programme\\microsoft visual studio\\vc98\\include\\xmemory"

#line 93 "c:\\programme\\microsoft visual studio\\vc98\\include\\xmemory"






















#line 10 "c:\\programme\\microsoft visual studio\\vc98\\include\\xstring"


#pragma pack(push,8)
#line 14 "c:\\programme\\microsoft visual studio\\vc98\\include\\xstring"
 #line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\xutility"



#pragma once
#line 6 "c:\\programme\\microsoft visual studio\\vc98\\include\\xutility"






#pragma pack(push,8)
#line 14 "c:\\programme\\microsoft visual studio\\vc98\\include\\xutility"
namespace std {
		
template<class _II, class _OI> inline
	_OI copy(_II _F, _II _L, _OI _X)
	{for (; _F != _L; ++_X, ++_F)
		*_X = *_F;
	return (_X); }
		
template<class _BI1, class _BI2> inline
	_BI2 copy_backward(_BI1 _F, _BI1 _L, _BI2 _X)
	{while (_F != _L)
		*--_X = *--_L;
	return (_X); }
		
template<class _II1, class _II2> inline
	bool equal(_II1 _F, _II1 _L, _II2 _X)
	{return (mismatch(_F, _L, _X).first == _L); }
		
template<class _II1, class _II2, class _Pr> inline
	bool equal(_II1 _F, _II1 _L, _II2 _X, _Pr _P)
	{return (mismatch(_F, _L, _X, _P).first == _L); }
		
template<class _FI, class _Ty> inline
	void fill(_FI _F, _FI _L, const _Ty& _X)
	{for (; _F != _L; ++_F)
		*_F = _X; }
		
template<class _OI, class _Sz, class _Ty> inline
	void fill_n(_OI _F, _Sz _N, const _Ty& _X)
	{for (; 0 < _N; --_N, ++_F)
		*_F = _X; }
		
template<class _II1, class _II2> inline
	bool lexicographical_compare(_II1 _F1, _II1 _L1,
		_II2 _F2, _II2 _L2)
	{for (; _F1 != _L1 && _F2 != _L2; ++_F1, ++_F2)
		if (*_F1 < *_F2)
			return (true);
		else if (*_F2 < *_F1)
			return (false);
	return (_F1 == _L1 && _F2 != _L2); }
		
template<class _II1, class _II2, class _Pr> inline
	bool lexicographical_compare(_II1 _F1, _II1 _L1,
		_II2 _F2, _II2 _L2, _Pr _P)
	{for (; _F1 != _L1 && _F2 != _L2; ++_F1, ++_F2)
		if (_P(*_F1, *_F2))
			return (true);
		else if (_P(*_F2, *_F1))
			return (false);
	return (_F1 == _L1 && _F2 != _L2); }
		




template<class _Ty> inline
	const _Ty& _cpp_max(const _Ty& _X, const _Ty& _Y)
	{return (_X < _Y ? _Y : _X); }
		
template<class _Ty, class _Pr> inline
	const _Ty& _cpp_max(const _Ty& _X, const _Ty& _Y, _Pr _P)
	{return (_P(_X, _Y) ? _Y : _X); }
		
template<class _Ty> inline
	const _Ty& _cpp_min(const _Ty& _X, const _Ty& _Y)
	{return (_Y < _X ? _Y : _X); }
		
template<class _Ty, class _Pr> inline
	const _Ty& _cpp_min(const _Ty& _X, const _Ty& _Y, _Pr _P)
	{return (_P(_Y, _X) ? _Y : _X); }
		
template<class _II1, class _II2> inline
	pair<_II1, _II2> mismatch(_II1 _F, _II1 _L, _II2 _X)
	{for (; _F != _L && *_F == *_X; ++_F, ++_X)
		;
	return (pair<_II1, _II2>(_F, _X)); }
		
template<class _II1, class _II2, class _Pr> inline
	pair<_II1, _II2> mismatch(_II1 _F, _II1 _L, _II2 _X, _Pr _P)
	{for (; _F != _L && _P(*_F, *_X); ++_F, ++_X)
		;
	return (pair<_II1, _II2>(_F, _X)); }
		
template<class _Ty> inline
	void swap(_Ty& _X, _Ty& _Y)
	{_Ty _Tmp = _X;
	_X = _Y, _Y = _Tmp; }
};

#pragma pack(pop)
#line 106 "c:\\programme\\microsoft visual studio\\vc98\\include\\xutility"

#line 108 "c:\\programme\\microsoft visual studio\\vc98\\include\\xutility"






















#line 15 "c:\\programme\\microsoft visual studio\\vc98\\include\\xstring"
namespace std {
__declspec(dllimport) void __cdecl _Xlen();
__declspec(dllimport) void __cdecl _Xran();
		
template<class _E,
	class _Tr = char_traits<_E>,
	class _A = allocator<_E> >
	class basic_string {
public:
	typedef basic_string<_E, _Tr, _A> _Myt;
	typedef _A::size_type size_type;
	typedef _A::difference_type difference_type;
	typedef _A::pointer pointer;
	typedef _A::const_pointer const_pointer;
	typedef _A::reference reference;
	typedef _A::const_reference const_reference;
	typedef _A::value_type value_type;
	typedef _A::pointer iterator;
	typedef _A::const_pointer const_iterator;
	typedef reverse_iterator<const_iterator, value_type,
		const_reference, const_pointer, difference_type>
			const_reverse_iterator;
	typedef reverse_iterator<iterator, value_type,
		reference, pointer, difference_type>
			reverse_iterator;
	explicit basic_string(const _A& _Al = _A())
		: allocator(_Al) {_Tidy(); }
	basic_string(const _Myt& _X)
		: allocator(_X.allocator)
		{_Tidy(), assign(_X, 0, npos); }
	basic_string(const _Myt& _X, size_type _P, size_type _M,
		const _A& _Al = _A())
		: allocator(_Al) {_Tidy(), assign(_X, _P, _M); }
	basic_string(const _E *_S, size_type _N,
		const _A& _Al = _A())
		: allocator(_Al) {_Tidy(), assign(_S, _N); }
	basic_string(const _E *_S, const _A& _Al = _A())
		: allocator(_Al) {_Tidy(), assign(_S); }
	basic_string(size_type _N, _E _C, const _A& _Al = _A())
		: allocator(_Al) {_Tidy(), assign(_N, _C); }
	typedef const_iterator _It;
	basic_string(_It _F, _It _L, const _A& _Al = _A())
		: allocator(_Al) {_Tidy(); assign(_F, _L); }
	~basic_string()
		{_Tidy(true); }
	typedef _Tr traits_type;
	typedef _A allocator_type;
	enum _Mref {_FROZEN = 255};
	static const size_type npos;
	_Myt& operator=(const _Myt& _X)
		{return (assign(_X)); }
	_Myt& operator=(const _E *_S)
		{return (assign(_S)); }
	_Myt& operator=(_E _C)
		{return (assign(1, _C)); }
	_Myt& operator+=(const _Myt& _X)
		{return (append(_X)); }
	_Myt& operator+=(const _E *_S)
		{return (append(_S)); }
	_Myt& operator+=(_E _C)
		{return (append(1, _C)); }
	_Myt& append(const _Myt& _X)
		{return (append(_X, 0, npos)); }
	_Myt& append(const _Myt& _X, size_type _P, size_type _M)
		{if (_X.size() < _P)
			_Xran();
		size_type _N = _X.size() - _P;
		if (_N < _M)
			_M = _N;
		if (npos - _Len <= _M)
			_Xlen();
		if (0 < _M && _Grow(_N = _Len + _M))
			{_Tr::copy(_Ptr + _Len, &_X.c_str()[_P], _M);
			_Eos(_N); }
		return (*this); }
	_Myt& append(const _E *_S, size_type _M)
		{if (npos - _Len <= _M)
			_Xlen();
		size_type _N;
		if (0 < _M && _Grow(_N = _Len + _M))
			{_Tr::copy(_Ptr + _Len, _S, _M);
			_Eos(_N); }
		return (*this); }
	_Myt& append(const _E *_S)
		{return (append(_S, _Tr::length(_S))); }
	_Myt& append(size_type _M, _E _C)
		{if (npos - _Len <= _M)
			_Xlen();
		size_type _N;
		if (0 < _M && _Grow(_N = _Len + _M))
			{_Tr::assign(_Ptr + _Len, _M, _C);
			_Eos(_N); }
		return (*this); }
	_Myt& append(_It _F, _It _L)
		{return (replace(end(), end(), _F, _L)); }
	_Myt& assign(const _Myt& _X)
		{return (assign(_X, 0, npos)); }
	_Myt& assign(const _Myt& _X, size_type _P, size_type _M)
		{if (_X.size() < _P)
			_Xran();
		size_type _N = _X.size() - _P;
		if (_M < _N)
			_N = _M;
		if (this == &_X)
			erase((size_type)(_P + _N)), erase(0, _P);
		else if (0 < _N && _N == _X.size()
			&& _Refcnt(_X.c_str()) < _FROZEN - 1
			&& allocator == _X.allocator)
			{_Tidy(true);
			_Ptr = (_E *)_X.c_str();
			_Len = _X.size();
			_Res = _X.capacity();
			++_Refcnt(_Ptr); }
		else if (_Grow(_N, true))
			{_Tr::copy(_Ptr, &_X.c_str()[_P], _N);
			_Eos(_N); }
		return (*this); }
	_Myt& assign(const _E *_S, size_type _N)
		{if (_Grow(_N, true))
			{_Tr::copy(_Ptr, _S, _N);
			_Eos(_N); }
		return (*this); }
	_Myt& assign(const _E *_S)
		{return (assign(_S, _Tr::length(_S))); }
	_Myt& assign(size_type _N, _E _C)
		{if (_N == npos)
			_Xlen();
		if (_Grow(_N, true))
			{_Tr::assign(_Ptr, _N, _C);
			_Eos(_N); }
		return (*this); }
	_Myt& assign(_It _F, _It _L)
		{return (replace(begin(), end(), _F, _L)); }
	_Myt& insert(size_type _P0, const _Myt& _X)
		{return (insert(_P0, _X, 0, npos)); }
	_Myt& insert(size_type _P0, const _Myt& _X, size_type _P,
		size_type _M)
		{if (_Len < _P0 || _X.size() < _P)
			_Xran();
		size_type _N = _X.size() - _P;
		if (_N < _M)
			_M = _N;
		if (npos - _Len <= _M)
			_Xlen();
		if (0 < _M && _Grow(_N = _Len + _M))
			{_Tr::move(_Ptr + _P0 + _M, _Ptr + _P0, _Len - _P0);
			_Tr::copy(_Ptr + _P0, &_X.c_str()[_P], _M);
			_Eos(_N); }
		return (*this); }
	_Myt& insert(size_type _P0, const _E *_S, size_type _M)
		{if (_Len < _P0)
			_Xran();
		if (npos - _Len <= _M)
			_Xlen();
		size_type _N;
		if (0 < _M && _Grow(_N = _Len + _M))
			{_Tr::move(_Ptr + _P0 + _M, _Ptr + _P0, _Len - _P0);
			_Tr::copy(_Ptr + _P0, _S, _M);
			_Eos(_N); }
		return (*this); }
	_Myt& insert(size_type _P0, const _E *_S)
		{return (insert(_P0, _S, _Tr::length(_S))); }
	_Myt& insert(size_type _P0, size_type _M, _E _C)
		{if (_Len < _P0)
			_Xran();
		if (npos - _Len <= _M)
			_Xlen();
		size_type _N;
		if (0 < _M && _Grow(_N = _Len + _M))
			{_Tr::move(_Ptr + _P0 + _M, _Ptr + _P0, _Len - _P0);
			_Tr::assign(_Ptr + _P0, _M, _C);
			_Eos(_N); }
		return (*this); }
	iterator insert(iterator _P, _E _C)
		{size_type _P0 = _Pdif(_P, begin());
		insert(_P0, 1, _C);
		return (begin() + _P0); }
	void insert(iterator _P, size_type _M, _E _C)
		{size_type _P0 = _Pdif(_P, begin());
		insert(_P0, _M, _C); }
	void insert(iterator _P, _It _F, _It _L)
		{replace(_P, _P, _F, _L); }
	_Myt& erase(size_type _P0 = 0, size_type _M = npos)
		{if (_Len < _P0)
			_Xran();
		_Split();
		if (_Len - _P0 < _M)
			_M = _Len - _P0;
		if (0 < _M)
			{_Tr::move(_Ptr + _P0, _Ptr + _P0 + _M,
				_Len - _P0 - _M);
			size_type _N = _Len - _M;
			if (_Grow(_N))
				_Eos(_N); }
		return (*this); }
	iterator erase(iterator _P)
		{size_t _M = _Pdif(_P, begin());
		erase(_M, 1);
		return (_Psum(_Ptr, _M)); }
	iterator erase(iterator _F, iterator _L)
		{size_t _M = _Pdif(_F, begin());
		erase(_M, _Pdif(_L, _F));
		return (_Psum(_Ptr, _M)); }
	_Myt& replace(size_type _P0, size_type _N0, const _Myt& _X)
		{return (replace(_P0, _N0, _X, 0, npos)); }
	_Myt& replace(size_type _P0, size_type _N0, const _Myt& _X,
		size_type _P, size_type _M)
		{if (_Len < _P0 || _X.size() < _P)
			_Xran();
		if (_Len - _P0 < _N0)
			_N0 = _Len - _P0;
		size_type _N = _X.size() - _P;
		if (_N < _M)
			_M = _N;
		if (npos - _M <= _Len - _N0)
			_Xlen();
		_Split();
		size_type _Nm = _Len - _N0 - _P0;
		if (_M < _N0)
			_Tr::move(_Ptr + _P0 + _M, _Ptr + _P0 + _N0, _Nm);
		if ((0 < _M || 0 < _N0) && _Grow(_N = _Len + _M - _N0))
			{if (_N0 < _M)
				_Tr::move(_Ptr + _P0 + _M, _Ptr + _P0 + _N0, _Nm);
			_Tr::copy(_Ptr + _P0, &_X.c_str()[_P], _M);
			_Eos(_N); }
		return (*this); }
	_Myt& replace(size_type _P0, size_type _N0, const _E *_S,
		size_type _M)
		{if (_Len < _P0)
			_Xran();
		if (_Len - _P0 < _N0)
			_N0 = _Len - _P0;
		if (npos - _M <= _Len - _N0)
			_Xlen();
		_Split();
		size_type _Nm = _Len - _N0 - _P0;
		if (_M < _N0)
			_Tr::move(_Ptr + _P0 + _M, _Ptr + _P0 + _N0, _Nm);
		size_type _N;
		if ((0 < _M || 0 < _N0) && _Grow(_N = _Len + _M - _N0))
			{if (_N0 < _M)
				_Tr::move(_Ptr + _P0 + _M, _Ptr + _P0 + _N0, _Nm);
			_Tr::copy(_Ptr + _P0, _S, _M);
			_Eos(_N); }
		return (*this); }
	_Myt& replace(size_type _P0, size_type _N0, const _E *_S)
		{return (replace(_P0, _N0, _S, _Tr::length(_S))); }
	_Myt& replace(size_type _P0, size_type _N0,
		size_type _M, _E _C)
		{if (_Len < _P0)
			_Xran();
		if (_Len - _P0 < _N0)
			_N0 = _Len - _P0;
		if (npos - _M <= _Len - _N0)
			_Xlen();
		_Split();
		size_type _Nm = _Len - _N0 - _P0;
		if (_M < _N0)
			_Tr::move(_Ptr + _P0 + _M, _Ptr + _P0 + _N0, _Nm);
		size_type _N;
		if ((0 < _M || 0 < _N0) && _Grow(_N = _Len + _M - _N0))
			{if (_N0 < _M)
				_Tr::move(_Ptr + _P0 + _M, _Ptr + _P0 + _N0,
					_Nm);
			_Tr::assign(_Ptr + _P0, _M, _C);
			_Eos(_N); }
		return (*this); }
	_Myt& replace(iterator _F, iterator _L, const _Myt& _X)
		{return (replace(
			_Pdif(_F, begin()), _Pdif(_L, _F), _X)); }
	_Myt& replace(iterator _F, iterator _L, const _E *_S,
		size_type _M)
		{return (replace(
			_Pdif(_F, begin()), _Pdif(_L, _F), _S, _M)); }
	_Myt& replace(iterator _F, iterator _L, const _E *_S)
		{return (replace(
			_Pdif(_F, begin()), _Pdif(_L, _F), _S)); }
	_Myt& replace(iterator _F, iterator _L,	size_type _M, _E _C)
		{return (replace(
			_Pdif(_F, begin()), _Pdif(_L, _F), _M, _C)); }
	_Myt& replace(iterator _F1, iterator _L1,
		_It _F2, _It _L2)
		{size_type _P0 = _Pdif(_F1, begin());
		size_type _M = 0;
		_Distance(_F2, _L2, _M);
		replace(_P0, _Pdif(_L1, _F1), _M, _E(0));
		for (_F1 = begin() + _P0; 0 < _M; ++_F1, ++_F2, --_M)
			*_F1 = *_F2;
		return (*this); }
	iterator begin()
		{_Freeze();
		return (_Ptr); }
	const_iterator begin() const
		{return (_Ptr); }
	iterator end()
		{_Freeze();
		return ((iterator)_Psum(_Ptr, _Len)); }
	const_iterator end() const
		{return ((const_iterator)_Psum(_Ptr, _Len)); }
	reverse_iterator rbegin()
		{return (reverse_iterator(end())); }
	const_reverse_iterator rbegin() const
		{return (const_reverse_iterator(end())); }
	reverse_iterator rend()
		{return (reverse_iterator(begin())); }
	const_reverse_iterator rend() const
		{return (const_reverse_iterator(begin())); }
	reference at(size_type _P0)
		{if (_Len <= _P0)
			_Xran();
		_Freeze();
		return (_Ptr[_P0]); }
	const_reference at(size_type _P0) const
		{if (_Len <= _P0)
			_Xran();
		return (_Ptr[_P0]); }
	reference operator[](size_type _P0)
		{if (_Len < _P0 || _Ptr == 0)
			return ((reference)*_Nullstr());
		_Freeze();
		return (_Ptr[_P0]); }
	const_reference operator[](size_type _P0) const
		{if (_Ptr == 0)
			return (*_Nullstr());
		else
			return (_Ptr[_P0]); }
	const _E *c_str() const
		{return (_Ptr == 0 ? _Nullstr() : _Ptr); }
	const _E *data() const
		{return (c_str()); }
	size_type length() const
		{return (_Len); }
	size_type size() const
		{return (_Len); }
	size_type max_size() const
		{size_type _N = allocator.max_size();
		return (_N <= 2 ? 1 : _N - 2); }
	void resize(size_type _N, _E _C)
		{_N <= _Len ? erase(_N) : append(_N - _Len, _C); }
	void resize(size_type _N)
		{_N <= _Len ? erase(_N) : append(_N - _Len, _E(0)); }
	size_type capacity() const
		{return (_Res); }
	void reserve(size_type _N = 0)
		{if (_Res < _N)
			_Grow(_N); }
	bool empty() const
		{return (_Len == 0); }
	size_type copy(_E *_S, size_type _N, size_type _P0 = 0) const
		{if (_Len < _P0)
			_Xran();
		if (_Len - _P0 < _N)
			_N = _Len - _P0;
		if (0 < _N)
			_Tr::copy(_S, _Ptr + _P0, _N);
		return (_N); }
	void swap(_Myt& _X)
		{if (allocator == _X.allocator)
			{std::swap(_Ptr, _X._Ptr);
			std::swap(_Len, _X._Len);
			std::swap(_Res, _X._Res); }
		else
			{_Myt _Ts = *this; *this = _X, _X = _Ts; }}
	friend void swap(_Myt& _X, _Myt& _Y)
		{_X.swap(_Y); }
	size_type find(const _Myt& _X, size_type _P = 0) const
		{return (find(_X.c_str(), _P, _X.size())); }
	size_type find(const _E *_S, size_type _P,
		size_type _N) const
		{if (_N == 0 && _P <= _Len)
			return (_P);
		size_type _Nm;
		if (_P < _Len && _N <= (_Nm = _Len - _P))
			{const _E *_U, *_V;
			for (_Nm -= _N - 1, _V = _Ptr + _P;
				(_U = _Tr::find(_V, _Nm, *_S)) != 0;
				_Nm -= _U - _V + 1, _V = _U + 1)
				if (_Tr::compare(_U, _S, _N) == 0)
					return (_U - _Ptr); }
		return (npos); }
	size_type find(const _E *_S, size_type _P = 0) const
		{return (find(_S, _P, _Tr::length(_S))); }
	size_type find(_E _C, size_type _P = 0) const
		{return (find((const _E *)&_C, _P, 1)); }
	size_type rfind(const _Myt& _X, size_type _P = npos) const
		{return (rfind(_X.c_str(), _P, _X.size())); }
	size_type rfind(const _E *_S, size_type _P,
		size_type _N) const
		{if (_N == 0)
			return (_P < _Len ? _P : _Len);
		if (_N <= _Len)
			for (const _E *_U = _Ptr +
				+ (_P < _Len - _N ? _P : _Len - _N); ; --_U)
				if (_Tr::eq(*_U, *_S)
					&& _Tr::compare(_U, _S, _N) == 0)
					return (_U - _Ptr);
				else if (_U == _Ptr)
					break;
		return (npos); }
	size_type rfind(const _E *_S, size_type _P = npos) const
		{return (rfind(_S, _P, _Tr::length(_S))); }
	size_type rfind(_E _C, size_type _P = npos) const
		{return (rfind((const _E *)&_C, _P, 1)); }
	size_type find_first_of(const _Myt& _X,
		size_type _P = 0) const
		{return (find_first_of(_X.c_str(), _P, _X.size())); }
	size_type find_first_of(const _E *_S, size_type _P,
		size_type _N) const
		{if (0 < _N && _P < _Len)
			{const _E *const _V = _Ptr + _Len;
			for (const _E *_U = _Ptr + _P; _U < _V; ++_U)
				if (_Tr::find(_S, _N, *_U) != 0)
					return (_U - _Ptr); }
		return (npos); }
	size_type find_first_of(const _E *_S, size_type _P = 0) const
		{return (find_first_of(_S, _P, _Tr::length(_S))); }
	size_type find_first_of(_E _C, size_type _P = 0) const
		{return (find((const _E *)&_C, _P, 1)); }
	size_type find_last_of(const _Myt& _X,
		size_type _P = npos) const
		{return (find_last_of(_X.c_str(), _P, _X.size())); }
	size_type find_last_of(const _E *_S, size_type _P,
		size_type _N) const
		{if (0 < _N && 0 < _Len)
			for (const _E *_U = _Ptr
				+ (_P < _Len ? _P : _Len - 1); ; --_U)
				if (_Tr::find(_S, _N, *_U) != 0)
					return (_U - _Ptr);
				else if (_U == _Ptr)
					break;
		return (npos); }
	size_type find_last_of(const _E *_S,
		size_type _P = npos) const
		{return (find_last_of(_S, _P, _Tr::length(_S))); }
	size_type find_last_of(_E _C, size_type _P = npos) const
		{return (rfind((const _E *)&_C, _P, 1)); }
	size_type find_first_not_of(const _Myt& _X,
		size_type _P = 0) const
		{return (find_first_not_of(_X.c_str(), _P,
			_X.size())); }
	size_type find_first_not_of(const _E *_S, size_type _P,
		size_type _N) const
		{if (_P < _Len)
			{const _E *const _V = _Ptr + _Len;
			for (const _E *_U = _Ptr + _P; _U < _V; ++_U)
				if (_Tr::find(_S, _N, *_U) == 0)
					return (_U - _Ptr); }
		return (npos); }
	size_type find_first_not_of(const _E *_S,
		size_type _P = 0) const
		{return (find_first_not_of(_S, _P, _Tr::length(_S))); }
	size_type find_first_not_of(_E _C, size_type _P = 0) const
		{return (find_first_not_of((const _E *)&_C, _P, 1)); }
	size_type find_last_not_of(const _Myt& _X,
		size_type _P = npos) const
		{return (find_last_not_of(_X.c_str(), _P, _X.size())); }
	size_type find_last_not_of(const _E *_S, size_type _P,
		 size_type _N) const
		{if (0 < _Len)
			for (const _E *_U = _Ptr
				+ (_P < _Len ? _P : _Len - 1); ; --_U)
				if (_Tr::find(_S, _N, *_U) == 0)
					return (_U - _Ptr);
				else if (_U == _Ptr)
					break;
		return (npos); }
	size_type find_last_not_of(const _E *_S,
		size_type _P = npos) const
		{return (find_last_not_of(_S, _P, _Tr::length(_S))); }
	size_type find_last_not_of(_E _C, size_type _P = npos) const
		{return (find_last_not_of((const _E *)&_C, _P, 1)); }
	_Myt substr(size_type _P = 0, size_type _M = npos) const
		{return (_Myt(*this, _P, _M)); }
	int compare(const _Myt& _X) const
		{return (compare(0, _Len, _X.c_str(), _X.size())); }
	int compare(size_type _P0, size_type _N0,
		const _Myt& _X) const
		{return (compare(_P0, _N0, _X, 0, npos)); }
	int compare(size_type _P0, size_type _N0, const _Myt& _X,
		size_type _P, size_type _M) const
		{if (_X.size() < _P)
			_Xran();
		if (_X._Len - _P < _M)
			_M = _X._Len - _P;
		return (compare(_P0, _N0, _X.c_str() + _P, _M)); }
	int compare(const _E *_S) const
		{return (compare(0, _Len, _S, _Tr::length(_S))); }
	int compare(size_type _P0, size_type _N0, const _E *_S) const
		{return (compare(_P0, _N0, _S, _Tr::length(_S))); }
	int compare(size_type _P0, size_type _N0, const _E *_S,
		size_type _M) const
		{if (_Len < _P0)
			_Xran();
		if (_Len - _P0 < _N0)
			_N0 = _Len - _P0;
		size_type _Ans = _Tr::compare(_Psum(_Ptr, _P0), _S,
			_N0 < _M ? _N0 : _M);
		return (_Ans != 0 ? _Ans : _N0 < _M ? -1
			: _N0 == _M ? 0 : +1); }
	_A get_allocator() const
		{return (allocator); }
protected:
	_A allocator;
private:
	enum {_MIN_SIZE = sizeof (_E) <= 32 ? 31 : 7};
	void _Copy(size_type _N)
		{size_type _Ns = _N | _MIN_SIZE;
		if (max_size() < _Ns)
			_Ns = _N;
		_E *_S;
		try {
			_S = allocator.allocate(_Ns + 2, (void *)0);
		} catch (...) {
			_Ns = _N;
			_S = allocator.allocate(_Ns + 2, (void *)0);
		}
		if (0 < _Len)
			_Tr::copy(_S + 1, _Ptr,_Len>_Ns?_Ns:_Len);
		size_type _Olen = _Len;
		_Tidy(true);
		_Ptr = _S + 1;
		_Refcnt(_Ptr) = 0;
		_Res = _Ns;
		_Eos(_Olen>_Ns?_Ns:_Olen); }
	void _Eos(size_type _N)
		{_Tr::assign(_Ptr[_Len = _N], _E(0)); }
	void _Freeze()
		{if (_Ptr != 0
			&& _Refcnt(_Ptr) != 0 && _Refcnt(_Ptr) != _FROZEN)
			_Grow(_Len);
		if (_Ptr != 0)
			_Refcnt(_Ptr) = _FROZEN; }
	bool _Grow(size_type _N, bool _Trim = false)
		{if (max_size() < _N)
			_Xlen();
		if (_Ptr != 0
			&& _Refcnt(_Ptr) != 0 && _Refcnt(_Ptr) != _FROZEN)
			if (_N == 0)
				{--_Refcnt(_Ptr), _Tidy();
				return (false); }
			else
				{_Copy(_N);
				return (true); }
		if (_N == 0)
			{if (_Trim)
				_Tidy(true);
			else if (_Ptr != 0)
				_Eos(0);
			return (false); }
		else
			{if (_Trim && (_MIN_SIZE < _Res || _Res < _N))
				{_Tidy(true);
				_Copy(_N); }
			else if (!_Trim && _Res < _N)
				_Copy(_N);
			return (true); }}
	static const _E * __cdecl _Nullstr()
		{static const _E _C = _E(0);
		return (&_C); }
	static size_type _Pdif(const_pointer _P2, const_pointer _P1)
		{return (_P2 == 0 ? 0 : _P2 - _P1); }
	static const_pointer _Psum(const_pointer _P, size_type _N)
		{return (_P == 0 ? 0 : _P + _N); }
	static pointer _Psum(pointer _P, size_type _N)
		{return (_P == 0 ? 0 : _P + _N); }
	unsigned char& _Refcnt(const _E *_U)
		{return (((unsigned char *)_U)[-1]); }
	void _Split()
		{if (_Ptr != 0 && _Refcnt(_Ptr) != 0 && _Refcnt(_Ptr) != _FROZEN)
			{_E *_Temp = _Ptr;
			_Tidy(true);
			assign(_Temp); }}
	void _Tidy(bool _Built = false)
		{if (!_Built || _Ptr == 0)
			;
		else if (_Refcnt(_Ptr) == 0 || _Refcnt(_Ptr) == _FROZEN)
			allocator.deallocate(_Ptr - 1, _Res + 2);
		else
			--_Refcnt(_Ptr);
		_Ptr = 0, _Len = 0, _Res = 0; }
	_E *_Ptr;
	size_type _Len, _Res;
	};
template<class _E, class _Tr, class _A>
	const basic_string<_E, _Tr, _A>::size_type
		basic_string<_E, _Tr, _A>::npos = -1;


#pragma warning(disable:4231) 

extern template class __declspec(dllimport) basic_string<char, char_traits<char>, allocator<char> >;
extern template class __declspec(dllimport) basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >;

#pragma warning(default:4231) 
#line 610 "c:\\programme\\microsoft visual studio\\vc98\\include\\xstring"

typedef basic_string<char, char_traits<char>, allocator<char> >
	string;

typedef basic_string<wchar_t, char_traits<wchar_t>,
	allocator<wchar_t> > wstring;

};

#pragma pack(pop)
#line 621 "c:\\programme\\microsoft visual studio\\vc98\\include\\xstring"

#line 623 "c:\\programme\\microsoft visual studio\\vc98\\include\\xstring"





#line 11 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdexcept"


#pragma pack(push,8)
#line 15 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdexcept"
namespace std {
		
class __declspec(dllimport) logic_error : public exception {
public:
	explicit logic_error(const string& _S)
		: exception(""), _Str(_S) {}
	virtual ~logic_error()
		{}
	virtual const char *what() const
		{return (_Str.c_str()); }
protected:
	virtual void _Doraise() const
		{throw (*this); }
private:
	string _Str;
	};
		
class __declspec(dllimport) domain_error : public logic_error {
public:
	explicit domain_error(const string& _S)
		: logic_error(_S) {}
	virtual ~domain_error()
		{}
protected:
	virtual void _Doraise() const
		{throw (*this); }
	};
		
class invalid_argument : public logic_error {
public:
	explicit invalid_argument(const string& _S)
		: logic_error(_S) {}
	virtual ~invalid_argument()
		{}
protected:
	virtual void _Doraise() const
		{throw (*this); }
	};
		
class __declspec(dllimport) length_error : public logic_error {
public:
	explicit length_error(const string& _S)
		: logic_error(_S) {}
	virtual ~length_error()
		{}
protected:
	virtual void _Doraise() const
		{throw (*this); }
	};
		
class __declspec(dllimport) out_of_range : public logic_error {
public:
	explicit out_of_range(const string& _S)
		: logic_error(_S) {}
	virtual ~out_of_range()
		{}
protected:
	virtual void _Doraise() const
		{throw (*this); }
	};
		
class __declspec(dllimport) runtime_error : public exception {
public:
	explicit runtime_error(const string& _S)
		: exception(""), _Str(_S) {}
	virtual ~runtime_error()
		{}
	virtual const char *what() const
		{return (_Str.c_str()); }
protected:
	virtual void _Doraise() const
		{throw (*this); }
private:
	string _Str;
	};
		
class __declspec(dllimport) overflow_error : public runtime_error {
public:
	explicit overflow_error(const string& _S)
		: runtime_error(_S) {}
	virtual ~overflow_error()
		{}
protected:
	virtual void _Doraise() const
		{throw (*this); }
	};
		
class __declspec(dllimport) underflow_error : public runtime_error {
public:
	explicit underflow_error(const string& _S)
		: runtime_error(_S) {}
	virtual ~underflow_error()
		{}
protected:
	virtual void _Doraise() const
		{throw (*this); }
	};
		
class __declspec(dllimport) range_error : public runtime_error {
public:
	explicit range_error(const string& _S)
		: runtime_error(_S) {}
	virtual ~range_error()
		{}
protected:
	virtual void _Doraise() const
		{throw (*this); }
	};
};

#pragma pack(pop)
#line 127 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdexcept"

#line 129 "c:\\programme\\microsoft visual studio\\vc98\\include\\stdexcept"





#line 12 "c:\\programme\\microsoft visual studio\\vc98\\include\\xlocale"
#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\typeinfo"
















#pragma once
#line 19 "c:\\programme\\microsoft visual studio\\vc98\\include\\typeinfo"








 

#line 30 "c:\\programme\\microsoft visual studio\\vc98\\include\\typeinfo"





















#pragma pack(push,8)
#line 53 "c:\\programme\\microsoft visual studio\\vc98\\include\\typeinfo"

class type_info {
public:
    __declspec(dllimport) virtual ~type_info();
    __declspec(dllimport) int operator==(const type_info& rhs) const;
    __declspec(dllimport) int operator!=(const type_info& rhs) const;
    __declspec(dllimport) int before(const type_info& rhs) const;
    __declspec(dllimport) const char* name() const;
    __declspec(dllimport) const char* raw_name() const;
private:
    void *_m_data;
    char _m_d_name[1];
    type_info(const type_info& rhs);
    type_info& operator=(const type_info& rhs);
};



 

 namespace std {
		
class __declspec(dllimport) bad_cast : public exception {
public:
	bad_cast(const char *_S = "bad cast") throw ()
		: exception(_S) {}
	virtual ~bad_cast() throw ()
		{}
protected:
	virtual void _Doraise() const
		{throw (*this); }
	};
		
class __declspec(dllimport) bad_typeid : public exception {
public:
	bad_typeid(const char *_S = "bad typeid") throw ()
		: exception(_S) {}
	virtual ~bad_typeid() throw ()
		{}
protected:
	virtual void _Doraise() const
		{throw (*this); }
	};

class __declspec(dllimport) __non_rtti_object : public bad_typeid {
public:
    __non_rtti_object(const char * what_arg) : bad_typeid(what_arg) {}
};
using ::type_info;
 };
using std::__non_rtti_object;









#pragma pack(pop)
#line 115 "c:\\programme\\microsoft visual studio\\vc98\\include\\typeinfo"

#line 117 "c:\\programme\\microsoft visual studio\\vc98\\include\\typeinfo"






#line 13 "c:\\programme\\microsoft visual studio\\vc98\\include\\xlocale"
#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\xlocinfo"



#pragma once
#line 6 "c:\\programme\\microsoft visual studio\\vc98\\include\\xlocinfo"



#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\xlocinfo.h"



#pragma once
#line 6 "c:\\programme\\microsoft visual studio\\vc98\\include\\xlocinfo.h"



#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\ctype.h"














#pragma once
#line 17 "c:\\programme\\microsoft visual studio\\vc98\\include\\ctype.h"






#line 24 "c:\\programme\\microsoft visual studio\\vc98\\include\\ctype.h"



extern "C" {
#line 29 "c:\\programme\\microsoft visual studio\\vc98\\include\\ctype.h"


















#line 48 "c:\\programme\\microsoft visual studio\\vc98\\include\\ctype.h"


























#line 75 "c:\\programme\\microsoft visual studio\\vc98\\include\\ctype.h"



__declspec(dllimport) extern unsigned short _ctype[];
__declspec(dllimport) extern unsigned short *_pctype;

__declspec(dllimport) extern wctype_t *_pwctype;
#line 83 "c:\\programme\\microsoft visual studio\\vc98\\include\\ctype.h"
#line 84 "c:\\programme\\microsoft visual studio\\vc98\\include\\ctype.h"








                                













__declspec(dllimport) int __cdecl _isctype(int, int);
__declspec(dllimport) int __cdecl isalpha(int);
__declspec(dllimport) int __cdecl isupper(int);
__declspec(dllimport) int __cdecl islower(int);
__declspec(dllimport) int __cdecl isdigit(int);
__declspec(dllimport) int __cdecl isxdigit(int);
__declspec(dllimport) int __cdecl isspace(int);
__declspec(dllimport) int __cdecl ispunct(int);
__declspec(dllimport) int __cdecl isalnum(int);
__declspec(dllimport) int __cdecl isprint(int);
__declspec(dllimport) int __cdecl isgraph(int);
__declspec(dllimport) int __cdecl iscntrl(int);
__declspec(dllimport) int __cdecl toupper(int);
__declspec(dllimport) int __cdecl tolower(int);
__declspec(dllimport) int __cdecl _tolower(int);
__declspec(dllimport) int __cdecl _toupper(int);
__declspec(dllimport) int __cdecl __isascii(int);
__declspec(dllimport) int __cdecl __toascii(int);
__declspec(dllimport) int __cdecl __iscsymf(int);
__declspec(dllimport) int __cdecl __iscsym(int);

#line 128 "c:\\programme\\microsoft visual studio\\vc98\\include\\ctype.h"


































#line 163 "c:\\programme\\microsoft visual studio\\vc98\\include\\ctype.h"
























































































#line 252 "c:\\programme\\microsoft visual studio\\vc98\\include\\ctype.h"

#line 254 "c:\\programme\\microsoft visual studio\\vc98\\include\\ctype.h"

















































#line 304 "c:\\programme\\microsoft visual studio\\vc98\\include\\ctype.h"
















#line 321 "c:\\programme\\microsoft visual studio\\vc98\\include\\ctype.h"

#line 323 "c:\\programme\\microsoft visual studio\\vc98\\include\\ctype.h"


}
#line 327 "c:\\programme\\microsoft visual studio\\vc98\\include\\ctype.h"


#line 330 "c:\\programme\\microsoft visual studio\\vc98\\include\\ctype.h"
#line 10 "c:\\programme\\microsoft visual studio\\vc98\\include\\xlocinfo.h"
#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\locale.h"














#pragma once
#line 17 "c:\\programme\\microsoft visual studio\\vc98\\include\\locale.h"






#line 24 "c:\\programme\\microsoft visual studio\\vc98\\include\\locale.h"







#pragma pack(push,8)
#line 33 "c:\\programme\\microsoft visual studio\\vc98\\include\\locale.h"


extern "C" {
#line 37 "c:\\programme\\microsoft visual studio\\vc98\\include\\locale.h"


















#line 56 "c:\\programme\\microsoft visual studio\\vc98\\include\\locale.h"

















#line 74 "c:\\programme\\microsoft visual studio\\vc98\\include\\locale.h"



























struct lconv {
        char *decimal_point;
        char *thousands_sep;
        char *grouping;
        char *int_curr_symbol;
        char *currency_symbol;
        char *mon_decimal_point;
        char *mon_thousands_sep;
        char *mon_grouping;
        char *positive_sign;
        char *negative_sign;
        char int_frac_digits;
        char frac_digits;
        char p_cs_precedes;
        char p_sep_by_space;
        char n_cs_precedes;
        char n_sep_by_space;
        char p_sign_posn;
        char n_sign_posn;
        };

#line 123 "c:\\programme\\microsoft visual studio\\vc98\\include\\locale.h"












__declspec(dllimport) char * __cdecl setlocale(int, const char *);
__declspec(dllimport) struct lconv * __cdecl localeconv(void);










#line 148 "c:\\programme\\microsoft visual studio\\vc98\\include\\locale.h"


}
#line 152 "c:\\programme\\microsoft visual studio\\vc98\\include\\locale.h"


#pragma pack(pop)
#line 156 "c:\\programme\\microsoft visual studio\\vc98\\include\\locale.h"

#line 158 "c:\\programme\\microsoft visual studio\\vc98\\include\\locale.h"
#line 11 "c:\\programme\\microsoft visual studio\\vc98\\include\\xlocinfo.h"






		











		



















typedef struct _Collvec {
	unsigned long _Hand;	
	unsigned int _Page;		
	} _Collvec;

typedef struct _Ctypevec {
	unsigned long _Hand;	
	unsigned int _Page;		
	const short *_Table;
	int _Delfl;
	} _Ctypevec;

typedef struct _Cvtvec {
	unsigned long _Hand;	
	unsigned int _Page;		
	} _Cvtvec;

		
extern "C" {
__declspec(dllimport) _Collvec __cdecl _Getcoll();
__declspec(dllimport) _Ctypevec __cdecl _Getctype();
__declspec(dllimport) _Cvtvec __cdecl _Getcvt();
char *__cdecl _Getdays();
char *__cdecl _Getmonths();
void *__cdecl _Gettnames();
__declspec(dllimport) int __cdecl _Mbrtowc(wchar_t *, const char *, size_t,
	mbstate_t *, const _Cvtvec *);
extern float __cdecl _Stof(const char *, char **, long);
extern double __cdecl _Stod(const char *, char **, long);
extern long double __cdecl _Stold(const char *, char **, long);
__declspec(dllimport) int __cdecl _Strcoll(const char *, const char *,
	const char *, const char *, const _Collvec *);
size_t __cdecl _Strftime(char *, size_t, const char *,
	const struct tm *, void *);
__declspec(dllimport) size_t __cdecl _Strxfrm(char *, char *,
	const char *, const char *, const _Collvec *);
__declspec(dllimport) int __cdecl _Tolower(int, const _Ctypevec *);
__declspec(dllimport) int __cdecl _Toupper(int, const _Ctypevec *);
__declspec(dllimport) int __cdecl _Wcrtomb(char *, wchar_t, mbstate_t *,
	const _Cvtvec *);
__declspec(dllimport) int __cdecl _Wcscoll(const wchar_t *, const wchar_t *,
	const wchar_t *, const wchar_t *, const _Collvec *);
__declspec(dllimport) size_t __cdecl _Wcsxfrm(wchar_t *, wchar_t *,
	const wchar_t *, const wchar_t *, const _Collvec *);
}
#line 95 "c:\\programme\\microsoft visual studio\\vc98\\include\\xlocinfo.h"





#line 10 "c:\\programme\\microsoft visual studio\\vc98\\include\\xlocinfo"




#pragma pack(push,8)
#line 16 "c:\\programme\\microsoft visual studio\\vc98\\include\\xlocinfo"
namespace std {

		
class __declspec(dllimport) _Timevec {
public:
	_Timevec(void *_P = 0)
		: _Ptr(_P) {}
	_Timevec(const _Timevec& _Rhs)
		{*this = _Rhs; }
	~_Timevec()
		{free(_Ptr); }
	_Timevec& operator=(const _Timevec& _Rhs)
		{_Ptr = _Rhs._Ptr;
		((_Timevec *)&_Rhs)->_Ptr = 0;
		return (*this); }
	void *_Getptr() const
		{return (_Ptr); }
private:
	void *_Ptr;
	};
		
class __declspec(dllimport) _Locinfo {
public:
	typedef ::_Collvec _Collvec;
	typedef ::_Ctypevec _Ctypevec;
	typedef ::_Cvtvec _Cvtvec;
	typedef std::_Timevec _Timevec;
	_Locinfo(const char * = "C");
	_Locinfo(int, const char *);
	~_Locinfo();
	_Locinfo& _Addcats(int, const char *);
	string _Getname() const
		{return (_Nname); }
	_Collvec _Getcoll() const
		{return (::_Getcoll()); }
	_Ctypevec _Getctype() const
		{return (::_Getctype()); }
	_Cvtvec _Getcvt() const
		{return (::_Getcvt()); }
	const lconv *_Getlconv() const
		{return (localeconv()); }
	_Timevec _Gettnames() const
		{return (_Timevec(::_Gettnames())); }
	const char *_Getdays() const
		{char *_S = ::_Getdays();
		if (_S != 0)
			{((_Locinfo *)this)->_Days = _S, free(_S); }
		return (_Days.size() != 0 ? _Days.c_str()
				: ":Sun:Sunday:Mon:Monday:Tue:Tuesday"
				":Wed:Wednesday:Thu:Thursday:Fri:Friday"
				":Sat:Saturday"); }
	const char *_Getmonths() const
		{char *_S = ::_Getmonths();
		if (_S != 0)
			{((_Locinfo *)this)->_Months = _S, free(_S); }
		return (_Months.size() != 0 ? _Months.c_str()
				: ":Jan:January:Feb:February:Mar:March"
				":Apr:April:May:May:Jun:June"
				":Jul:July:Aug:August:Sep:September"
				":Oct:October:Nov:November:Dec:December"); }
	const char *_Getfalse() const
		{return ("false"); }
	const char *_Gettrue() const
		{return ("true"); }
	const char *_Getno() const
		{return ("no"); }
	const char *_Getyes() const
		{return ("yes"); }
private:
	string _Days, _Months, _Oname, _Nname;
	};
		
template<class _E> inline
	int __cdecl _Strcoll(const _E *_F1, const _E *_L1,
		const _E *_F2, const _E *_L2, const _Locinfo::_Collvec *)
	{for (; _F1 != _L1 && _F2 != _L2; ++_F1, ++_F2)
		if (*_F1 < *_F2)
			return (-1);
		else if (*_F2 < *_F1)
			return (+1);
	return (_F2 != _L2 ? -1 : _F1 != _L1 ? +1 : 0); }
template<class _E> inline
	size_t __cdecl _Strxfrm(_E *_F1, _E *_L1,
		const _E *_F2, const _E *_L2, const _Locinfo::_Collvec *)
	{size_t _N = _L2 - _F2;
	if (_N <= _L1 - _F1)
		memcpy(_F1, _F2, _N * sizeof (_E));
	return (_N); }
};

#pragma pack(pop)
#line 108 "c:\\programme\\microsoft visual studio\\vc98\\include\\xlocinfo"

#line 110 "c:\\programme\\microsoft visual studio\\vc98\\include\\xlocinfo"





#line 14 "c:\\programme\\microsoft visual studio\\vc98\\include\\xlocale"


#pragma pack(push,8)
#line 18 "c:\\programme\\microsoft visual studio\\vc98\\include\\xlocale"
namespace std {
                
class __declspec(dllimport) locale {
public:
        enum _Category {collate = ((1 << (1)) >> 1), ctype = ((1 << (2)) >> 1),
                monetary = ((1 << (3)) >> 1), numeric = ((1 << (4)) >> 1),
                time = ((1 << (5)) >> 1), messages = ((1 << (6)) >> 1),
                all = (((1 << (7)) >> 1) - 1), none = 0};
        typedef int category;
                        
        class __declspec(dllimport) id {
        public:
                operator size_t()
                        {_Lockit _Lk;
                        if (_Id == 0)
                                _Id = ++_Id_cnt;
                        return (_Id); }
        private:
                size_t _Id;
                static int _Id_cnt;
                };
        class _Locimp;
                        
        class __declspec(dllimport) facet {
                friend class locale;
                friend class _Locimp;
        public:
                static size_t __cdecl _Getcat()
                        {return ((size_t)(-1)); }
                void _Incref()
                        {_Lockit _Lk;
                        if (_Refs < (size_t)(-1))
                                ++_Refs; }
                facet *_Decref()
                        {_Lockit _Lk;
                        if (0 < _Refs && _Refs < (size_t)(-1))
                                --_Refs;
                        return (_Refs == 0 ? this : 0); }
        public:
                virtual ~facet()
                        {}
        protected:
                explicit facet(size_t _R = 0)
                        : _Refs(_R) {}
        private:
                facet(const facet&);    
                const facet& operator=(const facet&);   
                size_t _Refs;
                };
                        
        class _Locimp : public facet {
        public:
                ~_Locimp();
        private:
                friend class locale;
                _Locimp(bool _Xp = false);
                _Locimp(const _Locimp&);
                void _Addfac(facet *, size_t);
                static _Locimp *__cdecl _Makeloc(const _Locinfo&,
                        category, _Locimp *, const locale *);
                static void __cdecl _Makewloc(const _Locinfo&,
                        category, _Locimp *, const locale *);
                static void __cdecl _Makexloc(const _Locinfo&,
                        category, _Locimp *, const locale *);
                facet **_Fv;
                size_t _Nfv;
                category _Cat;
                bool _Xpar;
                string _Name;
                static __declspec(dllimport) _Locimp *_Clocptr, *_Global;
                };
        locale& _Addfac(facet *, size_t, size_t);
        bool operator()(const string&, const string&) const;
        locale() throw ()
                : _Ptr(_Init())
                {_Lockit _lk;
                _Locimp::_Global->_Incref(); }
        locale(_Uninitialized)
                {}
        locale(const locale& _X) throw ()
                : _Ptr(_X._Ptr)
                {_Ptr->_Incref(); }
        locale(const locale&, const locale&, category);
        explicit locale(const char *, category = all);
        locale(const locale&, const char *, category);
        ~locale() throw ()
                {if (_Ptr != 0)
                        delete _Ptr->_Decref(); }
        locale& operator=(const locale& _X) throw ()
                {if (_Ptr != _X._Ptr)
                        {delete _Ptr->_Decref();
                        _Ptr = _X._Ptr;
                        _Ptr->_Incref(); }
                return (*this); }
        string name() const
                {return (_Ptr->_Name); }
        const facet *_Getfacet(size_t _Id, bool _Xp = false) const;
        bool _Iscloc() const;
        bool operator==(const locale& _X) const;
        bool operator!=(const locale& _X) const
                {return (!(*this == _X)); }
        static const locale& __cdecl classic();
        static locale __cdecl global(const locale&);
        static locale __cdecl empty();
private:
        locale(_Locimp *_P)
                : _Ptr(_P) {}
        static _Locimp *__cdecl _Init();
        static void __cdecl _Tidy();
        _Locimp *_Ptr;
        };
;
                
template<class _F>
        class _Tidyfac {
public:
        static _F *__cdecl _Save(_F *_Fac)
                {_Lockit _Lk;
                _Facsav = _Fac;
                _Facsav->_Incref();
                atexit(_Tidy);
                return (_Fac); }
        static void __cdecl _Tidy()
                {_Lockit _Lk;
                delete _Facsav->_Decref();
                _Facsav = 0; }
private:
        static _F *_Facsav;
        };
template<class _F>
        _F *_Tidyfac<_F>::_Facsav = 0;
 
 
 
template<class _F> inline
        locale _Addfac(locale _X, _F *_Fac)
                {_Lockit _Lk;
                return (_X._Addfac(_Fac, _F::id, _F::_Getcat())); }
template<class _F> inline
        const _F& __cdecl use_facet(const locale& _L, const _F *,
                bool _Cfacet)
        {static const locale::facet *_Psave = 0;
        _Lockit _Lk;
        size_t _Id = _F::id;
        const locale::facet *_Pf = _L._Getfacet(_Id, true);
        if (_Pf != 0)
                ;
        else if (!_Cfacet || !_L._Iscloc())
                throw bad_cast("missing locale facet");
        else if (_Psave == 0)
                _Pf = _Psave = _Tidyfac<_F>::_Save(new _F);
        else
                _Pf = _Psave;
        return (*(const _F *)_Pf); }
                

template<class _E> inline
        int _Narrow(_E _C)      
        {return ((unsigned char)(char)_C); }
inline int _Narrow(wchar_t _C)
        {return (wctob(_C)); }
                

template<class _E> inline
        _E _Widen(char _Ch, _E *)       
        {return (_Ch); }
inline wchar_t _Widen(char _Ch, wchar_t *)
        {return (btowc(_Ch)); }
                
template<class _E, class _II> inline
        int __cdecl _Getloctxt(_II& _F, _II& _L, size_t _N,
                const _E *_S)
        {for (size_t _I = 0; _S[_I] != (_E)0; ++_I)
                if (_S[_I] == _S[0])
                        ++_N;
        string _Str(_N, '\0');
        int _Ans = -2;
        for (size_t _J = 1; ; ++_J, ++_F, _Ans = -1)
                {bool  _Pfx;
                size_t _I, _K;
                for (_I = 0, _K = 0, _Pfx = false; _K < _N; ++_K)
                        {for (; _S[_I] != (_E)0 && _S[_I] != _S[0]; ++_I)
                                ;
                        if (_Str[_K] != '\0')
                                _I += _Str[_K];
                        else if (_S[_I += _J] == _S[0] || _S[_I] == (_E)0)
                                {_Str[_K] = _J < 127 ? _J : 127;
                                _Ans = _K; }
                        else if (_F == _L || _S[_I] != *_F)
                                _Str[_K] = _J < 127 ? _J : 127;
                        else
                                _Pfx = true; }
                if (!_Pfx || _F == _L)
                        break; }
        return (_Ans); }
                

template<class _E> inline
        _E *__cdecl _Maklocstr(const char *_S, _E *)
        {size_t _L = qstrlen(_S) + 1;
        _E *_X = new _E[_L];
        for (_E *_P = _X; 0 < _L; --_L, ++_P, ++_S)
                *_P = _Widen(*_S, (_E *)0);
        return (_X); }
                
class __declspec(dllimport) codecvt_base : public locale::facet {
public:
        enum _Result {ok, partial, error, noconv};
        typedef int result;
        codecvt_base(size_t _R = 0)
                : locale::facet(_R) {}
        bool always_noconv() const throw ()
                {return (do_always_noconv()); }
        int max_length() const throw ()
                {return (do_max_length()); }
        int encoding() const throw ()
                {return (do_encoding()); }
protected:
        virtual bool do_always_noconv() const throw ()
                {return (true); }
        virtual int do_max_length() const throw ()
                {return (1); }
        virtual int do_encoding() const throw ()
                {return (1); }
        };
;
                
template<class _E, class _To, class _St>
        class codecvt : public codecvt_base {
public:
        typedef _E from_type;
        typedef _To to_type;
        typedef _St state_type;
        result in(_St& _State,
                const _To *_F1, const _To *_L1, const _To *& _Mid1,
                _E *_F2, _E *_L2, _E *& _Mid2) const
                {return (do_in(_State,
                        _F1, _L1, _Mid1, _F2, _L2, _Mid2)); }
        result out(_St& _State,
                const _E *_F1, const _E *_L1, const _E *& _Mid1,
                _To *_F2, _To *_L2, _To *& _Mid2) const
                {return (do_out(_State,
                        _F1, _L1, _Mid1, _F2, _L2, _Mid2)); }
        int length(_St& _State, const _E *_F1,
                const _E *_L1, size_t _N2) const throw ()
                {return (do_length(_State, _F1, _L1, _N2)); }
        static locale::id id;
        explicit codecvt(size_t _R = 0)
                : codecvt_base(_R) {_Init(_Locinfo()); }
        codecvt(const _Locinfo& _Lobj, size_t _R = 0)
                : codecvt_base(_R) {_Init(_Lobj); }
        static size_t __cdecl _Getcat()
                {return (2); }
public:
        virtual ~codecvt()
                {};
protected:
        void _Init(const _Locinfo& _Lobj)
                {_Cvt = _Lobj._Getcvt(); }
        virtual result do_in(_St& _State,
                const _To *_F1, const _To *, const _To *& _Mid1,
                _E *_F2, _E *, _E *& _Mid2) const
                {_Mid1 = _F1, _Mid2 = _F2;
                return (noconv); }
        virtual result do_out(_St& _State,
                const _E *_F1, const _E *, const _E *& _Mid1,
                _To *_F2, _To *, _To *& _Mid2) const
                {_Mid1 = _F1, _Mid2 = _F2;
                return (noconv); }
        virtual int do_length(_St& _State, const _E *_F1,
                const _E *_L1, size_t _N2) const throw ()
                {return (_N2 < _L1 - _F1 ? _N2 : _L1 - _F1); }
private:
        _Locinfo::_Cvtvec _Cvt;
        };
template<class _E, class _To, class _St>
        locale::id codecvt<_E, _To, _St>::id;
                
class __declspec(dllimport) codecvt<wchar_t, char, mbstate_t> : public codecvt_base {
public:
        typedef wchar_t _E;
        typedef char _To;
        typedef mbstate_t _St;
        typedef _E from_type;
        typedef _To to_type;
        typedef _St state_type;
        result in(_St& _State,
                const _To *_F1, const _To *_L1, const _To *& _Mid1,
                _E *_F2, _E *_L2, _E *& _Mid2) const
                {return (do_in(_State,
                        _F1, _L1, _Mid1, _F2, _L2, _Mid2)); }
        result out(_St& _State,
                const _E *_F1, const _E *_L1, const _E *& _Mid1,
                _To *_F2, _To *_L2, _To *& _Mid2) const
                {return (do_out(_State,
                        _F1, _L1, _Mid1, _F2, _L2, _Mid2)); }
        int length(_St& _State, const _E *_F1,
                const _E *_L1, size_t _N2) const throw ()
                {return (do_length(_State, _F1, _L1, _N2)); }
        static locale::id id;
        explicit codecvt(size_t _R = 0)
                : codecvt_base(_R) {_Init(_Locinfo()); }
        codecvt(const _Locinfo& _Lobj, size_t _R = 0)
                : codecvt_base(_R) {_Init(_Lobj); }
        static size_t __cdecl _Getcat()
                {return (2); }
public:
        virtual ~codecvt()
                {};
protected:
        void _Init(const _Locinfo& _Lobj)
                {_Cvt = _Lobj._Getcvt(); }
        virtual result do_in(_St& _State,
                const _To *_F1, const _To *_L1, const _To *& _Mid1,
                _E *_F2, _E *_L2, _E *& _Mid2) const
                {_Mid1 = _F1, _Mid2 = _F2;
                result _Ans = _Mid1 == _L1 ? ok : partial;
                int _N;
                while (_Mid1 != _L1 && _Mid2 != _L2)
                        switch (_N =
                                _Mbrtowc(_Mid2, _Mid1, _L1 - _Mid1,
                                        &_State, &_Cvt))
                        {case -2:
                                _Mid1 = _L1;
                                return (_Ans);
                        case -1:
                                return (error);
                        case 0:
                                _N = qstrlen(_Mid1) + 1;
                        default:        
                                _Mid1 += _N, ++_Mid2, _Ans = ok; }
                return (_Ans); }
        virtual result do_out(_St& _State,
                const _E *_F1, const _E *_L1, const _E *& _Mid1,
                _To *_F2, _To *_L2, _To *& _Mid2) const
                {_Mid1 = _F1, _Mid2 = _F2;
                result _Ans = _Mid1 == _L1 ? ok : partial;
                int _N;
                while (_Mid1 != _L1 && _Mid2 != _L2)
                        if (__mb_cur_max <= _L2 - _Mid2)
                                if ((_N =
                                        _Wcrtomb(_Mid2, *_Mid1, &_State,
                                                &_Cvt)) <= 0)
                                        return (error);
                                else
                                        ++_Mid1, _Mid2 += _N, _Ans = ok;
                        else
                                {_To _Buf[2];
                                _St _Stsave = _State;
                                if ((_N =
                                        _Wcrtomb(_Buf, *_Mid1, &_State,
                                                &_Cvt)) <= 0)
                                        return (error);
                                else if (_L2 - _Mid2 < _N)
                                        {_State = _Stsave;
                                        return (_Ans); }
                                else
                                        {memcpy(_Mid2, _Buf, _N);
                                        ++_Mid1, _Mid2 += _N, _Ans = ok; }}
                return (_Ans); }
        virtual int do_length(_St& _State, const _E *_F1,
                const _E *_L1, size_t _N2) const throw ()
                {const _E *_Mid1;
                _To _Buf[2];
                int _N;
                for (_Mid1 = _F1; _Mid1 != _L1 && 0 < _N2;
                        ++_Mid1, _N2 -= _N)
                        if ((_N =
                                _Wcrtomb(_Buf, *_Mid1, &_State, &_Cvt)) <= 0
                                        || _N2 < _N)
                                break;
                return (_Mid1 - _F1); }
        virtual bool do_always_noconv() const throw ()
                {return (false); }
        virtual int do_max_length() const throw ()
                {return (2); }
        virtual int do_encoding() const throw ()
                {return (0); }
private:
        _Locinfo::_Cvtvec _Cvt;
        };
                
template<class _E, class _To, class _St>
        class codecvt_byname : public codecvt<_E, _To, _St> {
public:
        explicit codecvt_byname(const char *_S, size_t _R = 0)
                : codecvt<_E, _To, _St>(_Locinfo(_S), _R) {}
public:
        virtual ~codecvt_byname()
                {}
        };
                
struct __declspec(dllimport) ctype_base : public locale::facet {
        enum _Mask {alnum = 0x4|0x2|0x1|0x100, alpha = 0x2|0x1|0x100,
                cntrl = 0x20, digit = 0x4, graph = 0x4|0x2|0x10|0x1|0x100,
                lower = 0x2, print = 0x4|0x2|0x10|0x40|0x1|0x100|0x80,
                punct = 0x10, space = 0x8|0x40|0x000, upper = 0x1,
                xdigit = 0x80};

        typedef short mask;     
        ctype_base(size_t _R = 0)
                : locale::facet(_R) {}
        };
                
template<class _E>
        class ctype : public ctype_base {
public:
        typedef _E char_type;
        bool is(mask _M, _E _C) const
                {return (do_is(_M, _C)); }
        const _E *is(const _E *_F, const _E *_L, mask *_V) const
                {return (do_is(_F, _L, _V)); }
        const _E *scan_is(mask _M, const _E *_F,
                const _E *_L) const
                {return (do_scan_is(_M, _F, _L)); }
        const _E *scan_not(mask _M, const _E *_F,
                const _E *_L) const
                {return (do_scan_not(_M, _F, _L)); }
        _E tolower(_E _C) const
                {return (do_tolower(_C)); }
        const _E *tolower(_E *_F, const _E *_L) const
                {return (do_tolower(_F, _L)); }
        _E toupper(_E _C) const
                {return (do_toupper(_C)); }
        const _E *toupper(_E *_F, const _E *_L) const
                {return (do_toupper(_F, _L)); }
        _E widen(char _X) const
                {return (do_widen(_X)); }
        const char *widen(const char *_F, const char *_L,
                _E *_V) const
                {return (do_widen(_F, _L, _V)); }
        char narrow(_E _C, char _D = '\0') const
                {return (do_narrow(_C, _D)); }
        const _E *narrow(const _E *_F, const _E *_L, char _D,
                char *_V) const
                {return (do_narrow(_F, _L, _D, _V)); }
        static locale::id id;
        explicit ctype(size_t _R = 0)
                : ctype_base(_R) {_Init(_Locinfo()); }
        ctype(const _Locinfo& _Lobj, size_t _R = 0)
                : ctype_base(_R) {_Init(_Lobj); }
        static size_t __cdecl _Getcat()
                {return (2); }
public:
        virtual ~ctype()
                {if (_Ctype._Delfl)
                        free((void *)_Ctype._Table); }
protected:
        void _Init(const _Locinfo& _Lobj)
                {_Ctype = _Lobj._Getctype(); }
        virtual bool do_is(mask _M, _E _C) const
                {return ((_Ctype._Table[narrow(_C)] & _M) != 0); }
        virtual const _E *do_is(const _E *_F, const _E *_L,
                mask *_V) const
                {for (; _F != _L; ++_F, ++_V)
                        *_V = _Ctype._Table[narrow(*_F)];
                return (_F); }
        virtual const _E *do_scan_is(mask _M, const _E *_F,
                const _E *_L) const
                {for (; _F != _L && !is(_M, *_F); ++_F)
                        ;
                return (_F); }
        virtual const _E *do_scan_not(mask _M, const _E *_F,
                const _E *_L) const
                {for (; _F != _L && is(_M, *_F); ++_F)
                        ;
                return (_F); }
        virtual _E do_tolower(_E _C) const
                {return ((_E)widen((char)_Tolower(narrow(_C), &_Ctype))); }
        virtual const _E *do_tolower(_E *_F, const _E *_L) const
                {for (; _F != _L; ++_F)
                        *_F = (_E)_Tolower(*_F, &_Ctype);
                return ((const _E *)_F); }
        virtual _E do_toupper(_E _C) const
                {return ((_E)widen((char)_Toupper(narrow(_C), &_Ctype))); }
        virtual const _E *do_toupper(_E *_F, const _E *_L) const
                {for (; _F != _L; ++_F)
                        *_F = (_E)_Toupper(*_F, &_Ctype);
                return ((const _E *)_F); }
        virtual _E do_widen(char _X) const
                {return (_Widen(_X, (_E *)0)); }
        virtual const char *do_widen(const char *_F, const char *_L,
                _E *_V) const
                {for (; _F != _L; ++_F, ++_V)
                        *_V = _Widen(*_F, (_E *)0);
                return (_F); }
        virtual char do_narrow(_E _C, char) const
                {return ((char)_Narrow((_E)(_C))); }
        virtual const _E *do_narrow(const _E *_F, const _E *_L,
                char, char *_V) const
                {for (; _F != _L; ++_F, ++_V)
                        *_V = (char)_Narrow((_E)(*_F));
                return (_F); }
private:
        _Locinfo::_Ctypevec _Ctype;
        };

template<class _E>
        locale::id ctype<_E>::id;

                
class __declspec(dllimport) ctype<char> : public ctype_base {
public:
        typedef char _E;
        typedef _E char_type;
        bool is(mask _M, _E _C) const
                {return ((_Ctype._Table[(unsigned char)_C] & _M) != 0); }
        const _E *is(const _E *_F, const _E *_L, mask *_V) const
                {for (; _F != _L; ++_F, ++_V)
                        *_V = _Ctype._Table[(unsigned char)*_F];
                return (_F); }
        const _E *scan_is(mask _M, const _E *_F,
                const _E *_L) const
                {for (; _F != _L && !is(_M, *_F); ++_F)
                        ;
                return (_F); }
        const _E *scan_not(mask _M, const _E *_F,
                const _E *_L) const
                {for (; _F != _L && is(_M, *_F); ++_F)
                        ;
                return (_F); }
        _E tolower(_E _C) const
                {return (do_tolower(_C)); }
        const _E *tolower(_E *_F, const _E *_L) const
                {return (do_tolower(_F, _L)); }
        _E toupper(_E _C) const
                {return (do_toupper(_C)); }
        const _E *toupper(_E *_F, const _E *_L) const
                {return (do_toupper(_F, _L)); }
        _E widen(char _X) const
                {return (_X); }
        const _E *widen(const char *_F, const char *_L, _E *_V) const
                {memcpy(_V, _F, _L - _F);
                return (_L); }
        _E narrow(_E _C, char _D = '\0') const
                {return (_C); }
        const _E *narrow(const _E *_F, const _E *_L, char _D,
                char *_V) const
                {memcpy(_V, _F, _L - _F);
                return (_L); }
        static locale::id id;
        explicit ctype(const mask *_Tab = 0, bool _Df = false,
                size_t _R = 0)
                : ctype_base(_R)
                {_Lockit Lk;
                _Init(_Locinfo());
                if (_Ctype._Delfl)
                        free((void *)_Ctype._Table), _Ctype._Delfl = false;
                if (_Tab == 0)
                        _Ctype._Table = _Cltab;
                else
                        _Ctype._Table = _Tab, _Ctype._Delfl = _Df; }
        ctype(const _Locinfo& _Lobj, size_t _R = 0)
                : ctype_base(_R) {_Init(_Lobj); }
        static size_t __cdecl _Getcat()
                {return (2); }
        static const size_t table_size;
public:
        virtual ~ctype()
                {if (_Ctype._Delfl)
                        free((void *)_Ctype._Table); }
protected:
        static void __cdecl _Term(void)
                {free((void *)_Cltab); }
        void _Init(const _Locinfo& _Lobj)
                {_Lockit Lk;
                _Ctype = _Lobj._Getctype();
                if (_Cltab == 0)
                        {_Cltab = _Ctype._Table;
                        atexit(_Term);
                        _Ctype._Delfl = false; }}
        virtual _E do_tolower(_E _C) const
                {return (_E)(_Tolower((unsigned char)_C, &_Ctype)); }
        virtual const _E *do_tolower(_E *_F, const _E *_L) const
                {for (; _F != _L; ++_F)
                        *_F = (_E)_Tolower(*_F, &_Ctype);
                return ((const _E *)_F); }
        virtual _E do_toupper(_E _C) const
                {return ((_E)_Toupper((unsigned char)_C, &_Ctype)); }
        virtual const _E *do_toupper(_E *_F, const _E *_L) const
                {for (; _F != _L; ++_F)
                        *_F = (_E)_Toupper(*_F, &_Ctype);
                return ((const _E *)_F); }
        const mask *table() const throw ()
                {return (_Ctype._Table); }
        static const mask * __cdecl classic_table() throw ()
                {_Lockit Lk;
                if (_Cltab == 0)
                        locale::classic();      
                return (_Cltab); }
private:
        _Locinfo::_Ctypevec _Ctype;
        static const mask *_Cltab;
        };


                
template<class _E>
        class ctype_byname : public ctype<_E> {
public:
        explicit ctype_byname(const char *_S, size_t _R = 0)
                : ctype<_E>(_Locinfo(_S), _R) {}
public:
        virtual ~ctype_byname()
                {}
        };


#pragma warning(disable:4231) 
extern template class __declspec(dllimport) ctype<wchar_t>;
extern template class __declspec(dllimport) codecvt<char, char, int>;
#pragma warning(default:4231) 
#line 631 "c:\\programme\\microsoft visual studio\\vc98\\include\\xlocale"

};

#pragma pack(pop)
#line 636 "c:\\programme\\microsoft visual studio\\vc98\\include\\xlocale"

#line 638 "c:\\programme\\microsoft visual studio\\vc98\\include\\xlocale"





#line 10 "c:\\programme\\microsoft visual studio\\vc98\\include\\xiosbase"


#pragma pack(push,8)
#line 14 "c:\\programme\\microsoft visual studio\\vc98\\include\\xiosbase"
namespace std {
                
class __declspec(dllimport) ios_base {
public:
                        
        class failure : public runtime_error {
        public:
                explicit failure(const string &_S)
                        : runtime_error(_S) {}
                virtual ~failure()
                        {}
        protected:
                virtual void _Doraise() const
                        {throw (*this); }
        };
        enum _Fmtflags {skipws = 0x0001, unitbuf = 0x0002,
                uppercase = 0x0004, showbase = 0x0008,
                showpoint = 0x0010, showpos = 0x0020,
                left = 0x0040, right = 0x0080, internal = 0x0100,
                dec = 0x0200, oct = 0x0400, hex = 0x0800,
                scientific = 0x1000, fixed = 0x2000, boolalpha = 0x4000,
                adjustfield = 0x01c0, basefield = 0x0e00,
                floatfield = 0x3000, _Fmtmask = 0x7fff, _Fmtzero = 0};
        enum _Iostate {goodbit = 0x0, eofbit = 0x1,
                failbit = 0x2, badbit = 0x4, _Statmask = 0x7};
        enum _Openmode {in = 0x01, out = 0x02, ate = 0x04,
                app = 0x08, trunc = 0x10, binary = 0x20};
        enum seekdir {beg = 0, cur = 1, end = 2};
        enum event {erase_event, imbue_event, copyfmt_event};
        typedef void (__cdecl *event_callback)(event, ios_base&, int);
        typedef int fmtflags;
        typedef int iostate;
        typedef int openmode;
        typedef short io_state, open_mode, seek_dir;
                        
        class __declspec(dllimport) Init {
        public:
                Init();
                ~Init();
        private:
                static int _Init_cnt;
                };
        ios_base& operator=(const ios_base& _R)
                {if (this != &_R)
                        {_State = _R._State;
                        copyfmt(_R); }
                return (*this); }
        operator void *() const
                {return (fail() ? 0 : (void *)this); }
        bool operator!() const
                {return (fail()); }
        void clear(iostate = goodbit, bool = false);
        void clear(io_state _St)
                {clear((iostate)_St); }
        iostate rdstate() const
                {return (_State); }
        void setstate(iostate _St, bool _Ex = false)
                {if (_St != goodbit)
                        clear((iostate)((int)rdstate() | (int)_St), _Ex); }
        void setstate(io_state _St)
                {setstate((iostate)_St); }
        bool good() const
                {return (rdstate() == goodbit); }
        bool eof() const
                {return ((int)rdstate() & (int)eofbit); }
        bool fail() const
                {return (((int)rdstate() & ((int)badbit | (int)failbit)) != 0); }
        bool bad() const
                {return (((int)rdstate() & (int)badbit) != 0); }
        iostate exceptions() const
                {return (_Except); }
        void exceptions(iostate _Ne)
                {_Except = _Ne & _Statmask;
                clear(_State); }
        void exceptions(io_state _St)
                {exceptions((iostate)_St); }
        fmtflags flags() const
                {return (_Fmtfl); }
        fmtflags flags(fmtflags _Nf)
                {fmtflags _Of = _Fmtfl;
                _Fmtfl = _Nf & _Fmtmask;
                return (_Of); }
        fmtflags setf(fmtflags _Nf)
                {ios_base::fmtflags _Of = _Fmtfl;
                _Fmtfl |= _Nf & _Fmtmask;
                return (_Of); }
        fmtflags setf(fmtflags _Nf, fmtflags _M)
                {ios_base::fmtflags _Of = _Fmtfl;
                _Fmtfl = (_Fmtfl & ~_M) | (_Nf & _M & _Fmtmask);
                return (_Of); }
        void unsetf(fmtflags _M)
                {_Fmtfl &= ~_M; }
        streamsize precision() const
                {return (_Prec); }
        streamsize precision(int _Np)
                {streamsize _Op = _Prec;
                _Prec = _Np;
                return (_Op); }
        streamsize width() const
                {return (_Wide); }
        streamsize width(streamsize _Nw)
                {streamsize _Ow = _Wide;
                _Wide = _Nw;
                return (_Ow); }
        locale getloc() const
                {return (_Loc); }
        locale imbue(const locale&);
        static int __cdecl xalloc()
                {_Lockit _Lk;
                return (_Index++); }
        long& iword(int _Idx)
                {return (_Findarr(_Idx)._Lo); }
        void *& pword(int _Idx)
                {return (_Findarr(_Idx)._Vp); }
        void register_callback(event_callback, int);
        ios_base& copyfmt(const ios_base&);
        virtual ~ios_base();
        static bool __cdecl sync_with_stdio(bool _Sfl = true)
                {_Lockit _Lk;
                const bool _Osfl = _Sync;
                _Sync = _Sfl;
                return (_Osfl); }
protected:
        ios_base()
                : _Loc(_Noinit), _Stdstr(0) {}
        void _Addstd();
        void _Init();
private:
                        
        struct _Iosarray {
        public:
                _Iosarray(int _Idx, _Iosarray *_Link)
                        : _Next(_Link), _Index(_Idx), _Lo(0), _Vp(0) {}
                _Iosarray *_Next;
                int _Index;
                long _Lo;
                void *_Vp;
                };
                        
        struct _Fnarray {
                _Fnarray(int _Idx, event_callback _P, _Fnarray *_Link)
                        : _Next(_Link), _Index(_Idx), _Pfn(_P) {}
                _Fnarray *_Next;
                int _Index;
                event_callback _Pfn;
                };
        void _Callfns(event);
        _Iosarray& _Findarr(int);
        void _Tidy();
        iostate _State, _Except;
        fmtflags _Fmtfl;
        int _Prec, _Wide;
        _Iosarray *_Arr;
        _Fnarray *_Calls;
        locale _Loc;
        size_t _Stdstr;
        static int _Index;
        static bool _Sync;
        };



};

#pragma pack(pop)
#line 180 "c:\\programme\\microsoft visual studio\\vc98\\include\\xiosbase"

#line 182 "c:\\programme\\microsoft visual studio\\vc98\\include\\xiosbase"





#line 14 "c:\\programme\\microsoft visual studio\\vc98\\include\\xlocnum"


#pragma pack(push,8)
#line 18 "c:\\programme\\microsoft visual studio\\vc98\\include\\xlocnum"
namespace std {
		
template<class _E>
	class numpunct : public locale::facet {
public:
	typedef basic_string<_E, char_traits<_E>, allocator<_E> >
		string_type;
	typedef _E char_type;
	static locale::id id;
	_E decimal_point() const
		{return (do_decimal_point()); }
	_E thousands_sep() const
		{return (do_thousands_sep()); }
	string grouping() const
		{return (do_grouping()); }
	string_type falsename() const
		{return (do_falsename()); }
	string_type truename() const
		{return (do_truename()); }
	explicit numpunct(size_t _R = 0)
		: locale::facet(_R) {_Init(_Locinfo()); }
	numpunct(const _Locinfo& _Lobj, size_t _R = 0)
		: locale::facet(_R) {_Init(_Lobj); }
	static size_t __cdecl _Getcat()
		{return (4); }
public:
	virtual ~numpunct()
		{delete[] _Gr;
		delete[] _Nf;
		delete[] _Nt; }
protected:
	void _Init(const _Locinfo& _Lobj)
		{const lconv *_P = _Lobj._Getlconv();
		_Dp = _Widen(_P->decimal_point[0], (_E *)0);
		_Ks = _Widen(_P->thousands_sep[0], (_E *)0);
		_Gr = _Maklocstr(_P->grouping, (char *)0);
		_Nf = _Maklocstr(_Lobj._Getfalse(), (_E *)0);
		_Nt = _Maklocstr(_Lobj._Gettrue(), (_E *)0); }
	virtual _E do_decimal_point() const
		{return (_Dp); }
	virtual _E do_thousands_sep() const
		{return (_Ks); }
	virtual string do_grouping() const
		{return (string(_Gr)); }
	virtual string_type do_falsename() const
		{return (string_type(_Nf)); }
	virtual string_type do_truename() const
		{return (string_type(_Nt)); }
private:
	char *_Gr;
	_E _Dp, _Ks, *_Nf, *_Nt;
	};
typedef numpunct<char> _Npc;
typedef numpunct<wchar_t> _Npwc;
		
template<class _E>
	class numpunct_byname : public numpunct<_E> {
public:
	explicit numpunct_byname(const char *_S, size_t _R = 0)
		: numpunct<_E>(_Locinfo(_S), _R) {}
public:
	virtual ~numpunct_byname()
		{}
	};
template<class _E>
	locale::id numpunct<_E>::id;
 

template<class _E> inline
	bool (isdigit)(_E _C, const locale& _L)
	{return (use_facet(_L, (ctype<_E> *)0, true).is(ctype_base::digit, _C)); }

		
template<class _E,
	class _II = istreambuf_iterator<_E, char_traits<_E> > >
	class num_get : public locale::facet {
public:
	typedef numpunct<_E> _Mypunct;
	typedef basic_string<_E, char_traits<_E>, allocator<_E> >
		_Mystr;
	static size_t __cdecl _Getcat()
		{return (4); }
	static locale::id id;
public:
	virtual ~num_get()
		{}
protected:
	void _Init(const _Locinfo& _Lobj)
		{}
public:
	explicit num_get(size_t _R = 0)
		: locale::facet(_R) {_Init(_Locinfo()); }
	num_get(const _Locinfo& _Lobj, size_t _R = 0)
		: locale::facet(_R) {_Init(_Lobj); }
	typedef _E char_type;
	typedef _II iter_type;
	_II get(_II _F, _II _L, ios_base& _X, ios_base::iostate& _St,
		_Bool& _V) const
		{return (do_get(_F, _L, _X, _St, _V)); }
	_II get(_II _F, _II _L, ios_base& _X, ios_base::iostate& _St,
		unsigned short& _V) const
		{return (do_get(_F, _L, _X, _St, _V)); }
	_II get(_II _F, _II _L, ios_base& _X, ios_base::iostate& _St,
		unsigned int& _V) const
		{return (do_get(_F, _L, _X, _St, _V)); }
	_II get(_II _F, _II _L, ios_base& _X, ios_base::iostate& _St,
		long& _V) const
		{return (do_get(_F, _L, _X, _St, _V)); }
	_II get(_II _F, _II _L, ios_base& _X, ios_base::iostate& _St,
		unsigned long& _V) const
		{return (do_get(_F, _L, _X, _St, _V)); }
	_II get(_II _F, _II _L, ios_base& _X, ios_base::iostate& _St,
		float& _V) const
		{return (do_get(_F, _L, _X, _St, _V)); }
	_II get(_II _F, _II _L, ios_base& _X, ios_base::iostate& _St,
		double& _V) const
		{return (do_get(_F, _L, _X, _St, _V)); }
	_II get(_II _F, _II _L, ios_base& _X, ios_base::iostate& _St,
		long double& _V) const
		{return (do_get(_F, _L, _X, _St, _V)); }
	_II get(_II _F, _II _L, ios_base& _X, ios_base::iostate& _St,
		void *& _V) const
		{return (do_get(_F, _L, _X, _St, _V)); }
protected:
	virtual _II do_get(_II _F, _II _L, ios_base& _X,
		ios_base::iostate& _St, _Bool& _V) const
		{int _Ans = -1;
		if (_X.flags() & ios_base::boolalpha)
			{const _Mypunct& _Fac = use_facet(_X.getloc(), (_Mypunct *)0, true);
			_Mystr _Str(1, (_E)0);
			_Str += _Fac.falsename();
			_Str += (_E)0;
			_Str += _Fac.truename();
			_Ans = _Getloctxt(_F, _L, (size_t)2, _Str.c_str()); }
		else
			{char _Ac[32], *_Ep;
			(*_errno()) = 0;
			const unsigned long _Ulo = strtoul(_Ac, &_Ep,
				_Getifld(_Ac, _F, _L, _X.flags(), _X.getloc()));
			if (_Ep != _Ac && (*_errno()) == 0 && _Ulo <= 1)
				_Ans = _Ulo; }
		if (_F == _L)
			_St |= ios_base::eofbit;
		if (_Ans < 0)
			_St |= ios_base::failbit;
		else
			_V = _Ans != 0;
		return (_F); }
	virtual _II do_get(_II _F, _II _L, ios_base& _X,
		ios_base::iostate& _St, unsigned short& _V) const
		{char _Ac[32], *_Ep;
		(*_errno()) = 0;
		int _Base =
			_Getifld(_Ac, _F, _L, _X.flags(), _X.getloc());
		char *_S = _Ac[0] == '-' ? _Ac + 1 : _Ac;
		const unsigned long _Ans = strtoul(_S, &_Ep, _Base);
		if (_F == _L)
			_St |= ios_base::eofbit;
		if (_Ep == _S || (*_errno()) != 0 || 0xffff < _Ans)
			_St |= ios_base::failbit;
		else
			_V = (unsigned short)(_Ac[0] == '-' ? -_Ans : _Ans);
		return (_F); }
	virtual _II do_get(_II _F, _II _L, ios_base& _X,
		ios_base::iostate& _St, unsigned int& _V) const
		{char _Ac[32], *_Ep;
		(*_errno()) = 0;
		int _Base =
			_Getifld(_Ac, _F, _L, _X.flags(), _X.getloc());
		char *_S = _Ac[0] == '-' ? _Ac + 1 : _Ac;
		const unsigned long _Ans = strtoul(_S, &_Ep, _Base);
		if (_F == _L)
			_St |= ios_base::eofbit;
		if (_Ep == _S || (*_errno()) != 0 || 0xffffffff < _Ans)
			_St |= ios_base::failbit;
		else
			_V = _Ac[0] == '-' ? -_Ans : _Ans;
		return (_F); }
	virtual _II do_get(_II _F, _II _L, ios_base& _X,
		ios_base::iostate& _St, long& _V) const
		{char _Ac[32], *_Ep;
		(*_errno()) = 0;
		const long _Ans = strtol(_Ac, &_Ep,
			_Getifld(_Ac, _F, _L, _X.flags(), _X.getloc()));
		if (_F == _L)
			_St |= ios_base::eofbit;
		if (_Ep == _Ac || (*_errno()) != 0)
			_St |= ios_base::failbit;
		else
			_V = _Ans;
		return (_F); }
	virtual _II do_get(_II _F, _II _L, ios_base& _X,
		ios_base::iostate& _St, unsigned long& _V) const
		{char _Ac[32], *_Ep;
		(*_errno()) = 0;
		const unsigned long _Ans = strtoul(_Ac, &_Ep,
			_Getifld(_Ac, _F, _L, _X.flags(), _X.getloc()));
		if (_F == _L)
			_St |= ios_base::eofbit;
		if (_Ep == _Ac || (*_errno()) != 0)
			_St |= ios_base::failbit;
		else
			_V = _Ans;
		return (_F); }
	virtual _II do_get(_II _F, _II _L, ios_base& _X,
		ios_base::iostate& _St, float& _V) const
		{char _Ac[8 + 36 + 32], *_Ep;
		(*_errno()) = 0;
		const float _Ans = _Stof(_Ac, &_Ep,
			_Getffld(_Ac, _F, _L, _X.getloc()));
		if (_F == _L)
			_St |= ios_base::eofbit;
		if (_Ep == _Ac || (*_errno()) != 0)
			_St |= ios_base::failbit;
		else
			_V = _Ans;
		return (_F); }
	virtual _II do_get(_II _F, _II _L, ios_base& _X,
		ios_base::iostate& _St, double& _V) const
		{char _Ac[8 + 36 + 32], *_Ep;
		(*_errno()) = 0;
		const double _Ans = _Stod(_Ac, &_Ep,
			_Getffld(_Ac, _F, _L, _X.getloc()));
		if (_F == _L)
			_St |= ios_base::eofbit;
		if (_Ep == _Ac || (*_errno()) != 0)
			_St |= ios_base::failbit;
		else
			_V = _Ans;
		return (_F); }
	virtual _II do_get(_II _F, _II _L, ios_base& _X,
		ios_base::iostate& _St, long double& _V) const
		{char _Ac[8 + 36 + 32], *_Ep;
		(*_errno()) = 0;
		const long double _Ans = _Stold(_Ac, &_Ep,
			_Getffld(_Ac, _F, _L, _X.getloc()));
		if (_F == _L)
			_St |= ios_base::eofbit;
		if (_Ep == _Ac || (*_errno()) != 0)
			_St |= ios_base::failbit;
		else
			_V = _Ans;
		return (_F); }
	virtual _II do_get(_II _F, _II _L, ios_base& _X,
		ios_base::iostate& _St, void *& _V) const
		{union _Pvlo {
			void *_Pv;
			unsigned long _Lo[1 +
				(sizeof (void *) - 1) / sizeof (unsigned long)];
			} _U;
		const int _NL = sizeof (_U._Lo) / sizeof (unsigned long);
		for (int _I = 0; ; ++_F)
			{char _Ac[32], *_Ep;
			(*_errno()) = 0;
			_U._Lo[_I] = strtoul(_Ac, &_Ep,
				_Getifld(_Ac, _F, _L,
					ios_base::hex, _X.getloc()));
			if (_F == _L)
				_St |= ios_base::eofbit;
			if (_Ep == _Ac || (*_errno()) != 0)
				{_St |= ios_base::failbit;
				break; }
			if (_NL <= ++_I)
				break;
			if (_F == _L || *_F != _Widen(':', (_E *)0))
				{_St |= ios_base::failbit;
				break; }}
		if (!(_St & ios_base::failbit))
			_V = _U._Pv;
		return (_F); }
private:
	static int __cdecl _Getifld(char *_Ac, _II& _F, _II& _L,
		ios_base::fmtflags _Bfl, const locale& _Loc)
		{const _E _E0 = _Widen('0', (_E *)0);
		const _Mypunct& _Fac = use_facet(_Loc, (_Mypunct *)0, true);
		const string _Gr = _Fac.grouping();
		const _E _Ks = _Fac.thousands_sep();
		char *_P = _Ac;
		if (_F == _L)
			;
		else if (*_F == _Widen('+', (_E *)0))
			*_P++ = '+', ++_F;
		else if (*_F == _Widen('-', (_E *)0))
			*_P++ = '-', ++_F;
		_Bfl &= ios_base::basefield;
		int _Base = _Bfl == ios_base::oct ? 8
			: _Bfl == ios_base::hex ? 16
			: _Bfl == ios_base::_Fmtzero ? 0 : 10;
		bool _Sd = false, _Snz = false;
		if (_F != _L && *_F == _E0)
			{_Sd = true, ++_F;
			if (_F != _L && (*_F == _Widen('x', (_E *)0)
					|| *_F == _Widen('X', (_E *)0))
				&& (_Base == 0 || _Base == 16))
				_Base = 16, _Sd = false, ++_F;
			else if (_Base == 0)
				_Base = 8; }
		int _Dlen = _Base == 0 || _Base == 10 ? 10
			: _Base == 8 ? 8 : 16 + 6;
		string _Grin(1, _Sd ? '\1' : '\0');
		size_t _I = 0;
		for (char *const _Pe = &_Ac[32 - 1];
			_F != _L; ++_F)
			if (memchr("0123456789abcdefABCDEF",
				*_P = (char)_Narrow((_E)(*_F)), _Dlen) != 0)
				{if ((_Snz || *_P != '0') && _P < _Pe)
					++_P, _Snz = true;
				_Sd = true;
				if (_Grin[_I] != 127)
					++_Grin[_I]; }
			else if (_Grin[_I] == '\0' || _Ks == (_E)0
				|| *_F != _Ks)
				break;
			else
				_Grin.append(1, '\0'), ++_I;
		if (_I == 0)
			;
		else if ('\0' < _Grin[_I])
			++_I;
		else
			_Sd = false;
		for (const char *_Pg = _Gr.c_str(); _Sd && 0 < _I; --_I)
			if (*_Pg == 127)
				break;
			else if (0 < --_I && *_Pg != _Grin[_I]
				|| 0 == _I && *_Pg < _Grin[_I])
				_Sd = false;
			else if ('\0' < _Pg[1])
				++_Pg;
		if (_Sd && !_Snz)
			*_P++ = '0';
		else if (!_Sd)
			_P = _Ac;
		*_P = '\0';
		return (_Base);
		}
	static int __cdecl _Getffld(char *_Ac, _II& _F, _II &_L,
		const locale& _Loc)
		{const _E _E0 = _Widen('0', (_E *)0);
		const _Mypunct& _Fac = use_facet(_Loc, (_Mypunct *)0, true);
		char *_P = _Ac;
		if (_F == _L)
			;
		else if (*_F == _Widen('+', (_E *)0))
			*_P++ = '+', ++_F;
		else if (*_F == _Widen('-', (_E *)0))
			*_P++ = '-', ++_F;
		bool _Sd = false;
		for (; _F != _L && *_F == _E0; _Sd = true, ++_F)
			;
		if (_Sd)
			*_P++ = '0';
		int _Ns = 0;
		int _Pten = 0;
		for (; _F != _L && isdigit(*_P = (char)_Narrow((_E)(*_F)), _Loc);
			_Sd = true, ++_F)
			if (_Ns < 36)
				++_P, ++_Ns;
			else
				++_Pten;
		if (_F != _L && *_F == _Fac.decimal_point())
			*_P++ = localeconv()->decimal_point[0], ++_F;
		if (_Ns == 0)
			{for (; _F != _L && *_F == _E0; _Sd = true, ++_F)
				--_Pten;
			if (_Pten < 0)
				*_P++ = '0', ++_Pten; }
		for (; _F != _L && isdigit(*_P = (char)_Narrow((_E)(*_F)), _Loc);
			_Sd = true, ++_F)
			if (_Ns < 36)
				++_P, ++_Ns;
		if (_Sd && _F != 
_L
&& (*_F == _Widen('e', (_E *)0) || *_F == _Widen('E', (_E *)0)))
			{*_P++ = 'e', ++_F;
			_Sd = false, _Ns = 0;
			if (_F == _L)
				;
			else if (*_F == _Widen('+', (_E *)0))
				*_P++ = '+', ++_F;
			else if (*_F == _Widen('-', (_E *)0))
				*_P++ = '-', ++_F;
			for (; _F != _L && *_F == _E0; _Sd = true, ++_F)
				;
			if (_Sd)
				*_P++ = '0';
			for (; _F != _L && isdigit(*_P = (char)_Narrow((_E)(*_F)), _Loc);
				_Sd = true, ++_F)
				if (_Ns < 8)
					++_P, ++_Ns; }
		if (!_Sd)
			_P = _Ac;
		*_P = '\0';
		return (_Pten);
		};
	};
template<class _E, class _II>
	locale::id num_get<_E, _II>::id;
		
template<class _E,
	class _OI = ostreambuf_iterator<_E, char_traits<_E> > >
	class num_put : public locale::facet {
public:
	typedef numpunct<_E> _Mypunct;
	typedef basic_string<_E, char_traits<_E>, allocator<_E> >
		_Mystr;
	static size_t __cdecl _Getcat()
		{return (4); }
	static locale::id id;
public:
	virtual ~num_put()
		{}
protected:
	void _Init(const _Locinfo& _Lobj)
		{}
public:
	explicit num_put(size_t _R = 0)
		: locale::facet(_R) {_Init(_Locinfo()); }
	num_put(const _Locinfo& _Lobj, size_t _R = 0)
		: locale::facet(_R) {_Init(_Lobj); }
	typedef _E char_type;
	typedef _OI iter_type;
	_OI put(_OI _F, ios_base& _X, _E _Fill,
		_Bool _V) const
		{return (do_put(_F, _X, _Fill, _V)); }
	_OI put(_OI _F, ios_base& _X, _E _Fill,
		long _V) const
		{return (do_put(_F, _X, _Fill, _V)); }
	_OI put(_OI _F, ios_base& _X, _E _Fill,
		unsigned long _V) const
		{return (do_put(_F, _X, _Fill, _V)); }
	_OI put(_OI _F, ios_base& _X, _E _Fill,
		double _V) const
		{return (do_put(_F, _X, _Fill, _V)); }
	_OI put(_OI _F, ios_base& _X, _E _Fill,
		long double _V) const
		{return (do_put(_F, _X, _Fill, _V)); }
	_OI put(_OI _F, ios_base& _X, _E _Fill,
		const void *_V) const
		{return (do_put(_F, _X, _Fill, _V)); }
protected:
	virtual _OI do_put(_OI _F, ios_base& _X, _E _Fill,
		_Bool _V) const
		{const _Mypunct& _Fac = use_facet(_X.getloc(), (_Mypunct *)0, true);
		_Mystr _Str;
		if (!(_X.flags() & ios_base::boolalpha))
			_Str.append(1, _Widen(_V ? '1' : '0', (_E *)0));
		else if (_V)
			_Str = _Fac.truename();
		else
			_Str = _Fac.falsename();
		size_t _M = _X.width() <= 0 || _X.width() <= _Str.size()
			? 0 : _X.width() - _Str.size();
		ios_base::fmtflags _Afl =
			_X.flags() & ios_base::adjustfield;
		if (_Afl != ios_base::left)
			_F = _Rep(_F, _Fill, _M), _M = 0;
		_F = _Put(_F, _Str.c_str(), _Str.size());
		_X.width(0);
		return (_Rep(_F, _Fill, _M)); }
	virtual _OI do_put(_OI _F, ios_base& _X, _E _Fill,
		long _V) const
		{char _Buf[2 * 32], _Fmt[6];
		return (_Iput(_F, _X, _Fill, _Buf,
			sprintf(_Buf, _Ifmt(_Fmt, 'd', _X.flags()), _V))); }
	virtual _OI do_put(_OI _F, ios_base& _X, _E _Fill,
		unsigned long _V) const
		{char _Buf[2 * 32], _Fmt[6];
		return (_Iput(_F, _X, _Fill, _Buf,
			sprintf(_Buf, _Ifmt(_Fmt, 'u', _X.flags()), _V))); }
	virtual _OI do_put(_OI _F, ios_base& _X, _E _Fill,
		double _V) const
		{char _Buf[8 + 36 + 32], _Fmt[8];
		streamsize _Prec = _X.precision() <= 0
			&& !(_X.flags() & ios_base::fixed) ? 6
			: _X.precision();
		int _Mpr = 36 < _Prec ? 36 : _Prec;
		return (_Fput(_F, _X, _Fill, _Buf, _Prec - _Mpr,
			sprintf(_Buf, _Ffmt(_Fmt, 0, _X.flags()),
				_Mpr, _V))); }
	virtual _OI do_put(_OI _F, ios_base& _X, _E _Fill,
		long double _V) const
		{char _Buf[8 + 36 + 32], _Fmt[8];
		streamsize _Prec = _X.precision() <= 0
			&& !(_X.flags() & ios_base::fixed) ? 6
			: _X.precision();
		int _Mpr = 36 < _Prec ? 36 : _Prec;
		return (_Fput(_F, _X, _Fill, _Buf, _Prec - _Mpr,
			sprintf(_Buf, _Ffmt(_Fmt, 'L', _X.flags()),
				_Mpr, _V))); }
	virtual _OI do_put(_OI _F, ios_base& _X, _E _Fill,
		const void *_V) const
		{
		const int _NL = 1
			+ (sizeof (void *) - 1) / sizeof (unsigned long);
		char _Buf[(_NL + 1) * (32 + 1)];
		int _N = sprintf(_Buf, "%p", _V);
		size_t _M = _X.width() <= 0 || _X.width() <= _N
			? 0 : _X.width() - _N;
		ios_base::fmtflags _Afl =
			_X.flags() & ios_base::adjustfield;
		if (_Afl != ios_base::left)
			_F = _Rep(_F, _Fill, _M), _M = 0;
		_F = _Putc(_F, _Buf, _N);
		_X.width(0);
		return (_Rep(_F, _Fill, _M)); }
	static char *_Ffmt(char *_Fmt, char _Spec,
		ios_base::fmtflags _Fl)
		{char *_S = _Fmt;
		*_S++ = '%';
		if (_Fl & ios_base::showpos)
			*_S++ = '+';
		if (_Fl & ios_base::showpoint)
			*_S++ = '#';
		*_S++ = '.';
		*_S++ = '*';
		if (_Spec != 0)
			*_S++ = _Spec;	
		ios_base::fmtflags _Ffl = _Fl & ios_base::floatfield;
		*_S++ = _Ffl == ios_base::fixed ? 'f'
			: _Ffl == ios_base::scientific ? 'e' : 'g';
		*_S = '\0';
		return (_Fmt); }
	static _OI __cdecl _Fput(_OI _F, ios_base& _X, _E _Fill,
		const char *_S, size_t _Nz, size_t _N)
		{size_t _M = _X.width() <= 0 || _X.width() <= _N  + _Nz
			? 0 : _X.width() - _N - _Nz;
		ios_base::fmtflags _Afl =
			_X.flags() & ios_base::adjustfield;
		if (_Afl != ios_base::left && _Afl != ios_base::internal)
			_F = _Rep(_F, _Fill, _M), _M = 0;
		else if (_Afl == ios_base::internal)
			{if (0 < _N && (*_S == '+' || *_S == '-'))
				_F = _Putc(_F, _S, 1), ++_S, --_N;
			_F = _Rep(_F, _Fill, _M), _M = 0; }
		const char *_P = (const char *)memchr(_S,
			localeconv()->decimal_point[0], _N);
		if (_P != 0)
			{const _Mypunct& _Fac = use_facet(_X.getloc(), (_Mypunct *)0, true);
			size_t _Nf = _P - _S + 1;
			_F = _Putc(_F, _S, _Nf - 1);
			_F = _Rep(_F, _Fac.decimal_point(), 1);
			_S += _Nf, _N -= _Nf; }
		if ((_P = (const char *)memchr(_S, 'e', _N)) != 0)
			{size_t _Nm = _P - _S + 1;
			_F = _Putc(_F, _S, _Nm - 1);
			_F = _Rep(_F, _Widen('0', (_E *)0), _Nz), _Nz = 0;
			_F = _Putc(_F, _X.flags() & ios_base::uppercase
				? "E" : "e", 1);
			_S += _Nm, _N -= _Nm; }
		_F = _Putc(_F, _S, _N);
		_F = _Rep(_F, _Widen('0', (_E *)0), _Nz);
		_X.width(0);
		return (_Rep(_F, _Fill, _M)); }
	static char *__cdecl _Ifmt(char *_Fmt, char _Spec,
		ios_base::fmtflags _Fl)
		{char *_S = _Fmt;
		*_S++ = '%';
		if (_Fl & ios_base::showpos)
			*_S++ = '+';
		if (_Fl & ios_base::showbase)
			*_S++ = '#';
		*_S++ = 'l';
		ios_base::fmtflags _Bfl = _Fl & ios_base::basefield;
		*_S++ = _Bfl == ios_base::oct ? 'o'
			: _Bfl != ios_base::hex ? _Spec	
			: _Fl & ios_base::uppercase ? 'X' : 'x';
		*_S = '\0';
		return (_Fmt); }
	static _OI __cdecl _Iput(_OI _F, ios_base& _X, _E _Fill,
		char *_S, size_t _N)
		{const size_t _Np = *_S == '+' || *_S == '-' ? 1
			: *_S == '0' && (_S[1] == 'x' || _S[1] == 'X') ? 2
			: 0;
		const _Mypunct& _Fac = use_facet(_X.getloc(), (_Mypunct *)0, true);
		const string _Gr = _Fac.grouping();
		const _E _Ks = _Fac.thousands_sep();
		bool _Grp = '\0' < *_Gr.c_str();
		if (_Grp)
			{const char *_Pg = _Gr.c_str();
			size_t _I = _N;
			for (_Grp = false; *_Pg != 127 && '\0' < *_Pg
				&& *_Pg < _I - _Np; _Grp = true)
				{_I -= *_Pg;
				memmove(&_S[_I + 1], &_S[_I], _N + 1 - _I);
				_S[_I] = ',', ++_N;
				if ('\0' < _Pg[1])
					++_Pg; }}
		size_t _M = _X.width() <= 0 || _X.width() <= _N
			? 0 : _X.width() - _N;
		ios_base::fmtflags _Afl =
			_X.flags() & ios_base::adjustfield;
		if (_Afl != ios_base::left && _Afl != ios_base::internal)
			_F = _Rep(_F, _Fill, _M), _M = 0;
		else if (_Afl == ios_base::internal)
			{_F = _Putc(_F, _S, _Np), _S += _Np, _N -= _Np;
			_F = _Rep(_F, _Fill, _M), _M = 0; }
		if (!_Grp)
			_F = _Putc(_F, _S, _N);
		else
			for (; ; ++_S, --_N)
				{size_t _Nd = strcspn(_S, ",");
				_F = _Putc(_F, _S, _Nd);
				_S += _Nd, _N -= _Nd;
				if (_N == 0)
					break;
				if (_Ks != (_E)0)
					_F = _Rep(_F, _Ks, 1); }
		_X.width(0);
		return (_Rep(_F, _Fill, _M)); }
	static _OI _Put(_OI _F, const _E *_S, size_t _N)
		{for (; 0 < _N; --_N, ++_F, ++_S)
			*_F = *_S;
		return (_F); }
	static _OI _Putc(_OI _F, const char *_S, size_t _N)
		{for (; 0 < _N; --_N, ++_F, ++_S)
			*_F = _Widen(*_S, (_E *)0);
		return (_F); }
	static _OI _Rep(_OI _F, _E _C, size_t _N)
		{for (; 0 < _N; --_N, ++_F)
			*_F = _C;
		return (_F); }
	};
template<class _E, class _OI>
	locale::id num_put<_E, _OI>::id;


#pragma warning(disable:4231) 

extern template class __declspec(dllimport) numpunct<char>;
extern template class __declspec(dllimport) numpunct<wchar_t>;
extern template class __declspec(dllimport) num_get<char,
                      istreambuf_iterator<char, char_traits<char> > >;
extern template class __declspec(dllimport) num_get<wchar_t,
                      istreambuf_iterator<wchar_t, char_traits<wchar_t> > >;
extern template class __declspec(dllimport) num_put<char,
                      ostreambuf_iterator<char, char_traits<char> > >;
extern template class __declspec(dllimport) num_put<wchar_t,
                      ostreambuf_iterator<wchar_t, char_traits<wchar_t> > >;

#pragma warning(default:4231) 
#line 659 "c:\\programme\\microsoft visual studio\\vc98\\include\\xlocnum"

};

#pragma pack(pop)
#line 664 "c:\\programme\\microsoft visual studio\\vc98\\include\\xlocnum"

#line 666 "c:\\programme\\microsoft visual studio\\vc98\\include\\xlocnum"





#line 10 "c:\\programme\\microsoft visual studio\\vc98\\include\\streambuf"


#pragma pack(push,8)
#line 14 "c:\\programme\\microsoft visual studio\\vc98\\include\\streambuf"
namespace std {
		
template<class _E, class _Tr = char_traits<_E> >
	class basic_streambuf {
protected:
	basic_streambuf()
		: _Loc() {_Init(); }
	basic_streambuf(_Uninitialized)
		: _Loc(_Noinit) {}
public:
	typedef basic_streambuf<_E, _Tr> _Myt;
	typedef _E char_type;
	typedef _Tr traits_type;
	virtual ~basic_streambuf()
		{}
	typedef _Tr::int_type int_type;
	typedef _Tr::pos_type pos_type;
	typedef _Tr::off_type off_type;
	pos_type pubseekoff(off_type _O, ios_base::seekdir _W,
		ios_base::openmode _M = ios_base::in | ios_base::out)
		{return (seekoff(_O, _W, _M)); }
	pos_type pubseekoff(off_type _O, ios_base::seek_dir _W,
		ios_base::open_mode _M)
		{return (pubseekoff(_O, (ios_base::seekdir)_W,
			(ios_base::openmode)_M)); }
	pos_type pubseekpos(pos_type _P,
		ios_base::openmode _M = ios_base::in | ios_base::out)
		{return (seekpos(_P, _M)); }
	pos_type pubseekpos(pos_type _P, ios_base::open_mode _M)
		{return (seekpos(_P, (ios_base::openmode)_M)); }
	_Myt *pubsetbuf(_E *_S, streamsize _N)
		{return (setbuf(_S, _N)); }
	locale pubimbue(const locale &_Ln)
		{locale _Lo = _Loc;
		imbue(_Ln);
		_Loc = _Ln;
		return (_Lo); }
	locale getloc()
		{return (_Loc); }
	streamsize in_avail()
		{return (gptr() != 0 && gptr() < egptr()
			? egptr() - gptr() : showmanyc()); }
	int pubsync()
		{return (sync()); }
	int_type sbumpc()
		{return (gptr() != 0 && gptr() < egptr()
			? _Tr::to_int_type(*_Gninc()) : uflow()); }
	int_type sgetc()
		{return (gptr() != 0 && gptr() < egptr()
			? _Tr::to_int_type(*gptr()) : underflow()); }
	streamsize sgetn(_E *_S, streamsize _N)
		{return (xsgetn(_S, _N)); }
	int_type snextc()
		{return (_Tr::eq_int_type(_Tr::eof(), sbumpc())
			? _Tr::eof() : sgetc()); }
	int_type sputbackc(_E _C)
		{return (gptr() != 0 && eback() < gptr()
			&& _Tr::eq(_C, gptr()[-1])
			? _Tr::to_int_type(*_Gndec())
			: pbackfail(_Tr::to_int_type(_C))); }
	void stossc()
		{if (gptr() != 0 && gptr() < egptr())
			_Gninc();
		else
			uflow(); }
	int_type sungetc()
		{return (gptr() != 0 && eback() < gptr()
			? _Tr::to_int_type(*_Gndec()) : pbackfail()); }
	int_type sputc(_E _C)
		{return (pptr() != 0 && pptr() < epptr()
			? _Tr::to_int_type(*_Pninc() = _C)
			: overflow(_Tr::to_int_type(_C))); }
	streamsize sputn(const _E *_S, streamsize _N)
		{return (xsputn(_S, _N)); }
protected:
	_E *eback() const
		{return (*_IGbeg); }
	_E *gptr() const
		{return (*_IGnext); }
	_E *pbase() const
		{return (*_IPbeg); }
	_E *pptr() const
		{return (*_IPnext); }
	_E *egptr() const
		{return (*_IGnext + *_IGcnt); }
	void gbump(int _N)
		{*_IGcnt -= _N;
		*_IGnext += _N; }
	void setg(_E *_B, _E *_N, _E *_L)
		{*_IGbeg = _B, *_IGnext = _N, *_IGcnt = _L - _N; }
	_E *epptr() const
		{return (*_IPnext + *_IPcnt); }
	_E *_Gndec()
		{++*_IGcnt;
		return (--*_IGnext); }
	_E *_Gninc()
		{--*_IGcnt;
		return ((*_IGnext)++); }
	void pbump(int _N)
		{*_IPcnt -= _N;
		*_IPnext += _N; }
	void setp(_E *_B, _E *_L)
		{*_IPbeg = _B, *_IPnext = _B, *_IPcnt = _L - _B; }
	void setp(_E *_B, _E *_N, _E *_L)
		{*_IPbeg = _B, *_IPnext = _N, *_IPcnt = _L - _N; }
	_E *_Pninc()
		{--*_IPcnt;
		return ((*_IPnext)++); }
	void _Init()
		{_IGbeg = &_Gbeg, _IPbeg = &_Pbeg;
		_IGnext = &_Gnext, _IPnext = &_Pnext;
		_IGcnt = &_Gcnt, _IPcnt = &_Pcnt;
		setp(0, 0), setg(0, 0, 0); }
	void _Init(_E **_Gb, _E **_Gn, int *_Gc,
		_E **_Pb, _E **_Pn, int *_Pc)
		{_IGbeg = _Gb, _IPbeg = _Pb;
		_IGnext = _Gn, _IPnext = _Pn;
		_IGcnt = _Gc, _IPcnt = _Pc; }
	virtual int_type overflow(int_type = _Tr::eof())
		{return (_Tr::eof()); }
	virtual int_type pbackfail(int_type = _Tr::eof())
		{return (_Tr::eof()); }
	virtual int showmanyc()
		{return (0); }
	virtual int_type underflow()
		{return (_Tr::eof()); }
	virtual int_type uflow()
		{return (_Tr::eq_int_type(_Tr::eof(), underflow())
			? _Tr::eof() : _Tr::to_int_type(*_Gninc())); }
	virtual streamsize xsgetn(_E * _S, streamsize _N)
		{int_type _C;
		streamsize _M, _Ns;
		for (_Ns = 0; 0 < _N; )
			if (gptr() != 0 && 0 < (_M = egptr() - gptr()))
				{if (_N < _M)
					_M = _N;
				_Tr::copy(_S, gptr(), _M);
				_S += _M, _Ns += _M, _N -= _M, gbump(_M); }
			else if (_Tr::eq_int_type(_Tr::eof(), _C = uflow()))
				break;
			else
				*_S++ = _Tr::to_char_type(_C), ++_Ns, --_N;
		return (_Ns); }
	virtual streamsize xsputn(const _E *_S, streamsize _N)
		{streamsize _M, _Ns;
		for (_Ns = 0; 0 < _N; )
			if (pptr() != 0 && 0 < (_M = epptr() - pptr()))
				{if (_N < _M)
					_M = _N;
				_Tr::copy(pptr(), _S, _M);
				_S += _M, _Ns += _M, _N -= _M, pbump(_M); }
			else if (_Tr::eq_int_type(_Tr::eof(),
				overflow(_Tr::to_int_type(*_S))))
				break;
			else
				++_S, ++_Ns, --_N;
		return (_Ns); }
	virtual pos_type seekoff(off_type, ios_base::seekdir,
		ios_base::openmode = ios_base::in | ios_base::out)
		{return (streampos(_BADOFF)); }
	virtual pos_type seekpos(pos_type,
		ios_base::openmode = ios_base::in | ios_base::out)
		{return (streampos(_BADOFF)); }
	virtual _Myt *setbuf(_E *, streamsize)
		{return (this); }
	virtual int sync()
		{return (0); }
	virtual void imbue(const locale& _Loc)
		{}
private:
	_E *_Gbeg, *_Pbeg;
	_E **_IGbeg, **_IPbeg;
	_E *_Gnext, *_Pnext;
	_E **_IGnext, **_IPnext;
	int _Gcnt, _Pcnt;
	int *_IGcnt, *_IPcnt;
	locale _Loc;
	};


#pragma warning(disable:4231) 
extern template class __declspec(dllimport) basic_streambuf<char, char_traits<char> >;
extern template class __declspec(dllimport) basic_streambuf<wchar_t, char_traits<wchar_t> >;
#pragma warning(default:4231) 
#line 199 "c:\\programme\\microsoft visual studio\\vc98\\include\\streambuf"

};

#pragma pack(pop)
#line 204 "c:\\programme\\microsoft visual studio\\vc98\\include\\streambuf"

#line 206 "c:\\programme\\microsoft visual studio\\vc98\\include\\streambuf"





#line 10 "c:\\programme\\microsoft visual studio\\vc98\\include\\ios"


#pragma pack(push,8)
#line 14 "c:\\programme\\microsoft visual studio\\vc98\\include\\ios"
namespace std {
		
template<class _E, class _Tr = char_traits<_E> >
	class basic_ios : public ios_base {
public:
	typedef basic_ios<_E, _Tr> _Myt;
	typedef basic_ostream<_E, _Tr> _Myos;
	typedef basic_streambuf<_E, _Tr> _Mysb;
	typedef ctype<_E> _Ctype;
	explicit basic_ios(_Mysb *_S)
		{init(_S); }
	basic_ios(const _Myt& _R)
		{init(0), *this = _R; }
	virtual ~basic_ios()
		{}
	typedef _E char_type;
	typedef _Tr traits_type;
	typedef _Tr::int_type int_type;
	typedef _Tr::pos_type pos_type;
	typedef _Tr::off_type off_type;
	void clear(iostate _St = goodbit, bool _Ex = false)
		{ios_base::clear(_Sb == 0 ? (int)_St | (int)badbit
			: (int)_St, _Ex); }
	void clear(io_state _St)
		{clear((iostate)_St); }
	void setstate(iostate _St, bool _Ex = false)
		{if (_St != goodbit)
			clear((iostate)((int)rdstate() | (int)_St), _Ex); }
	void setstate(io_state _St)
		{setstate((iostate)_St); }
	_Myt& copyfmt(const _Myt& _R)
		{_Tiestr = _R.tie();
		_Fillch = _R.fill();
		ios_base::copyfmt(_R);
		return (*this); }
	_Myos *tie() const
		{return (_Tiestr); }
	_Myos *tie(_Myos *_N)
		{_Myos *_O = _Tiestr;
		_Tiestr = _N;
		return (_O); }
	_Mysb *rdbuf() const
		{return (_Sb); }
	_Mysb *rdbuf(_Mysb *_N)
		{_Mysb *_O = _Sb;
		_Sb = _N;
		clear();
		return (_O); }
	locale imbue(const locale& _Ln)
		{if (rdbuf() != 0)
			rdbuf()->pubimbue(_Ln);
		return (ios_base::imbue(_Ln)); }
	_E fill() const
		{return (_Fillch); }
	_E fill(_E _Nf)
		{_E _Of = _Fillch;
		_Fillch = _Nf;
		return (_Of); }
	char narrow(_E _C, char _D = '\0') const
		{const _Ctype& _Fac = use_facet(getloc(), (_Ctype *)0, true);
		return (_Fac.narrow(_C, _D)); }
	_E widen(char _C) const
		{const _Ctype& _Fac = use_facet(getloc(), (_Ctype *)0, true);
		return (_Fac.widen(_C)); }
protected:
	void init(_Mysb *_S = 0,
		bool _Isstd = false)
		{_Sb = _S;
		_Tiestr = 0;
		_Fillch = _Widen(' ', (_E *)0);
		_Init();
		if (_Sb == 0)
			setstate(badbit);
		if (_Isstd)
			_Addstd(); }
	basic_ios()
		{}
private:
	_Mysb *_Sb;
	_Myos *_Tiestr;
	_E _Fillch;
	};


#pragma warning(disable:4231) 
extern template class __declspec(dllimport) basic_ios<char, char_traits<char> >;
extern template class __declspec(dllimport) basic_ios<wchar_t, char_traits<wchar_t> >;
#pragma warning(default:4231) 
#line 103 "c:\\programme\\microsoft visual studio\\vc98\\include\\ios"

		
inline ios_base& __cdecl boolalpha(ios_base& _I)
	{_I.setf(ios_base::boolalpha);
	return (_I); }
inline ios_base& __cdecl dec(ios_base& _I)
	{_I.setf(ios_base::dec, ios_base::basefield);
	return (_I); }
inline ios_base& __cdecl fixed(ios_base& _I)
	{_I.setf(ios_base::fixed, ios_base::floatfield);
	return (_I); }
inline ios_base& __cdecl hex(ios_base& _I)
	{_I.setf(ios_base::hex, ios_base::basefield);
	return (_I); }
inline ios_base& __cdecl internal(ios_base& _I)
	{_I.setf(ios_base::internal, ios_base::adjustfield);
	return (_I); }
inline ios_base& __cdecl left(ios_base& _I)
	{_I.setf(ios_base::left, ios_base::adjustfield);
	return (_I); }
inline ios_base& __cdecl noboolalpha(ios_base& _I)
	{_I.unsetf(ios_base::boolalpha);
	return (_I); }
inline ios_base& __cdecl noshowbase(ios_base& _I)
	{_I.unsetf(ios_base::showbase);
	return (_I); }
inline ios_base& __cdecl noshowpoint(ios_base& _I)
	{_I.unsetf(ios_base::showpoint);
	return (_I); }
inline ios_base& __cdecl noshowpos(ios_base& _I)
	{_I.unsetf(ios_base::showpos);
	return (_I); }
inline ios_base& __cdecl noskipws(ios_base& _I)
	{_I.unsetf(ios_base::skipws);
	return (_I); }
inline ios_base& __cdecl nounitbuf(ios_base& _I)
	{_I.unsetf(ios_base::unitbuf);
	return (_I); }
inline ios_base& __cdecl nouppercase(ios_base& _I)
	{_I.unsetf(ios_base::uppercase);
	return (_I); }
inline ios_base& __cdecl oct(ios_base& _I)
	{_I.setf(ios_base::oct, ios_base::basefield);
	return (_I); }
inline ios_base& __cdecl right(ios_base& _I)
	{_I.setf(ios_base::right, ios_base::adjustfield);
	return (_I); }
inline ios_base& __cdecl scientific(ios_base& _I)
	{_I.setf(ios_base::scientific, ios_base::floatfield);
	return (_I); }
inline ios_base& __cdecl showbase(ios_base& _I)
	{_I.setf(ios_base::showbase);
	return (_I); }
inline ios_base& __cdecl showpoint(ios_base& _I)
	{_I.setf(ios_base::showpoint);
	return (_I); }
inline ios_base& __cdecl showpos(ios_base& _I)
	{_I.setf(ios_base::showpos);
	return (_I); }
inline ios_base& __cdecl skipws(ios_base& _I)
	{_I.setf(ios_base::skipws);
	return (_I); }
inline ios_base& __cdecl unitbuf(ios_base& _I)
	{_I.setf(ios_base::unitbuf);
	return (_I); }
inline ios_base& __cdecl uppercase(ios_base& _I)
	{_I.setf(ios_base::uppercase);
	return (_I); }
};

#pragma pack(pop)
#line 175 "c:\\programme\\microsoft visual studio\\vc98\\include\\ios"

#line 177 "c:\\programme\\microsoft visual studio\\vc98\\include\\ios"





#line 10 "c:\\programme\\microsoft visual studio\\vc98\\include\\ostream"


#pragma pack(push,8)
#line 14 "c:\\programme\\microsoft visual studio\\vc98\\include\\ostream"
		
 
 

 

namespace std {
		
template<class _E, class _Tr = char_traits<_E> >
	class basic_ostream : virtual public basic_ios<_E, _Tr> {
public:
	typedef basic_ostream<_E, _Tr> _Myt;
	typedef basic_ios<_E, _Tr> _Myios;
	typedef basic_streambuf<_E, _Tr> _Mysb;
	typedef ostreambuf_iterator<_E, _Tr> _Iter;
	typedef num_put<_E, _Iter> _Nput;
	explicit basic_ostream(basic_streambuf<_E, _Tr> *_S,
		bool _Isstd = false, bool _Doinit = true)
		{if (_Doinit)
		    init(_S, _Isstd); }
	basic_ostream(_Uninitialized)
		{_Addstd(); }
	virtual ~basic_ostream()
		{}
	class sentry {
	public:
		explicit sentry(_Myt& _Os)
			: _Ok(_Os.opfx()), _Ostr(_Os) {}
		~sentry()
			{if (!uncaught_exception())
				_Ostr.osfx(); }
		operator bool() const
			{return (_Ok); }
	private:
		bool _Ok;
		_Myt& _Ostr;
		};
	bool opfx()
		{if (good() && tie() != 0)
			tie()->flush();
		return (good()); }
	void osfx()
		{if (flags() & unitbuf)
			flush(); }
	_Myt& operator<<(_Myt& (__cdecl *_F)(_Myt&))
		{return ((*_F)(*this)); }
	_Myt& operator<<(_Myios& (__cdecl *_F)(_Myios&))
		{(*_F)(*(_Myios *)this);
		return (*this); }
	_Myt& operator<<(ios_base& (__cdecl *_F)(ios_base&))
		{(*_F)(*(ios_base *)this);
		return (*this); }
	_Myt& operator<<(_Bool _X)
		{iostate _St = goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{const _Nput& _Fac = use_facet(getloc(), (_Nput *)0, true);
			try {
			if (_Fac.put(_Iter(rdbuf()), *this,
				fill(), _X).failed())
				_St |= badbit;
			} catch (...) { setstate(ios_base::badbit, true); } }
		setstate(_St);
		return (*this); }
	_Myt& operator<<(short _X)
		{iostate _St = goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{const _Nput& _Fac = use_facet(getloc(), (_Nput *)0, true);
			fmtflags _Bfl = flags() & basefield;
			long _Y = (_Bfl == oct || _Bfl == hex)
				? (long)(unsigned short)_X : (long)_X;
			try {
			if (_Fac.put(_Iter(rdbuf()), *this,
				fill(), _Y).failed())
				_St |= badbit;
			} catch (...) { setstate(ios_base::badbit, true); } }
		setstate(_St);
		return (*this); }
	_Myt& operator<<(unsigned short _X)
		{iostate _St = goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{const _Nput& _Fac = use_facet(getloc(), (_Nput *)0, true);
			try {
			if (_Fac.put(_Iter(rdbuf()), *this,
				fill(), (unsigned long)_X).failed())
				_St |= badbit;
			} catch (...) { setstate(ios_base::badbit, true); } }
		setstate(_St);
		return (*this); }
	_Myt& operator<<(int _X)
		{iostate _St = goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{const _Nput& _Fac = use_facet(getloc(), (_Nput *)0, true);
			fmtflags _Bfl = flags() & basefield;
			long _Y = (_Bfl == oct || _Bfl == hex)
				? (long)(unsigned int)_X : (long)_X;
			try {
			if (_Fac.put(_Iter(rdbuf()), *this,
				fill(), _Y).failed())
				_St |= badbit;
			} catch (...) { setstate(ios_base::badbit, true); } }
		setstate(_St);
		return (*this); }
	_Myt& operator<<(unsigned int _X)
		{iostate _St = goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{const _Nput& _Fac = use_facet(getloc(), (_Nput *)0, true);
			try {
			if (_Fac.put(_Iter(rdbuf()), *this,
				fill(), (unsigned long)_X).failed())
				_St |= badbit;
			} catch (...) { setstate(ios_base::badbit, true); } }
		setstate(_St);
		return (*this); }
	_Myt& operator<<(long _X)
		{iostate _St = goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{const _Nput& _Fac = use_facet(getloc(), (_Nput *)0, true);
			try {
			if (_Fac.put(_Iter(rdbuf()), *this,
				fill(), _X).failed())
				_St |= badbit;
			} catch (...) { setstate(ios_base::badbit, true); } }
		setstate(_St);
		return (*this); }
	_Myt& operator<<(unsigned long _X)
		{iostate _St = goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{const _Nput& _Fac = use_facet(getloc(), (_Nput *)0, true);
			try {
			if (_Fac.put(_Iter(rdbuf()), *this,
				fill(), _X).failed())
				_St |= badbit;
			} catch (...) { setstate(ios_base::badbit, true); } }
		setstate(_St);
		return (*this); }
	_Myt& operator<<(float _X)
		{iostate _St = goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{const _Nput& _Fac = use_facet(getloc(), (_Nput *)0, true);
			try {
			if (_Fac.put(_Iter(rdbuf()), *this,
				fill(), (double)_X).failed())
				_St |= badbit;
			} catch (...) { setstate(ios_base::badbit, true); } }
		setstate(_St);
		return (*this); }
	_Myt& operator<<(double _X)
		{iostate _St = goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{const _Nput& _Fac = use_facet(getloc(), (_Nput *)0, true);
			try {
			if (_Fac.put(_Iter(rdbuf()), *this,
				fill(), _X).failed())
				_St |= badbit;
			} catch (...) { setstate(ios_base::badbit, true); } }
		setstate(_St);
		return (*this); }
	_Myt& operator<<(long double _X)
		{iostate _St = goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{const _Nput& _Fac = use_facet(getloc(), (_Nput *)0, true);
			try {
			if (_Fac.put(_Iter(rdbuf()), *this,
				fill(), _X).failed())
				_St |= badbit;
			} catch (...) { setstate(ios_base::badbit, true); } }
		setstate(_St);
		return (*this); }
	_Myt& operator<<(const void *_X)
		{iostate _St = goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{const _Nput& _Fac = use_facet(getloc(), (_Nput *)0, true);
			try {
			if (_Fac.put(_Iter(rdbuf()), *this,
				fill(), _X).failed())
				_St |= badbit;
			} catch (...) { setstate(ios_base::badbit, true); } }
		setstate(_St);
		return (*this); }
	_Myt& operator<<(_Mysb *_Pb)
		{iostate _St = goodbit;
		bool _Copied = false;
		const sentry _Ok(*this);
		if (_Ok && _Pb != 0)
			for (int_type _C = _Tr::eof(); ; _Copied = true)
				{try {
				_C = _Tr::eq_int_type(_Tr::eof(), _C)
					? _Pb->sgetc() : _Pb->snextc();
				} catch (...) {
					setstate(failbit);
					throw;
				}
				if (_Tr::eq_int_type(_Tr::eof(),_C))
					break;
				try {
					if (_Tr::eq_int_type(_Tr::eof(),
						rdbuf()->sputc(_Tr::to_char_type(_C))))
						{_St |= badbit;
						break; }
				} catch (...) { setstate(ios_base::badbit, true); } }
		width(0);
		setstate(!_Copied ? _St | failbit : _St);
		return (*this); }
	_Myt& put(_E _X)
		{iostate _St = goodbit;
		const sentry _Ok(*this);
		if (!_Ok)
			_St |= badbit;
		else
			{try {
			 if (_Tr::eq_int_type(_Tr::eof(),
				rdbuf()->sputc(_X)))
				_St |= badbit;
			} catch (...) { setstate(ios_base::badbit, true); } }
		setstate(_St);
		return (*this); }
	_Myt& write(const _E *_S, streamsize _N)
		{iostate _St = goodbit;
		const sentry _Ok(*this);
		if (!_Ok)
			_St |= badbit;
		else
			{try {
			if (rdbuf()->sputn(_S, _N) != _N)
				_St |= badbit;
			} catch (...) { setstate(ios_base::badbit, true); } }
		setstate(_St);
		return (*this); }
	_Myt& flush()
		{iostate _St = goodbit;
		if (!fail() && rdbuf()->pubsync() == -1)
			_St |= badbit;
		setstate(_St);
		return (*this); }
	_Myt& seekp(pos_type _P)
		{if (!fail())
			rdbuf()->pubseekpos(_P, out);
		return (*this); }
	_Myt& seekp(off_type _O, ios_base::seekdir _W)
		{if (!fail())
			rdbuf()->pubseekoff(_O, _W, out);
		return (*this); }
	pos_type tellp()
		{if (!fail())
			return (rdbuf()->pubseekoff(0, cur, out));
		else
			return (streampos(_BADOFF)); }
	};



#pragma warning(disable:4231) 
extern template class __declspec(dllimport) basic_ostream<char, char_traits<char> >;
extern template class __declspec(dllimport) basic_ostream<wchar_t, char_traits<wchar_t> >;
#pragma warning(default:4231) 
#line 281 "c:\\programme\\microsoft visual studio\\vc98\\include\\ostream"


		
template<class _E, class _Tr> inline
	basic_ostream<_E, _Tr>& __cdecl operator<<(
		basic_ostream<_E, _Tr>& _O, const _E *_X)
	{typedef basic_ostream<_E, _Tr> _Myos;
	ios_base::iostate _St = ios_base::goodbit;
	size_t _N = _Tr::length(_X);
	size_t _M = _O.width() <= 0 || _O.width() <= _N
		? 0 : _O.width() - _N;
	const _Myos::sentry _Ok(_O);
	if (!_Ok)
		_St |= ios_base::badbit;
	else
		{try {
		if ((_O.flags() & ios_base::adjustfield)
			!= ios_base::left)
			for (; 0 < _M; --_M)
				if (_Tr::eq_int_type(_Tr::eof(),
					_O.rdbuf()->sputc(_O.fill())))
					{_St |= ios_base::badbit;
					break; }
		if (_St == ios_base::goodbit
			&& _O.rdbuf()->sputn(_X, _N) != _N)
			_St |= ios_base::badbit;
		if (_St == ios_base::goodbit)
			for (; 0 < _M; --_M)
				if (_Tr::eq_int_type(_Tr::eof(),
					_O.rdbuf()->sputc(_O.fill())))
					{_St |= ios_base::badbit;
					break; }
		_O.width(0);
		} catch (...) { (_O).setstate(ios_base::badbit, true); } }
	_O.setstate(_St);
	return (_O); }
template<class _E, class _Tr> inline
	basic_ostream<_E, _Tr>& __cdecl operator<<(
		basic_ostream<_E, _Tr>& _O, _E _C)
	{typedef basic_ostream<_E, _Tr> _Myos;
	ios_base::iostate _St = ios_base::goodbit;
	const _Myos::sentry _Ok(_O);
	if (_Ok)
		{size_t _M = _O.width() <= 1 ? 0 : _O.width() - 1;
		try {
		if ((_O.flags() & ios_base::adjustfield)
			!= ios_base::left)
			for (; _St == ios_base::goodbit && 0 < _M; --_M)
				if (_Tr::eq_int_type(_Tr::eof(),
					_O.rdbuf()->sputc(_O.fill())))
					_St |= ios_base::badbit;
		if (_St == ios_base::goodbit
			&& _Tr::eq_int_type(_Tr::eof(),
				_O.rdbuf()->sputc(_C)))
			_St |= ios_base::badbit;
		for (; _St == ios_base::goodbit && 0 < _M; --_M)
			if (_Tr::eq_int_type(_Tr::eof(),
				_O.rdbuf()->sputc(_O.fill())))
				_St |= ios_base::badbit;
		} catch (...) { (_O).setstate(ios_base::badbit, true); } }
	_O.width(0);
	_O.setstate(_St);
	return (_O); }
template<class _E, class _Tr> inline
	basic_ostream<_E, _Tr>& __cdecl operator<<(
		basic_ostream<_E, _Tr>& _O, const signed char *_X)
	{return (_O << (const char *)_X); }
template<class _E, class _Tr> inline
	basic_ostream<_E, _Tr>& __cdecl operator<<(
		basic_ostream<_E, _Tr>& _O, const signed char _C)
	{return (_O << (char)_C); }
template<class _E, class _Tr> inline
	basic_ostream<_E, _Tr>& __cdecl operator<<(
		basic_ostream<_E, _Tr>& _O, const unsigned char *_X)
	{return (_O << (const char *)_X); }
template<class _E, class _Tr> inline
	basic_ostream<_E, _Tr>& __cdecl operator<<(
		basic_ostream<_E, _Tr>& _O, const unsigned char _C)
	{return (_O << (char)_C); }
template<class _E, class _Tr> inline
	basic_ostream<_E, _Tr>& __cdecl operator<<(
		basic_ostream<_E, _Tr>& _O, const signed short *_X)
	{return (_O << (const wchar_t *)_X); }
		
template<class _E, class _Tr> inline
	basic_ostream<_E, _Tr>&
		__cdecl endl(basic_ostream<_E, _Tr>& _O)
	{_O.put(_O.widen('\n'));
	_O.flush();
	return (_O); }
__declspec(dllimport) inline basic_ostream<char, char_traits<char> >&
	__cdecl endl(basic_ostream<char, char_traits<char> >& _O)
	{_O.put('\n');
	_O.flush();
	return (_O); }
__declspec(dllimport) inline basic_ostream<wchar_t, char_traits<wchar_t> >&
	__cdecl endl(basic_ostream<wchar_t,
		char_traits<wchar_t> >& _O)
	{_O.put('\n');
	_O.flush();
	return (_O); }
template<class _E, class _Tr> inline
	basic_ostream<_E, _Tr>&
		__cdecl ends(basic_ostream<_E, _Tr>& _O)
	{_O.put(_E('\0'));
	return (_O); }
__declspec(dllimport) inline basic_ostream<char, char_traits<char> >&
	__cdecl ends(basic_ostream<char, char_traits<char> >& _O)
	{_O.put('\0');
	return (_O); }
__declspec(dllimport) inline basic_ostream<wchar_t, char_traits<wchar_t> >&
	__cdecl ends(basic_ostream<wchar_t,
		char_traits<wchar_t> >& _O)
	{_O.put('\0');
	return (_O); }
template<class _E, class _Tr> inline
	basic_ostream<_E, _Tr>&
		__cdecl flush(basic_ostream<_E, _Tr>& _O)
	{_O.flush();
	return (_O); }
__declspec(dllimport) inline basic_ostream<char, char_traits<char> >&
	__cdecl flush(basic_ostream<char, char_traits<char> >& _O)
	{_O.flush();
	return (_O); }
__declspec(dllimport) inline basic_ostream<wchar_t, char_traits<wchar_t> >&
	__cdecl flush(basic_ostream<wchar_t,
		char_traits<wchar_t> >& _O)
	{_O.flush();
	return (_O); }


#pragma warning(disable:4231) 

extern template __declspec(dllimport) basic_ostream<char, char_traits<char> >& __cdecl operator<<(
       basic_ostream<char, char_traits<char> >&, const char *);
extern template __declspec(dllimport) basic_ostream<char, char_traits<char> >& __cdecl operator<<(
       basic_ostream<char, char_traits<char> >&, char);
extern template __declspec(dllimport) basic_ostream<char, char_traits<char> >& __cdecl operator<<(
       basic_ostream<char, char_traits<char> >&, const signed char *);
extern template __declspec(dllimport) basic_ostream<char, char_traits<char> >& __cdecl operator<<(
       basic_ostream<char, char_traits<char> >&, const signed char);
extern template __declspec(dllimport) basic_ostream<char, char_traits<char> >& __cdecl operator<<(
       basic_ostream<char, char_traits<char> >&, const unsigned char *);
extern template __declspec(dllimport) basic_ostream<char, char_traits<char> >& __cdecl operator<<(
       basic_ostream<char, char_traits<char> >&, const unsigned char);
extern template __declspec(dllimport) basic_ostream<wchar_t, char_traits<wchar_t> >& __cdecl operator<<(
       basic_ostream<wchar_t, char_traits<wchar_t> >&, const wchar_t *);
extern template __declspec(dllimport) basic_ostream<wchar_t, char_traits<wchar_t> >& __cdecl operator<<(
       basic_ostream<wchar_t, char_traits<wchar_t> >&, wchar_t);
extern template __declspec(dllimport) basic_ostream<wchar_t, char_traits<wchar_t> >& __cdecl operator<<(
       basic_ostream<wchar_t, char_traits<wchar_t> >&, const signed short *);

#pragma warning(default:4231) 
#line 435 "c:\\programme\\microsoft visual studio\\vc98\\include\\ostream"

};

#pragma pack(pop)
#line 440 "c:\\programme\\microsoft visual studio\\vc98\\include\\ostream"

#line 442 "c:\\programme\\microsoft visual studio\\vc98\\include\\ostream"





#line 10 "c:\\programme\\microsoft visual studio\\vc98\\include\\istream"


#pragma pack(push,8)
#line 14 "c:\\programme\\microsoft visual studio\\vc98\\include\\istream"
namespace std {
		
template<class _E, class _Tr = char_traits<_E> >
	class basic_istream : virtual public basic_ios<_E, _Tr> {
public:
	typedef basic_istream<_E, _Tr> _Myt;
	typedef basic_ios<_E, _Tr> _Myios;
	typedef basic_streambuf<_E, _Tr> _Mysb;
	typedef istreambuf_iterator<_E, _Tr> _Iter;
	typedef ctype<_E> _Ctype;
	typedef num_get<_E, _Iter> _Nget;
	explicit basic_istream(_Mysb *_S, bool _Isstd = false)
		: _Chcount(0) {init(_S, _Isstd); }
	basic_istream(_Uninitialized)
		{_Addstd(); }
	virtual ~basic_istream()
		{}
	class sentry {
	public:
		explicit sentry(_Myt& _Is, bool _Noskip = false)
			: _Ok(_Is.ipfx(_Noskip)) {}
		operator bool() const
			{return (_Ok); }
	private:
		bool _Ok;
		};
	bool ipfx(bool _Noskip = false)
		{if (good())
			{if (tie() != 0)
				tie()->flush();
			if (!_Noskip && flags() & skipws)
				{const _Ctype& _Fac = use_facet(getloc(), (_Ctype *)0, true);
				try {
				int_type _C = rdbuf()->sgetc();
				while (!_Tr::eq_int_type(_Tr::eof(), _C)
					&& _Fac.is(_Ctype::space,
						_Tr::to_char_type(_C)))
					_C = rdbuf()->snextc();
				} catch (...) { setstate(ios_base::badbit, true); } }
			if (good())
				return (true); }
		setstate(failbit);
		return (false); }
	void isfx()
		{}
	_Myt& operator>>(_Myt& (__cdecl *_F)(_Myt&))
		{return ((*_F)(*this)); }
	_Myt& operator>>(_Myios& (__cdecl *_F)(_Myios&))
		{(*_F)(*(_Myios *)this);
		return (*this); }
	_Myt& operator>>(ios_base& (__cdecl *_F)(ios_base&))
		{(*_F)(*(ios_base *)this);
		return (*this); }
	_Myt& operator>>(_Bool& _X)
		{iostate _St = goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{const _Nget& _Fac = use_facet(getloc(), (_Nget *)0, true);
			try {
			_Fac.get(_Iter(rdbuf()), _Iter(0), *this, _St, _X);
			} catch (...) { setstate(ios_base::badbit, true); } }
		setstate(_St);
		return (*this); }
	_Myt& operator>>(short& _X)
		{iostate _St = goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{long _Y;
			const _Nget& _Fac = use_facet(getloc(), (_Nget *)0, true);
			try {
			_Fac.get(_Iter(rdbuf()), _Iter(0), *this, _St, _Y);
			} catch (...) { setstate(ios_base::badbit, true); }
			if (_St & failbit || _Y < (-32768) || 32767 < _Y)
				_St |= failbit;
			else
				_X = (short)_Y; }
		setstate(_St);
		return (*this); }
	_Myt& operator>>(unsigned short& _X)
		{iostate _St = goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{const _Nget& _Fac = use_facet(getloc(), (_Nget *)0, true);
			try {
			_Fac.get(_Iter(rdbuf()), _Iter(0), *this, _St, _X);
			} catch (...) { setstate(ios_base::badbit, true); } }
		setstate(_St);
		return (*this); }
	_Myt& operator>>(int& _X)
		{iostate _St = goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{long _Y;
			const _Nget& _Fac = use_facet(getloc(), (_Nget *)0, true);
			try {
			_Fac.get(_Iter(rdbuf()), _Iter(0), *this, _St, _Y);
			} catch (...) { setstate(ios_base::badbit, true); }
			if (_St & failbit || _Y < (-2147483647 - 1) || 2147483647 < _Y)
				_St |= failbit;
			else
				_X = _Y; }
		setstate(_St);
		return (*this); }
	_Myt& operator>>(unsigned int& _X)
		{iostate _St = goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{const _Nget& _Fac = use_facet(getloc(), (_Nget *)0, true);
			try {
			_Fac.get(_Iter(rdbuf()), _Iter(0), *this, _St, _X);
			} catch (...) { setstate(ios_base::badbit, true); } }
		setstate(_St);
		return (*this); }
	_Myt& operator>>(long& _X)
		{iostate _St = goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{const _Nget& _Fac = use_facet(getloc(), (_Nget *)0, true);
			try {
			_Fac.get(_Iter(rdbuf()), _Iter(0), *this, _St, _X);
			} catch (...) { setstate(ios_base::badbit, true); } }
		setstate(_St);
		return (*this); }
	_Myt& operator>>(unsigned long& _X)
		{iostate _St = goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{const _Nget& _Fac = use_facet(getloc(), (_Nget *)0, true);
			try {
			_Fac.get(_Iter(rdbuf()), _Iter(0), *this, _St, _X);
			} catch (...) { setstate(ios_base::badbit, true); } }
		setstate(_St);
		return (*this); }
	_Myt& operator>>(float& _X)
		{iostate _St = goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{const _Nget& _Fac = use_facet(getloc(), (_Nget *)0, true);
			try {
			_Fac.get(_Iter(rdbuf()), _Iter(0), *this, _St, _X);
			} catch (...) { setstate(ios_base::badbit, true); } }
		setstate(_St);
		return (*this); }
	_Myt& operator>>(double& _X)
		{iostate _St = goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{const _Nget& _Fac = use_facet(getloc(), (_Nget *)0, true);
			try {
			_Fac.get(_Iter(rdbuf()), _Iter(0), *this, _St, _X);
			} catch (...) { setstate(ios_base::badbit, true); } }
		setstate(_St);
		return (*this); }
	_Myt& operator>>(long double& _X)
		{iostate _St = goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{const _Nget& _Fac = use_facet(getloc(), (_Nget *)0, true);
			try {
			_Fac.get(_Iter(rdbuf()), _Iter(0), *this, _St, _X);
			} catch (...) { setstate(ios_base::badbit, true); } }
		setstate(_St);
		return (*this); }
	_Myt& operator>>(void *& _X)
		{iostate _St = goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{const _Nget& _Fac = use_facet(getloc(), (_Nget *)0, true);
			try {
			_Fac.get(_Iter(rdbuf()), _Iter(0), *this, _St, _X);
			} catch (...) { setstate(ios_base::badbit, true); } }
		setstate(_St);
		return (*this); }
	_Myt& operator>>(_Mysb *_Pb)
		{iostate _St = goodbit;
		bool _Copied = false;
		const sentry _Ok(*this);
		if (_Ok && _Pb != 0)
			{try {
			int_type _C = rdbuf()->sgetc();
			for (; ; _C = rdbuf()->snextc())
				if (_Tr::eq_int_type(_Tr::eof(), _C))
					{_St |= eofbit;
					break; }
				else
					{try {
						if (_Tr::eq_int_type(_Tr::eof(),
							_Pb->sputc(_Tr::to_char_type(_C))))
							break;
					} catch (...) {
						break;
					}
					_Copied = true; }
			} catch (...) { setstate(ios_base::badbit, true); } }
		setstate(!_Copied ? _St | failbit : _St);
		return (*this); }
	int_type get()
		{int_type _C;
		iostate _St = goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);
		if (!_Ok)
			_C = _Tr::eof();
		else
			{try {
			_C = rdbuf()->sbumpc();
			if (_Tr::eq_int_type(_Tr::eof(), _C))
				_St |= eofbit | failbit;
			else
				++_Chcount;
			} catch (...) { setstate(ios_base::badbit, true); } }
		setstate(_St);
		return (_C); }
	_Myt& get(_E *_S, streamsize _N)
		{return (get(_S, _N, widen('\n'))); }
	_Myt& get(_E *_S, streamsize _N, _E _D)
		{iostate _St = goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);
		if (_Ok && 0 < _N)
			{try {
			int_type _C = rdbuf()->sgetc();
			for (; 0 < --_N; _C = rdbuf()->snextc())
				if (_Tr::eq_int_type(_Tr::eof(), _C))
					{_St |= eofbit;
					break; }
				else if (_Tr::to_char_type(_C) == _D)
					break;
				else
					*_S++ = _Tr::to_char_type(_C), ++_Chcount;
			} catch (...) { setstate(ios_base::badbit, true); } }
		setstate(_Chcount == 0 ? _St | failbit : _St);
		*_S = _E(0);
		return (*this); }
	_Myt& get(_E& _X)
		{int_type _C = get();
		if (!_Tr::eq_int_type(_Tr::eof(), _C))
			_X = _Tr::to_char_type(_C);
		return (*this); }
	_Myt& get(_Mysb& _Sb)
		{return (get(_Sb, widen('\n'))); }
	_Myt& get(_Mysb& _Sb, _E _D)
		{iostate _St = goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);
		if (_Ok)
			{try {
			int_type _C = rdbuf()->sgetc();
			for (; ; _C = rdbuf()->snextc())
				if (_Tr::eq_int_type(_Tr::eof(), _C))
					{_St |= eofbit;
					break; }
				else
					{try {
						_E _Ch = _Tr::to_char_type(_C);
						if (_Ch == _D
							|| _Tr::eq_int_type(_Tr::eof(),
								_Sb.sputc(_Ch)))
							break;
					} catch (...) {
						break;
					}
					++_Chcount; }
			} catch (...) { setstate(ios_base::badbit, true); } }
		if (_Chcount == 0)
			_St |= failbit;
		setstate(_St);
		return (*this); }
	_Myt& getline(_E *_S, streamsize _N)
		{return (getline(_S, _N, widen('\n'))); }
	_Myt& getline(_E *_S, streamsize _N, _E _D)
		{iostate _St = goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);
		if (_Ok && 0 < _N)
			{int_type _Di = _Tr::to_int_type(_D);
			try {
			int_type _C = rdbuf()->sgetc();
			for (; ; _C = rdbuf()->snextc())
				if (_Tr::eq_int_type(_Tr::eof(), _C))
					{_St |= eofbit;
					break; }
				else if (_C == _Di)
					{++_Chcount;
					rdbuf()->stossc();
					break; }
				else if (--_N <= 0)
					{_St |= failbit;
					break; }
				else
					{++_Chcount;
					*_S++ = _Tr::to_char_type(_C); }
			} catch (...) { setstate(ios_base::badbit, true); } }
		*_S = _E(0);
		setstate(_Chcount == 0 ? _St | failbit : _St);
		return (*this); }
	_Myt& ignore(streamsize _N = 1, int_type _Di = _Tr::eof())
		{iostate _St = goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);
		if (_Ok && 0 < _N)
			{try {
			for (; ; )
				{int_type _C;
				if (_N != 2147483647 && --_N < 0)
					break;
				else if (_Tr::eq_int_type(_Tr::eof(),
					_C = rdbuf()->sbumpc()))
					{_St |= eofbit;
					break; }
				else
					{++_Chcount;
					if (_C == _Di)
						break; }}
			} catch (...) { setstate(ios_base::badbit, true); } }
		setstate(_St);
		return (*this); }
	_Myt& read(_E *_S, streamsize _N)
		{iostate _St = goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);
		if (_Ok)
			{try {
			const streamsize _M = rdbuf()->sgetn(_S, _N);
			_Chcount += _M;
			if (_M != _N)
				_St |= eofbit | failbit;
			} catch (...) { setstate(ios_base::badbit, true); } }
		setstate(_St);
		return (*this); }
	streamsize readsome(_E *_S, streamsize _N)
		{iostate _St = goodbit;
		_Chcount = 0;
		int _M;
		if (rdbuf() == 0)
			_St |= failbit;
		else if ((_M = rdbuf()->in_avail()) < 0)
			_St |= eofbit;
		else if (0 < _M)
			read(_S, _M < _N ? _M : _N);
		setstate(_St);
		return (gcount()); }
	int_type peek()
		{iostate _St = goodbit;
		_Chcount = 0;
		int_type _C;
		const sentry _Ok(*this, true);
		if (!_Ok)
			_C = _Tr::eof();
		else
			{try {
			if (_Tr::eq_int_type(_Tr::eof(),
				_C = rdbuf()->sgetc()))
				_St |= eofbit;
			} catch (...) { setstate(ios_base::badbit, true); } }
		setstate(_St);
		return (_C); }
	_Myt& putback(_E _X)
		{iostate _St = goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);
		if (_Ok)
			{try {
			if (_Tr::eq_int_type(_Tr::eof(),
				rdbuf()->sputbackc(_X)))
				_St |= badbit;
			} catch (...) { setstate(ios_base::badbit, true); } }
		setstate(_St);
		return (*this); }
	_Myt& unget()
		{iostate _St = goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);
		if (_Ok)
			{try {
			if (_Tr::eq_int_type(_Tr::eof(),
				rdbuf()->sungetc()))
				_St |= badbit;
			} catch (...) { setstate(ios_base::badbit, true); } }
		setstate(_St);
		return (*this); }
	streamsize gcount() const
		{return (_Chcount); }
	int sync()
		{iostate _St = goodbit;
		int _Ans;
		if (rdbuf() == 0)
			_Ans = -1;
		else if (rdbuf()->pubsync() == -1)
			_St |= badbit, _Ans = -1;
		else
			_Ans = 0;
		setstate(_St);
		return (_Ans); }
	_Myt& seekg(pos_type _P)
		{if (!fail())
			rdbuf()->pubseekpos(_P, in);
		return (*this); }
	_Myt& seekg(off_type _O, ios_base::seekdir _W)
		{if (!fail())
			rdbuf()->pubseekoff(_O, _W, in);
		return (*this); }
	pos_type tellg()
		{if (!fail())
			return (rdbuf()->pubseekoff(0, cur, in));
		else
			return (streampos(_BADOFF)); }
private:
	streamsize _Chcount;
	};


#pragma warning(disable:4231) 
extern template class __declspec(dllimport) basic_istream<char, char_traits<char> >;
extern template class __declspec(dllimport) basic_istream<wchar_t, char_traits<wchar_t> >;
#pragma warning(default:4231) 
#line 431 "c:\\programme\\microsoft visual studio\\vc98\\include\\istream"

		
template<class _E, class _Tr = char_traits<_E> >
	class basic_iostream : public basic_istream<_E, _Tr>,
		public basic_ostream<_E, _Tr> {
public:
	explicit basic_iostream(basic_streambuf<_E, _Tr> *_S)
		: basic_istream<_E, _Tr>(_S), basic_ostream<_E, _Tr>(_S, false, false)
		{}
	virtual ~basic_iostream()
		{}
	};


#pragma warning(disable:4231) 
extern template class __declspec(dllimport) basic_iostream<char, char_traits<char> >;
extern template class __declspec(dllimport) basic_iostream<wchar_t, char_traits<wchar_t> >;
#pragma warning(default:4231) 
#line 450 "c:\\programme\\microsoft visual studio\\vc98\\include\\istream"



		
template<class _E, class _Tr> inline
	basic_istream<_E, _Tr>& __cdecl operator>>(
		basic_istream<_E, _Tr>& _I, _E *_X)
	{typedef basic_istream<_E, _Tr> _Myis;
	typedef ctype<_E> _Ctype;
	ios_base::iostate _St = ios_base::goodbit;
	_E *_S = _X;
	const _Myis::sentry _Ok(_I);
	if (_Ok)
		{const _Ctype& _Fac = use_facet(_I.getloc(), (_Ctype *)0, true);
		try {
		int _N = 0 < _I.width() ? _I.width() : 2147483647;
		_Myis::int_type _C = _I.rdbuf()->sgetc();
		for (; 0 < --_N; _C = _I.rdbuf()->snextc())
			if (_Tr::eq_int_type(_Tr::eof(), _C))
				{_St |= ios_base::eofbit;
				break; }
			else if (_Fac.is(_Ctype::space,
				_Tr::to_char_type(_C)))
				break;
			else
				*_S++ = _Tr::to_char_type(_C);
		} catch (...) { (_I).setstate(ios_base::badbit, true); } }
	*_S = _E(0);
	_I.width(0);
	_I.setstate(_S == _X ? _St | ios_base::failbit : _St);
	return (_I); }
template<class _E, class _Tr> inline
	basic_istream<_E, _Tr>& __cdecl operator>>(
		basic_istream<_E, _Tr>& _I, _E& _X)
	{typedef basic_istream<_E, _Tr> _Myis;
	_Myis::int_type _C;
	ios_base::iostate _St = ios_base::goodbit;
	const _Myis::sentry _Ok(_I);
	if (_Ok)
		{try {
		_C = _I.rdbuf()->sbumpc();
		if (_Tr::eq_int_type(_Tr::eof(), _C))
			_St |= ios_base::eofbit | ios_base::failbit;
		else
			_X = _Tr::to_char_type(_C);
		} catch (...) { (_I).setstate(ios_base::badbit, true); } }
	_I.setstate(_St);
	return (_I); }
template<class _E, class _Tr> inline
	basic_istream<_E, _Tr>& __cdecl operator>>(
		basic_istream<_E, _Tr>& _I, signed char *_X)
	{return (_I >> (char *)_X); }
template<class _E, class _Tr> inline
	basic_istream<_E, _Tr>& __cdecl operator>>(
		basic_istream<_E, _Tr>& _I, signed char& _C)
	{return (_I >> (char&)_C); }
template<class _E, class _Tr> inline
	basic_istream<_E, _Tr>& __cdecl operator>>(
		basic_istream<_E, _Tr>& _I, unsigned char *_X)
	{return (_I >> (char *)_X); }
template<class _E, class _Tr> inline
	basic_istream<_E, _Tr>& __cdecl operator>>(
		basic_istream<_E, _Tr>& _I, unsigned char& _C)
	{return (_I >> (char&)_C); }
template<class _E, class _Tr> inline
	basic_istream<_E, _Tr>& __cdecl operator>>(
		basic_istream<_E, _Tr>& _I, signed short * _X)
	{return (_I >> (wchar_t *)_X); }
		
template<class _E, class _Tr> inline
	basic_istream<_E, _Tr>& __cdecl ws(basic_istream<_E, _Tr>& _I)
	{typedef basic_istream<_E, _Tr> _Myis;
	typedef ctype<_E> _Ctype;
	ios_base::iostate _St = ios_base::goodbit;
	const _Myis::sentry _Ok(_I, true);
	if (_Ok)
		{const _Ctype& _Fac = use_facet(_I.getloc(), (_Ctype *)0, true);
		try {
		for (_Tr::int_type _C = _I.rdbuf()->sgetc(); ;
			_C = _I.rdbuf()->snextc())
			if (_Tr::eq_int_type(_Tr::eof(), _C))
				{_St |= ios_base::eofbit;
				break; }
			else if (!_Fac.is(_Ctype::space,
				_Tr::to_char_type(_C)))
				break;
		} catch (...) { (_I).setstate(ios_base::badbit, true); } }
	_I.setstate(_St);
	return (_I); }
__declspec(dllimport) inline basic_istream<char, char_traits<char> >&
	__cdecl ws(basic_istream<char, char_traits<char> >& _I)
	{typedef char _E;
	typedef char_traits<_E> _Tr;
	ios_base::iostate _St = ios_base::goodbit;
	const basic_istream<_E, _Tr>::sentry _Ok(_I, true);
	if (_Ok)
		{const ctype<_E>& _Fac = use_facet(_I.getloc(), (ctype<_E> *)0, true);
		try {
		for (_Tr::int_type _C = _I.rdbuf()->sgetc(); ;
			_C = _I.rdbuf()->snextc())
			if (_Tr::eq_int_type(_Tr::eof(), _C))
				{_St |= ios_base::eofbit;
				break; }
			else if (!_Fac.is(ctype<_E>::space,
				_Tr::to_char_type(_C)))
				break;
		} catch (...) { (_I).setstate(ios_base::badbit, true); } }
	_I.setstate(_St);
	return (_I); }
__declspec(dllimport) inline basic_istream<wchar_t, char_traits<wchar_t> >&
	__cdecl ws(basic_istream<wchar_t, char_traits<wchar_t> >& _I)
	{typedef wchar_t _E;
	typedef char_traits<_E> _Tr;
	ios_base::iostate _St = ios_base::goodbit;
	const basic_istream<_E, _Tr>::sentry _Ok(_I, true);
	if (_Ok)
		{const ctype<_E>& _Fac = use_facet(_I.getloc(), (ctype<_E> *)0, true);
		try {
		for (_Tr::int_type _C = _I.rdbuf()->sgetc(); ;
			_C = _I.rdbuf()->snextc())
			if (_Tr::eq_int_type(_Tr::eof(), _C))
				{_St |= ios_base::eofbit;
				break; }
			else if (_Fac.is(ctype<_E>::space,
				_Tr::to_char_type(_C)))
				break;
		} catch (...) { (_I).setstate(ios_base::badbit, true); } }
	_I.setstate(_St);
	return (_I); }



#pragma warning(disable:4231) 

extern template __declspec(dllimport) basic_istream<char, char_traits<char> >& __cdecl operator>>(
       basic_istream<char, char_traits<char> >&, char *);
extern template __declspec(dllimport) basic_istream<char, char_traits<char> >& __cdecl operator>>(
       basic_istream<char, char_traits<char> >&, char&);
extern template __declspec(dllimport) basic_istream<char, char_traits<char> >& __cdecl operator>>(
       basic_istream<char, char_traits<char> >&, signed char *);
extern template __declspec(dllimport) basic_istream<char, char_traits<char> >& __cdecl operator>>(
       basic_istream<char, char_traits<char> >&, signed char&);
extern template __declspec(dllimport) basic_istream<char, char_traits<char> >& __cdecl operator>>(
       basic_istream<char, char_traits<char> >&, unsigned char *);
extern template __declspec(dllimport) basic_istream<char, char_traits<char> >& __cdecl operator>>(
       basic_istream<char, char_traits<char> >&, unsigned char&);
extern template __declspec(dllimport) basic_istream<wchar_t, char_traits<wchar_t> >& __cdecl operator>>(
       basic_istream<wchar_t, char_traits<wchar_t> >&, wchar_t *);
extern template __declspec(dllimport) basic_istream<wchar_t, char_traits<wchar_t> >& __cdecl operator>>(
       basic_istream<wchar_t, char_traits<wchar_t> >&, wchar_t&);
extern template __declspec(dllimport) basic_istream<wchar_t, char_traits<wchar_t> >& __cdecl operator>>(
       basic_istream<wchar_t, char_traits<wchar_t> >&, signed short *);

#pragma warning(default:4231) 
#line 605 "c:\\programme\\microsoft visual studio\\vc98\\include\\istream"


};

#pragma pack(pop)
#line 611 "c:\\programme\\microsoft visual studio\\vc98\\include\\istream"

#line 613 "c:\\programme\\microsoft visual studio\\vc98\\include\\istream"





#line 10 "c:\\programme\\microsoft visual studio\\vc98\\include\\fstream"



#pragma pack(push,8)
#line 15 "c:\\programme\\microsoft visual studio\\vc98\\include\\fstream"
namespace std {

extern __declspec(dllimport) FILE *__cdecl __Fiopen(const char *,ios_base::openmode);

		
template<class _E> inline
	bool _Fgetc(_E& _C, _iobuf *_Fi)
	{return (fread(&_C, sizeof (_E), 1, _Fi) == 1); }
inline bool _Fgetc(char& _C, _iobuf *_Fi)
	{int _Ch;
	if ((_Ch = fgetc(_Fi)) == (-1))
		return (false);
	else
		{_C = (char)_Ch;
		return (true); }} 
inline bool _Fgetc(wchar_t& _C, _iobuf *_Fi)
	{_Wint_t _Ch;
	if ((_Ch = fgetwc(_Fi)) == (wint_t)(0xFFFF))
		return (false);
	else
		{_C = _Ch;
		return (true); }}
		
template<class _E> inline
	bool _Fputc(_E _C, _iobuf *_Fi)
	{return (fwrite(&_C, sizeof (_E), 1, _Fi) == 1); }
inline bool _Fputc(char _C, _iobuf *_Fi)
	{return (fputc(_C, _Fi) != (-1)); }
inline bool _Fputc(wchar_t _C, _iobuf *_Fi)
	{return (fputwc(_C, _Fi) != (wint_t)(0xFFFF)); }
		
template<class _E> inline
	bool _Ungetc(const _E& _C, _iobuf *_Fi, size_t _N)
	{const unsigned char *_P = (const unsigned char *)&_C;
	for (_P += _N; 0 < _N && ungetc(*--_P, _Fi) != (-1); --_N)
		;
	if (_N == 0)
		return (true);
	else
		{for (; _N < sizeof (_E); ++_N)
			fgetc(_Fi);
		return (false); }}
template<class _E> inline
	bool _Ungetc(const _E& _C, _iobuf *_Fi)
	{return (_Ungetc(_C, _Fi, sizeof (_E))); }
inline bool _Ungetc(char _C, _iobuf *_Fi)
	{return (ungetc((unsigned char)_C, _Fi) != (-1)); }
inline bool _Ungetc(wchar_t _C, _iobuf *_Fi)
	{return (ungetwc(_C, _Fi) != (wint_t)(0xFFFF)); }
		
template<class _E, class _Tr = char_traits<_E> >
	class basic_filebuf : public basic_streambuf<_E, _Tr> {
public:
	typedef basic_filebuf<_E, _Tr> _Myt;
	typedef basic_streambuf<_E, _Tr> _Mysb;
	typedef codecvt<_E, char, _Tr::state_type> _Cvt;
	basic_filebuf(_iobuf *_F = 0)
		: _Loc(), _Mysb() {_Init(_F, _Newfl); }
	basic_filebuf(_Uninitialized)
		: _Loc(_Noinit), _Mysb(_Noinit) {}
	virtual ~basic_filebuf()
		{if (_Closef)
			close();
		delete _Str; }
	enum _Initfl {_Newfl, _Openfl, _Closefl};
	bool is_open() const
		{return (_File != 0); }
	_Myt *open(const char *_S, ios_base::openmode _M)
		{_iobuf *_Fp;
		if (_File != 0 || (_Fp = __Fiopen(_S, _M)) == 0)
			return (0);
		_Init(_Fp, _Openfl);
		_Initcvt();
		return (this); }
	_Myt *open(const char *_N, ios::open_mode _M)
		{return (open(_N, (ios::openmode)_M)); }
	_Myt *close()
		{if (_File != 0 && fclose(_File) == 0)
			{_Init(0, _Closefl);
			return (this); }
		else
			return (0); }
protected:
	virtual int_type overflow(int_type _C = _Tr::eof())
		{if (_Tr::eq_int_type(_Tr::eof(), _C))
			return (_Tr::not_eof(_C));
		else if (pptr() != 0 && pptr() < epptr())
			{*_Pninc() = _Tr::to_char_type(_C);
			return (_C); }
		else if (_File == 0)
			return (_Tr::eof());
		else if (_Pcvt == 0)
			return (_Fputc(_Tr::to_char_type(_C), _File)
				? _C : _Tr::eof());
		else
			{const int _NC = 8;
			const _E _X = _Tr::to_char_type(_C);
			const _E *_S;
			char *_D;
			_Str->erase();
			for (size_t _I = _NC; ; _I += _NC)
				{_Str->append(_NC, '\0');
				switch (_Pcvt->out(_State,
					&_X, &_X + 1, _S,
					_Str->begin(), _Str->end(), _D))
				{case codecvt_base::partial:
					if (_S == &_X)
						return (_Tr::eof());
				case codecvt_base::ok:	
					{size_t _N = _D - _Str->begin();
					return (fwrite(_Str->begin(), _N, 1, _File)
						== _N ? _C : _Tr::eof()); } 
				case codecvt_base::noconv:
					return (_Fputc(_X, _File) ? _C : _Tr::eof());
				default:
					return (_Tr::eof()); }}}}
	virtual int_type pbackfail(int_type _C = _Tr::eof())
		{if (gptr() != 0 && eback() < gptr()
			&& (_Tr::eq_int_type(_Tr::eof(), _C)
			 || _Tr::eq_int_type(_Tr::to_int_type(gptr()[-1]),
				_C)))
			{_Gndec();
			return (_Tr::not_eof(_C)); }
		else if (_File == 0 || _Tr::eq_int_type(_Tr::eof(), _C))
			return (_Tr::eof());
		else if (_Pcvt == 0)
			return (_Ungetc(_Tr::to_char_type(_C), _File)
				? _C : _Tr::eof());
		else if (0 < _Str->size()
			&& _Ungetc(*_Str->begin(), _File, _Str->size()))
			{_Str->erase();
			_State = _State0;
			return (_C); }
		else
			return (_Tr::eof()); }
	virtual int_type underflow()
		{if (gptr() != 0 && gptr() < egptr())
			return (_Tr::to_int_type(*gptr()));
		else
			return (pbackfail(uflow())); }
	virtual int_type uflow()
		{if (gptr() != 0 && gptr() < egptr())
			return (_Tr::to_int_type(*_Gninc()));
		else if (_File == 0)
			return (_Tr::eof());
		else if (_Pcvt == 0)
			{_E _C;
			return (_Fgetc(_C, _File) ? _Tr::to_int_type(_C)
				: _Tr::eof()); }
		else
			for (_State0 = _State, _Str->erase(); ; )
				{_E _X, *_D;
				const char *_S;
				int _C = fgetc(_File);
				if (_C == (-1))
					return (_Tr::eof());	
				_Str->append(1, (char)_C);
				_State = _State0;
				switch (_Pcvt->in(_State,
					_Str->begin(), _Str->end(), _S,
					&_X, &_X + 1, _D))
				{case codecvt_base::partial:
					break;
				case codecvt_base::noconv:
					if (_Str->size() < sizeof (_E))
						break;
					memcpy(&_X, _Str->begin(), sizeof (_E));
				case codecvt_base::ok:	
					return (_Tr::to_int_type(_X)); 
				default:
					return (_Tr::eof()); }}}
	virtual pos_type seekoff(off_type _O, ios_base::seekdir _Way,
		ios_base::openmode =
			(ios_base::openmode)(ios_base::in | ios_base::out))
		{fpos_t _Fp;
		if (_File == 0 || fseek(_File, _O, _Way) != 0
			|| fgetpos(_File, &_Fp) != 0)
			return (pos_type(_BADOFF));
		return (pos_type(_State, _Fp)); } 
	virtual pos_type seekpos(pos_type _P,
		ios_base::openmode =
			(ios_base::openmode)(ios_base::in | ios_base::out))
		{fpos_t _Fp = _P.get_fpos_t();
		off_type _Off = (off_type)_P - ((long)(_Fp));
		if (_File == 0
			|| fsetpos(_File, &_Fp) != 0
			|| _Off != 0 && fseek(_File, _Off, 1) != 0
			|| fgetpos(_File, &_Fp) != 0)
			return (pos_type(_BADOFF));
		if (_Str != 0)
			_State = _P.state(), _Str->erase();
		return (pos_type(_State, _Fp)); }
	virtual _Mysb *setbuf(_E *_S, streamsize _N)
		{return (_File == 0 || setvbuf(_File, (char *)_S,
			0x0000, _N * sizeof (_E)) != 0 ? 0 : this); }
	virtual int sync()
		{return (_File == 0 || 0 <= fflush(_File) ? 0 : -1); }
	void _Init(_iobuf *_Fp, _Initfl _Which)
		{static _Tr::state_type _Stinit;
		_Closef = _Which == _Openfl;
		if (_Which == _Newfl)
			{_Loc.locale::~locale();
			new (&_Loc) locale;
			_Str = 0; }
		_Mysb::_Init();
		if (_Fp != 0 && !_Closef && sizeof (_E) == 1)
			{_Mysb::_Init((_E **)&_Fp->_base,
				(_E **)&_Fp->_ptr, &_Fp->_cnt,
				(_E **)&_Fp->_base, (_E **)&_Fp->_ptr,
				&_Fp->_cnt); }
		_File = _Fp;
		_State = _Stinit;
		_State0 = _Stinit;
		_Pcvt = 0; }
	void _Initcvt()
		{_Pcvt = (_Cvt *)&use_facet(getloc(), (_Cvt *)0, true);
		_Loc = _Addfac(_Loc, _Pcvt);
		if (_Pcvt->always_noconv())
			_Pcvt = 0;
		if (_Str == 0)
			_Str = new string; }
private:
	_Cvt *_Pcvt;
	_Tr::state_type _State0;
	_Tr::state_type _State;
	string *_Str;
	bool _Closef;
	locale _Loc;
	_iobuf *_File;
	};


#pragma warning(disable:4231) 
extern template class __declspec(dllimport) basic_filebuf<char, char_traits<char> >;
extern template class __declspec(dllimport) basic_filebuf<wchar_t, char_traits<wchar_t> >;
#pragma warning(default:4231) 
#line 252 "c:\\programme\\microsoft visual studio\\vc98\\include\\fstream"

		
template<class _E, class _Tr = char_traits<_E> >
	class basic_ifstream : public basic_istream<_E, _Tr> {
public:
	typedef basic_ifstream<_E, _Tr> _Myt;
	typedef basic_filebuf<_E, _Tr> _Myfb;
	basic_ifstream()
		: basic_istream<_E, _Tr>(&_Fb) {}
	explicit basic_ifstream(const char *_S,
		ios_base::openmode _M = in)
		: basic_istream<_E, _Tr>(&_Fb)
		{if (_Fb.open(_S, _M | in) == 0)
			setstate(failbit); }
	virtual ~basic_ifstream()
		{}
	_Myfb *rdbuf() const
		{return ((_Myfb *)&_Fb); }
	bool is_open() const
		{return (_Fb.is_open()); }
	void open(const char *_S, ios_base::openmode _M = in)
		{if (_Fb.open(_S, _M | in) == 0)
		 	setstate(failbit); }
	void open(const char *_S, ios_base::open_mode _M)
		{open(_S, (openmode)_M); }
	void close()
		{if (_Fb.close() == 0)
		 	setstate(failbit); }
private:
	_Myfb _Fb;
	};


#pragma warning(disable:4231) 
extern template class __declspec(dllimport) basic_ifstream<char, char_traits<char> >;
extern template class __declspec(dllimport) basic_ifstream<wchar_t, char_traits<wchar_t> >;
#pragma warning(default:4231) 
#line 290 "c:\\programme\\microsoft visual studio\\vc98\\include\\fstream"

		
template<class _E, class _Tr = char_traits<_E> >
	class basic_ofstream : public basic_ostream<_E, _Tr> {
public:
	typedef basic_ofstream<_E, _Tr> _Myt;
	typedef basic_filebuf<_E, _Tr> _Myfb;
	basic_ofstream()
		: basic_ostream<_E, _Tr>(&_Fb) {}
	explicit basic_ofstream(const char *_S,
		ios_base::openmode _M = out | trunc)
		: basic_ostream<_E, _Tr>(&_Fb)
		{if (_Fb.open(_S, _M | out) == 0)
			setstate(failbit); }
	virtual ~basic_ofstream()
		{}
	_Myfb *rdbuf() const
		{return ((_Myfb *)&_Fb); }
	bool is_open() const
		{return (_Fb.is_open()); }
	void open(const char *_S, ios_base::openmode _M = out | trunc)
		{if (_Fb.open(_S, _M | out) == 0)
		 	setstate(failbit); }
	void open(const char *_S, ios_base::open_mode _M)
		{open(_S, (openmode)_M); }
	void close()
		{if (_Fb.close() == 0)
		 	setstate(failbit); }
private:
	_Myfb _Fb;
	};


#pragma warning(disable:4231) 
extern template class __declspec(dllimport) basic_ofstream<char, char_traits<char> >;
extern template class __declspec(dllimport) basic_ofstream<wchar_t, char_traits<wchar_t> >;
#pragma warning(default:4231) 
#line 328 "c:\\programme\\microsoft visual studio\\vc98\\include\\fstream"


		
template<class _E, class _Tr = char_traits<_E> >
	class basic_fstream : public basic_iostream<_E, _Tr> {
public:
	basic_fstream()
		: basic_iostream<_E, _Tr>(&_Fb) {}
	explicit basic_fstream(const char *_S,
		ios_base::openmode _M = in | out)
		: basic_iostream<_E, _Tr>(&_Fb)
		{if (_Fb.open(_S, _M) == 0)
			setstate(failbit); }
	virtual ~basic_fstream()
		{}
	basic_filebuf<_E, _Tr> *rdbuf() const
		{return ((basic_filebuf<_E, _Tr> *)&_Fb); }
	bool is_open() const
		{return (_Fb.is_open()); }
	void open(const char *_S, ios_base::openmode _M = in | out)
		{if (_Fb.open(_S, _M) == 0)
		 	setstate(failbit); }
	void open(const char *_S, ios_base::open_mode _M)
		{open(_S, (openmode)_M); }
	void close()
		{if (_Fb.close() == 0)
		 	setstate(failbit); }
private:
	basic_filebuf<_E, _Tr> _Fb;
	};


#pragma warning(disable:4231) 
extern template class __declspec(dllimport) basic_fstream<char, char_traits<char> >;
extern template class __declspec(dllimport) basic_fstream<wchar_t, char_traits<wchar_t> >;
#pragma warning(default:4231) 
#line 365 "c:\\programme\\microsoft visual studio\\vc98\\include\\fstream"




};

#pragma pack(pop)
#line 373 "c:\\programme\\microsoft visual studio\\vc98\\include\\fstream"

#line 375 "c:\\programme\\microsoft visual studio\\vc98\\include\\fstream"





#line 47 "h:\\c_projekte\\elansim\\headview.cpp"
#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\iomanip"



#pragma once
#line 6 "c:\\programme\\microsoft visual studio\\vc98\\include\\iomanip"







#pragma pack(push,8)
#line 15 "c:\\programme\\microsoft visual studio\\vc98\\include\\iomanip"
namespace std {
		
template<class _E>
	struct _Fillobj {
	_Fillobj(_E _Charg)
		: _Ch(_Charg) {}
	_E _Ch;
	};
template<class _E> inline
	_Fillobj<_E> __cdecl setfill(_E _C)
	{return (_Fillobj<_E>(_C)); }
template<class _E, class _Tr> inline
	basic_istream<_E, _Tr>& __cdecl operator>>(
		basic_istream<_E, _Tr>& _I, const _Fillobj<_E>& _X)
		{_I.fill(_X._Ch);
		return (_I); }
template<class _E, class _Tr> inline
	basic_ostream<_E, _Tr>& __cdecl operator<<(
		basic_ostream<_E, _Tr>& _O, const _Fillobj<_E>& _X)
		{_O.fill(_X._Ch);
		return (_O); }
		
template<class _Tm>
	struct _Smanip {
	_Smanip(void (__cdecl *_F)(ios_base&, _Tm), _Tm _A)
		: _Pf(_F), _Manarg(_A) {}
	void (__cdecl *_Pf)(ios_base&, _Tm);
	_Tm _Manarg;
	};
template<class _E, class _Tr, class _Tm> inline
	basic_istream<_E, _Tr>& __cdecl operator>>(
		basic_istream<_E, _Tr>& _I, const _Smanip<_Tm>& _M)
	{(*_M._Pf)(_I, _M._Manarg);
	return (_I); }
template<class _E, class _Tr, class _Tm> inline
	basic_ostream<_E, _Tr>& __cdecl operator<<(
		basic_ostream<_E, _Tr>& _O, const _Smanip<_Tm>& _M)
	{(*_M._Pf)(_O, _M._Manarg);
	return (_O); }
		
__declspec(dllimport) _Smanip<ios_base::fmtflags>
	__cdecl resetiosflags(ios_base::fmtflags);
__declspec(dllimport) _Smanip<ios_base::fmtflags>
	__cdecl setiosflags(ios_base::fmtflags);
__declspec(dllimport) _Smanip<int> __cdecl setbase(int);
__declspec(dllimport) _Smanip<streamsize> __cdecl setprecision(streamsize);
__declspec(dllimport) _Smanip<streamsize> __cdecl setw(streamsize);
};

#pragma pack(pop)
#line 66 "c:\\programme\\microsoft visual studio\\vc98\\include\\iomanip"

#line 68 "c:\\programme\\microsoft visual studio\\vc98\\include\\iomanip"





#line 48 "h:\\c_projekte\\elansim\\headview.cpp"

#line 1 "h:\\c_projekte\\elansim\\scene.h"








#pragma once
#line 11 "h:\\c_projekte\\elansim\\scene.h"

#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\vector"



#pragma once
#line 6 "c:\\programme\\microsoft visual studio\\vc98\\include\\vector"




#line 1 "c:\\programme\\microsoft visual studio\\vc98\\include\\memory"



#pragma once
#line 6 "c:\\programme\\microsoft visual studio\\vc98\\include\\memory"






#pragma pack(push,8)
#line 14 "c:\\programme\\microsoft visual studio\\vc98\\include\\memory"
		
template<class _Ty>
	inline void *operator new(size_t _N, std::allocator<_Ty>& _Al)
	{return (_Al._Charalloc(_N)); }
namespace std {
		
template<class _Ty> inline
	pair<_Ty  *, ptrdiff_t>
		get_temporary_buffer(ptrdiff_t _N, _Ty  *)
	{_Ty  *_P;
	for (_P = 0; 0 < _N; _N /= 2)
		if ((_P = (_Ty  *)operator new(
			(size_t)_N * sizeof (_Ty), nothrow)) != 0)
			break;
	return (pair<_Ty  *, ptrdiff_t>(_P, _N)); }
		
template<class _Ty> inline
	void return_temporary_buffer(_Ty *_P)
	{operator delete(_P); }
		
template<class _II, class _FI> inline
	_FI uninitialized_copy(_II _F, _II _L, _FI _X)
	{for (; _F != _L; ++_X, ++_F)
		_Construct(&*_X, *_F);
	return (_X); }
		
template<class _FI, class _Ty> inline
	void uninitialized_fill(_FI _F, _FI _L, const _Ty& _X)
	{for (; _F != _L; ++_F)
		_Construct(&*_F, _X); }
		
template<class _FI, class _S, class _Ty> inline
	void uninitialized_fill_n(_FI _F, _S _N, const _Ty& _X)
	{for (; 0 < _N; --_N, ++_F)
		_Construct(&*_F, _X); }
		
template<class _OI, class _Ty>
	class raw_storage_iterator
		: public iterator<output_iterator_tag, void, void> {
public:
	typedef _OI iterator_type;
	typedef _Ty element_type;
	explicit raw_storage_iterator(_OI _X)
		: _Next(_X) {}
	raw_storage_iterator<_OI, _Ty>& operator*()
		{return (*this); }
	raw_storage_iterator<_OI, _Ty>& operator=(const _Ty& _X)
		{_Construct(&*_Next, _X);
		return (*this); }
	raw_storage_iterator<_OI, _Ty>& operator++()
		{++_Next;
		return (*this); }
	raw_storage_iterator<_OI, _Ty> operator++(int)
		{raw_storage_iterator<_OI, _Ty> _Ans = *this;
		++_Next;
		return (_Ans); }
private:
	_OI _Next;
	};
		
template<class _Ty>
	class _Temp_iterator
		: public iterator<output_iterator_tag, void, void> {
public:
	typedef _Ty  *_Pty;
	_Temp_iterator(ptrdiff_t _N = 0)
		{pair<_Pty, ptrdiff_t> _Pair =
			get_temporary_buffer(_N, (_Pty)0);
		_Buf._Begin = _Pair.first;
		_Buf._Cur = _Pair.first;
		_Buf._Hiwater = _Pair.first;
		_Buf._Len = _Pair.second;
		_Pb = &_Buf; }
	_Temp_iterator(const _Temp_iterator<_Ty>& _X)
		{_Buf._Begin = 0;
		_Buf._Cur = 0;
		_Buf._Hiwater = 0;
		_Buf._Len = 0;
		*this = _X; }
	~_Temp_iterator()
		{if (_Buf._Begin != 0)
			{for (_Pty _F = _Buf._Begin;
				_F != _Buf._Hiwater; ++_F)
				_Destroy(&*_F);
			return_temporary_buffer(_Buf._Begin); }}
	_Temp_iterator<_Ty>& operator=(const _Temp_iterator<_Ty>& _X)
		{_Pb = _X._Pb;
		return (*this); }
	_Temp_iterator<_Ty>& operator=(const _Ty& _V)
		{if (_Pb->_Cur < _Pb->_Hiwater)
			*_Pb->_Cur++ = _V;
		else
			{_Construct(&*_Pb->_Cur, _V);
			_Pb->_Hiwater = ++_Pb->_Cur; }
		return (*this); }
	_Temp_iterator<_Ty>& operator*()
		{return (*this); }
	_Temp_iterator<_Ty>& operator++()
		{return (*this); }
	_Temp_iterator<_Ty>& operator++(int)
		{return (*this); }
	_Temp_iterator<_Ty>& _Init()
		{_Pb->_Cur = _Pb->_Begin;
		return (*this); }
	_Pty _First() const
		{return (_Pb->_Begin); }
	_Pty _Last() const
		{return (_Pb->_Cur); }
	ptrdiff_t _Maxlen() const
		{return (_Pb->_Len); }
private:
	struct _Bufpar {
		_Pty _Begin;
		_Pty _Cur;
		_Pty _Hiwater;
		ptrdiff_t _Len;
		} _Buf, *_Pb;
	};
		
template<class _Ty>
	class auto_ptr {
public:
	typedef _Ty element_type;
	explicit auto_ptr(_Ty *_P = 0) throw ()
		: _Owns(_P != 0), _Ptr(_P) {}
	auto_ptr(const auto_ptr<_Ty>& _Y) throw ()
		: _Owns(_Y._Owns), _Ptr(_Y.release()) {}
	auto_ptr<_Ty>& operator=(const auto_ptr<_Ty>& _Y) throw ()
		{if (this != &_Y)
			{if (_Ptr != _Y.get())
				{if (_Owns)
					delete _Ptr;
				_Owns = _Y._Owns; }
			else if (_Y._Owns)
				_Owns = true;
			_Ptr = _Y.release(); }
		return (*this); }
	~auto_ptr()
		{if (_Owns)
			delete _Ptr; }
	_Ty& operator*() const throw ()
		{return (*get()); }
	_Ty *operator->() const throw ()
		{return (get()); }
	_Ty *get() const throw ()
		{return (_Ptr); }
	_Ty *release() const throw ()
		{((auto_ptr<_Ty> *)this)->_Owns = false;
		return (_Ptr); }
private:
	bool _Owns;
	_Ty *_Ptr;
	};
};

#pragma pack(pop)
#line 171 "c:\\programme\\microsoft visual studio\\vc98\\include\\memory"

#line 173 "c:\\programme\\microsoft visual studio\\vc98\\include\\memory"






















#line 11 "c:\\programme\\microsoft visual studio\\vc98\\include\\vector"




#pragma pack(push,8)
#line 17 "c:\\programme\\microsoft visual studio\\vc98\\include\\vector"
namespace std {
		
template<class _Ty, class _A = allocator<_Ty> >
	class vector {
public:
	typedef vector<_Ty, _A> _Myt;
	typedef _A allocator_type;
	typedef _A::size_type size_type;
	typedef _A::difference_type difference_type;
	typedef _A::pointer _Tptr;
	typedef _A::const_pointer _Ctptr;
	typedef _A::reference reference;
	typedef _A::const_reference const_reference;
	typedef _A::value_type value_type;
	typedef _Tptr iterator;
	typedef _Ctptr const_iterator;
	typedef reverse_iterator<const_iterator, value_type,
		const_reference, _Ctptr, difference_type>
			const_reverse_iterator;
	typedef reverse_iterator<iterator, value_type,
		reference, _Tptr, difference_type>
			reverse_iterator;
	explicit vector(const _A& _Al = _A())
		: allocator(_Al), _First(0), _Last(0), _End(0) {}
	explicit vector(size_type _N, const _Ty& _V = _Ty(),
		const _A& _Al = _A())
		: allocator(_Al)
		{_First = allocator.allocate(_N, (void *)0);
		_Ufill(_First, _N, _V);
		_Last = _First + _N;
		_End = _Last; }
	vector(const _Myt& _X)
		: allocator(_X.allocator)
		{_First = allocator.allocate(_X.size(), (void *)0);
		_Last = _Ucopy(_X.begin(), _X.end(), _First);
		_End = _Last; }
	typedef const_iterator _It;
	vector(_It _F, _It _L, const _A& _Al = _A())
		: allocator(_Al), _First(0), _Last(0), _End(0)
		{insert(begin(), _F, _L); }
	~vector()
		{_Destroy(_First, _Last);
		allocator.deallocate(_First, _End - _First);
		_First = 0, _Last = 0, _End = 0; }
	_Myt& operator=(const _Myt& _X)
		{if (this == &_X)
			;
		else if (_X.size() <= size())
			{iterator _S = copy(_X.begin(), _X.end(), _First);
			_Destroy(_S, _Last);
			_Last = _First + _X.size(); }
		else if (_X.size() <= capacity())
			{const_iterator _S = _X.begin() + size();
			copy(_X.begin(), _S, _First);
			_Ucopy(_S, _X.end(), _Last);
			_Last = _First + _X.size(); }
		else
			{_Destroy(_First, _Last);
			allocator.deallocate(_First, _End - _First);
			_First = allocator.allocate(_X.size(), (void *)0);
			_Last = _Ucopy(_X.begin(), _X.end(),
				_First);
			_End = _Last; }
		return (*this); }
	void reserve(size_type _N)
		{if (capacity() < _N)
			{iterator _S = allocator.allocate(_N, (void *)0);
			_Ucopy(_First, _Last, _S);
			_Destroy(_First, _Last);
			allocator.deallocate(_First, _End - _First);
			_End = _S + _N;
			_Last = _S + size();
			_First = _S; }}
	size_type capacity() const
		{return (_First == 0 ? 0 : _End - _First); }
	iterator begin()
		{return (_First); }
	const_iterator begin() const
		{return ((const_iterator)_First); }
	iterator end()
		{return (_Last); }
	const_iterator end() const
		{return ((const_iterator)_Last); }
	reverse_iterator rbegin()
		{return (reverse_iterator(end())); }
	const_reverse_iterator rbegin() const
		{return (const_reverse_iterator(end())); }
	reverse_iterator rend()
		{return (reverse_iterator(begin())); }
	const_reverse_iterator rend() const
		{return (const_reverse_iterator(begin())); }
	void resize(size_type _N, const _Ty& _X = _Ty())
		{if (size() < _N)
			insert(end(), _N - size(), _X);
		else if (_N < size())
			erase(begin() + _N, end()); }
	size_type size() const
		{return (_First == 0 ? 0 : _Last - _First); }
	size_type max_size() const
		{return (allocator.max_size()); }
	bool empty() const
		{return (size() == 0); }
	_A get_allocator() const
		{return (allocator); }
	const_reference at(size_type _P) const
		{if (size() <= _P)
			_Xran();
		return (*(begin() + _P)); }
	reference at(size_type _P)
		{if (size() <= _P)
			_Xran();
		return (*(begin() + _P)); }
	const_reference operator[](size_type _P) const
		{return (*(begin() + _P)); }
	reference operator[](size_type _P)
		{return (*(begin() + _P)); }
	reference front()
		{return (*begin()); }
	const_reference front() const
		{return (*begin()); }
	reference back()
		{return (*(end() - 1)); }
	const_reference back() const
		{return (*(end() - 1)); }
	void push_back(const _Ty& _X)
		{insert(end(), _X); }
	void pop_back()
		{erase(end() - 1); }
	void assign(_It _F, _It _L)
		{erase(begin(), end());
		insert(begin(), _F, _L); }
	void assign(size_type _N, const _Ty& _X = _Ty())
		{erase(begin(), end());
		insert(begin(), _N, _X); }
	iterator insert(iterator _P, const _Ty& _X = _Ty())
		{size_type _O = _P - begin();
		insert(_P, 1, _X);
		return (begin() + _O); }
	void insert(iterator _P, size_type _M, const _Ty& _X)
		{if (_End - _Last < _M)
			{size_type _N = size() + (_M < size() ? size() : _M);
			iterator _S = allocator.allocate(_N, (void *)0);
			iterator _Q = _Ucopy(_First, _P, _S);
			_Ufill(_Q, _M, _X);
			_Ucopy(_P, _Last, _Q + _M);
			_Destroy(_First, _Last);
			allocator.deallocate(_First, _End - _First);
			_End = _S + _N;
			_Last = _S + size() + _M;
			_First = _S; }
		else if (_Last - _P < _M)
			{_Ucopy(_P, _Last, _P + _M);
			_Ufill(_Last, _M - (_Last - _P), _X);
			fill(_P, _Last, _X);
			_Last += _M; }
		else if (0 < _M)
			{_Ucopy(_Last - _M, _Last, _Last);
			copy_backward(_P, _Last - _M, _Last);
			fill(_P, _P + _M, _X);
			_Last += _M; }}
	void insert(iterator _P, _It _F, _It _L)
		{size_type _M = 0;
		_Distance(_F, _L, _M);
		if (_End - _Last < _M)
			{size_type _N = size() + (_M < size() ? size() : _M);
			iterator _S = allocator.allocate(_N, (void *)0);
			iterator _Q = _Ucopy(_First, _P, _S);
			_Q = _Ucopy(_F, _L, _Q);
			_Ucopy(_P, _Last, _Q);
			_Destroy(_First, _Last);
			allocator.deallocate(_First, _End - _First);
			_End = _S + _N;
			_Last = _S + size() + _M;
			_First = _S; }
		else if (_Last - _P < _M)
			{_Ucopy(_P, _Last, _P + _M);
			_Ucopy(_F + (_Last - _P), _L, _Last);
			copy(_F, _F + (_Last - _P), _P);
			_Last += _M; }
		else if (0 < _M)
			{_Ucopy(_Last - _M, _Last, _Last);
			copy_backward(_P, _Last - _M, _Last);
			copy(_F, _L, _P);
			_Last += _M; }}
	iterator erase(iterator _P)
		{copy(_P + 1, end(), _P);
		_Destroy(_Last - 1, _Last);
		--_Last;
		return (_P); }
	iterator erase(iterator _F, iterator _L)
		{iterator _S = copy(_L, end(), _F);
		_Destroy(_S, end());
		_Last = _S;
		return (_F); }
	void clear()
		{erase(begin(), end()); }
	bool _Eq(const _Myt& _X) const
		{return (size() == _X.size()
			&& equal(begin(), end(), _X.begin())); }
	bool _Lt(const _Myt& _X) const
		{return (lexicographical_compare(begin(), end(),
			_X.begin(), _X.end())); }
	void swap(_Myt& _X)
		{if (allocator == _X.allocator)
			{std::swap(_First, _X._First);
			std::swap(_Last, _X._Last);
			std::swap(_End, _X._End); }
		else
			{_Myt _Ts = *this; *this = _X, _X = _Ts; }}
	friend void swap(_Myt& _X, _Myt& _Y)
		{_X.swap(_Y); }
protected:
	void _Destroy(iterator _F, iterator _L)
		{for (; _F != _L; ++_F)
			allocator.destroy(_F); }
	iterator _Ucopy(const_iterator _F, const_iterator _L,
		iterator _P)
		{for (; _F != _L; ++_P, ++_F)
			allocator.construct(_P, *_F);
		return (_P); }
	void _Ufill(iterator _F, size_type _N, const _Ty &_X)
		{for (; 0 < _N; --_N, ++_F)
			allocator.construct(_F, _X); }
	void _Xran() const
		{throw out_of_range("invalid vector<T> subscript"); }
	_A allocator;
	iterator _First, _Last, _End;
	};
		
typedef unsigned int _Vbase;
const int _VBITS = 8 * sizeof (_Vbase);
typedef allocator<_Vbase> _Bool_allocator;
class vector<_Bool, _Bool_allocator> {
public:
	typedef _Bool_allocator _A;
	typedef _Bool _Ty;
	typedef vector<_Ty, _A> _Myt;
	typedef vector<_Vbase, _A> _Vbtype;
	typedef _A allocator_type;
	typedef _A::size_type size_type;
	typedef _A::difference_type difference_type;

		
	class reference {
	public:
		reference()
			: _Mask(0), _Ptr(0) {}
		reference(size_t _O, _Vbase *_P)
			: _Mask((_Vbase)1 << _O), _Ptr(_P) {}
		reference& operator=(const reference& _X)
			{return (*this = bool(_X)); }
		reference& operator=(bool _V)
			{if (_V)
				*_Ptr |= _Mask;
			else
				*_Ptr &= ~_Mask;
			return (*this); }
		void flip()
			{*_Ptr ^= _Mask; }
		bool operator~() const
			{return (!bool(*this)); }
		operator bool() const
			{return ((*_Ptr & _Mask) != 0); }
	protected:
		_Vbase _Mask, *_Ptr;
		};

	typedef const reference const_reference;
	typedef bool value_type;
		
	class iterator;
	class const_iterator : public _Ranit<_Bool, difference_type> {
	public:
		const_iterator()
			: _Off(0), _Ptr(0) {}
		const_iterator(size_t _O, const _Vbase *_P)
			: _Off(_O), _Ptr((_Vbase*)_P) {}
		const_iterator(const iterator& _X)
			: _Off(_X._Off), _Ptr(_X._Ptr) {}
		const_reference operator*() const
			{return (const_reference(_Off, _Ptr)); }
		const_iterator& operator++()
			{_Inc();
			return (*this); }
		const_iterator operator++(int)
			{const_iterator _Tmp = *this;
			_Inc();
			return (_Tmp); }
		const_iterator& operator--()
			{_Dec();
			return (*this); }
		const_iterator operator--(int)
			{const_iterator _Tmp = *this;
			_Dec();
			return (_Tmp); }
		const_iterator& operator+=(difference_type _N)
			{_Off += _N;
			_Ptr += _Off / _VBITS;
			_Off %= _VBITS;
			return (*this); }
		const_iterator& operator-=(difference_type _N)
			{return (*this += -_N); }
		const_iterator operator+(difference_type _N) const
			{const_iterator _Tmp = *this;
			return (_Tmp += _N); }
		const_iterator operator-(difference_type _N) const
			{const_iterator _Tmp = *this;
			return (_Tmp -= _N); }
		difference_type operator-(const const_iterator _X) const
			{return (_VBITS * (_Ptr - _X._Ptr)
				+ (difference_type)_Off
				- (difference_type)_X._Off); }
		const_reference operator[](difference_type _N) const
			{return (*(*this + _N)); }
		bool operator==(const const_iterator& _X) const
			{return (_Ptr == _X._Ptr && _Off == _X._Off); }
		bool operator!=(const const_iterator& _X) const
			{return (!(*this == _X)); }
		bool operator<(const const_iterator& _X) const
			{return (_Ptr < _X._Ptr
				|| _Ptr == _X._Ptr && _Off < _X._Off); }
		bool operator>(const const_iterator& _X) const
			{return (_X < *this); }
		bool operator<=(const const_iterator& _X) const
			{return (!(_X < *this)); }
		bool operator>=(const const_iterator& _X) const
			{return (!(*this < _X)); }
	protected:
		void _Dec()
			{if (_Off != 0)
				--_Off;
			else
				_Off = _VBITS - 1, --_Ptr; }
		void _Inc()
			{if (_Off < _VBITS - 1)
				++_Off;
			else
				_Off = 0, ++_Ptr; }
		size_t _Off;
		_Vbase *_Ptr;
		};
		
	class iterator : public const_iterator {
	public:
		iterator()
			: const_iterator() {}
		iterator(size_t _O, _Vbase *_P)
			: const_iterator(_O, _P) {}
		reference operator*() const
			{return (reference(_Off, _Ptr)); }
		iterator& operator++()
			{_Inc();
			return (*this); }
		iterator operator++(int)
			{iterator _Tmp = *this;
			_Inc();
			return (_Tmp); }
		iterator& operator--()
			{_Dec();
			return (*this); }
		iterator operator--(int)
			{iterator _Tmp = *this;
			_Dec();
			return (_Tmp); }
		iterator& operator+=(difference_type _N)
			{_Off += _N;
			_Ptr += _Off / _VBITS;
			_Off %= _VBITS;
			return (*this); }
		iterator& operator-=(difference_type _N)
			{return (*this += -_N); }
		iterator operator+(difference_type _N) const
			{iterator _Tmp = *this;
			return (_Tmp += _N); }
		iterator operator-(difference_type _N) const
			{iterator _Tmp = *this;
			return (_Tmp -= _N); }
		difference_type operator-(const iterator _X) const
			{return (_VBITS * (_Ptr - _X._Ptr)
				+ (difference_type)_Off
				- (difference_type)_X._Off); }
		reference operator[](difference_type _N) const
			{return (*(*this + _N)); }
		bool operator==(const iterator& _X) const
			{return (_Ptr == _X._Ptr && _Off == _X._Off); }
		bool operator!=(const iterator& _X) const
			{return (!(*this == _X)); }
		bool operator<(const iterator& _X) const
			{return (_Ptr < _X._Ptr
				|| _Ptr == _X._Ptr && _Off < _X._Off); }
		bool operator>(const iterator& _X) const
			{return (_X < *this); }
		bool operator<=(const iterator& _X) const
			{return (!(_X < *this)); }
		bool operator>=(const iterator& _X) const
			{return (!(*this < _X)); }
		};
	typedef reverse_iterator<const_iterator, value_type,
		const_reference, const_reference *, difference_type>
			const_reverse_iterator;
	typedef reverse_iterator<iterator, value_type,
		reference, reference *, difference_type>
			reverse_iterator;
	explicit vector(const _A& _Al = _A())
		: _Size(0), _Vec(_Al) {}
	explicit vector(size_type _N, const bool _V = false,
		const _A& _Al = _A())
		: _Vec(_Nw(_N), _V ? -1 : 0, _Al) {_Trim(_N); }
	typedef const_iterator _It;
	vector(_It _F, _It _L, const _A& _Al = _A())
		: _Size(0), _Vec(_Al)
		{insert(begin(), _F, _L); }
	~vector()
		{_Size = 0; }
	void reserve(size_type _N)
		{_Vec.reserve(_Nw(_N)); }
	size_type capacity() const
		{return (_Vec.capacity() * _VBITS); }
	iterator begin()
		{return (iterator(0, _Vec.begin())); }
	const_iterator begin() const
		{return (const_iterator(0, _Vec.begin())); }
	iterator end()
		{iterator _Tmp = begin();
		if (0 < _Size)
			_Tmp += _Size;
		return (_Tmp); }
	const_iterator end() const
		{const_iterator _Tmp = begin();
		if (0 < _Size)
			_Tmp += _Size;
		return (_Tmp); }
	reverse_iterator rbegin()
		{return (reverse_iterator(end())); }
	const_reverse_iterator rbegin() const
		{return (const_reverse_iterator(end())); }
	reverse_iterator rend()
		{return (reverse_iterator(begin())); }
	const_reverse_iterator rend() const
		{return (const_reverse_iterator(begin())); }
	void resize(size_type _N, bool _X = false)
		{if (size() < _N)
			insert(end(), _N - size(), _X);
		else if (_N < size())
			erase(begin() + _N, end()); }
	size_type size() const
		{return (_Size); }
	size_type max_size() const
		{return (_Vec.max_size() * _VBITS); }
	bool empty() const
		{return (size() == 0); }
	_A get_allocator() const
		{return (_Vec.get_allocator()); }
	const_reference at(size_type _P) const
		{if (size() <= _P)
			_Xran();
		return (*(begin() + _P)); }
	reference at(size_type _P)
		{if (size() <= _P)
			_Xran();
		return (*(begin() + _P)); }
	const_reference operator[](size_type _P) const
		{return (*(begin() + _P)); }
	reference operator[](size_type _P)
		{return (*(begin() + _P)); }
	reference front()
		{return (*begin()); }
	const_reference front() const
		{return (*begin()); }
	reference back()
		{return (*(end() - 1)); }
	const_reference back() const
		{return (*(end() - 1)); }
	void push_back(const bool _X)
		{insert(end(), _X); }
	void pop_back()
		{erase(end() - 1); }
	void assign(_It _F, _It _L)
		{erase(begin(), end());
		insert(begin(), _F, _L); }
	void assign(size_type _N, const bool _X = false)
		{erase(begin(), end());
		insert(begin(), _N, _X); }
	iterator insert(iterator _P, const bool _X = false)
		{size_type _O = _P - begin();
		insert(_P, 1, _X);
		return (begin() + _O); }
	void insert(iterator _P, size_type _M, const bool _X)
		{if (0 < _M)
			{if (capacity() - size() < _M)
				{size_type _O = _P - begin();
				_Vec.resize(_Nw(size() + _M), 0);
				_P = begin() + _O; }
			copy_backward(_P, end(), end() + _M);
			fill(_P, _P + _M, _X);
			_Size += _M; }}
	void insert(iterator _P, _It _F, _It _L)
		{size_type _M = 0;
		_Distance(_F, _L, _M);
		if (0 < _M)
			{if (capacity() - size() < _M)
				{size_type _O = _P - begin();
				_Vec.resize(_Nw(size() + _M), 0);
				_P = begin() + _O; }
			copy_backward(_P, end(), end() + _M);
			copy(_F, _L, _P);
			_Size += _M; }}
	iterator erase(iterator _P)
		{copy(_P + 1, end(), _P);
		_Trim(_Size - 1);
		return (_P); }
	iterator erase(iterator _F, iterator _L)
		{iterator _S = copy(_L, end(), _F);
		_Trim(_S - begin());
		return (_F); }
	void clear()
		{erase(begin(), end()); }
	void flip()
		{for (_Vbtype::iterator _S = _Vec.begin();
			_S != _Vec.end(); ++_S)
			*_S = ~*_S;
		_Trim(_Size); }
	bool _Eq(const _Myt& _X) const
		{return (_Size == _X._Size && _Vec._Eq(_X._Vec)); }
	bool _Lt(const _Myt& _X) const
		{return (_Size < _X._Size
			|| _Size == _X._Size && _Vec._Lt(_X._Vec)); }
	void swap(_Myt& _X)
		{std::swap(_Size, _X._Size);
		_Vec.swap(_X._Vec); }
	friend void swap(_Myt& _X, _Myt& _Y)
		{_X.swap(_Y); }
	static void swap(reference _X, reference _Y)
		{bool _V = _X;
		_X = _Y;
		_Y = _V; }
protected:
	static size_type _Nw(size_type _N)
		{return ((_N + _VBITS - 1) / _VBITS); }
	void _Trim(size_type _N)
		{size_type _M = _Nw(_N);
		if (_M < _Vec.size())
			_Vec.erase(_Vec.begin() + _M, _Vec.end());
		_Size = _N;
		_N %= _VBITS;
		if (0 < _N)
			_Vec[_M - 1] &= ((_Vbase)1 << _N) - 1; }
	void _Xran() const
		{throw out_of_range("invalid vector<bool> subscript"); }
	size_type _Size;
	_Vbtype _Vec;
	};
typedef vector<_Bool, _Bool_allocator> _Bvector;
		
template<class _Ty, class _A> inline
	bool operator==(const vector<_Ty, _A>& _X,
		const vector<_Ty, _A>& _Y)
	{return (_X._Eq(_Y)); }
template<class _Ty, class _A> inline
	bool operator!=(const vector<_Ty, _A>& _X,
		const vector<_Ty, _A>& _Y)
	{return (!(_X == _Y)); }
template<class _Ty, class _A> inline
	bool operator<(const vector<_Ty, _A>& _X,
		const vector<_Ty, _A>& _Y)
	{return (_X._Lt(_Y)); }
template<class _Ty, class _A> inline
	bool operator>(const vector<_Ty, _A>& _X,
		const vector<_Ty, _A>& _Y)
	{return (_Y < _X); }
template<class _Ty, class _A> inline
	bool operator<=(const vector<_Ty, _A>& _X,
		const vector<_Ty, _A>& _Y)
	{return (!(_Y < _X)); }
template<class _Ty, class _A> inline
	bool operator>=(const vector<_Ty, _A>& _X,
		const vector<_Ty, _A>& _Y)
	{return (!(_X < _Y)); }
};

#pragma pack(pop)
#line 599 "c:\\programme\\microsoft visual studio\\vc98\\include\\vector"

#line 601 "c:\\programme\\microsoft visual studio\\vc98\\include\\vector"






















#line 13 "h:\\c_projekte\\elansim\\scene.h"
#line 1 "h:\\c_projekte\\elansim\\source.h"








#pragma once
#line 11 "h:\\c_projekte\\elansim\\source.h"

class Source  
{
public:

	enum ID { Connection, File } _id;

	Source(ID id) : _id(id) {};
	~Source();



	virtual ID operator()() { return _id; }
};

#line 27 "h:\\c_projekte\\elansim\\source.h"
#line 14 "h:\\c_projekte\\elansim\\scene.h"

class SoVRMLGroup;
class SoNode;
class Tree;
class SoPath;
class ServerConnection;
class SoVRMLScript;
class SoVRMLElevationGrid;

class SoPerspectiveCamera;

class Scene  
{
public:
	Scene(SoVRMLGroup* root);
	Scene();
	virtual ~Scene();

	typedef std::vector<Tree*> treeList;
	typedef std::vector<SoVRMLScript*> GGInfo;

	int convert(const char* buffer, size_t size);
	char* toVRML(size_t& size);
	static void* buffer_realloc(void* bufptr, size_t size);
	SoVRMLGroup* getRoot() { return _root; }
	void hideTrees(int withStatus, bool hideOrShow);
	void cutTrees(int withStatus);
	int getGGDialogData(const char**& namelist, int*& minVal, int*& maxVal);
	void showOriginalStand(bool onOff);
	int getWorldInfo(const char**& info);
	Tree* getTree(SoPath* path);
	SoVRMLElevationGrid* getGround();
	

	void event(const char* data);
	void eventReleased(int treeNr, int partId);

	static void _selectionCB(void* data, SoPath* path);
	SoVRMLElevationGrid* _ground;
	treeList _tree;
	
private:


	
	
	static Scene* me;

	GGInfo	_GGInfo;
	SoVRMLGroup* _root;

	
	void _analyseScene();
	void _fixTextures();
	bool _isUsingShaftSystem(SoNode* node);
	bool _isUsingAdjust(SoNode* node);
	void _getDefaultSystem();
	void _adjustPosition(SoNode* node);
	void _writeToBuffer();

	static void* _buffer_realloc(void* bufptr, size_t size);

};

#line 79 "h:\\c_projekte\\elansim\\scene.h"
#line 50 "h:\\c_projekte\\elansim\\headview.cpp"







HeadView::HeadView( QWidget* parent, const char* name, bool modal, WFlags fl )
    : QDialog( parent, name, modal, fl )
{
    if ( !name )
	setName( "HeadView" );
	resize( 247, 226 );
    setCaption( tr( "HeadView" ) );

    Frame5 = new QFrame( this, "Frame5" );
    Frame5->setGeometry( QRect( 5, 0, 236, 201 ) ); 
    Frame5->setFrameShape( QFrame::StyledPanel );
    Frame5->setFrameShadow( QFrame::Sunken );

    slider = new QSlider( this, "slider" );
    slider->setGeometry( QRect( 5, 205, 235, 16 ) ); 
    slider->setOrientation( QSlider::Horizontal );
	slider->setMaxValue(100);
	slider->setMinValue(0);
	slider->setValue(20);


	connect (slider, "2""valueChanged(int)", this, "1""_onSlider(int)" );

	_root = new SoVRMLGroup;

	SoQtRenderArea* renderframe = new SoQtRenderArea(Frame5);
	renderframe->setBackgroundColor(SbColor(0.8f,0.8f,0.8f));
	renderframe->setSceneGraph(_root);

	SbViewportRegion region(renderframe->getSize());
	
	SbRotation rot1(SbVec3f(1.f,0.f,0.f), float(-3.14159265358979323846/2));
	SbRotation rot2(SbVec3f(0.f,1.f,0.f), float(3.14159265358979323846*1.2));


	headCam = new SoPerspectiveCamera;
	SoDirectionalLight* light = new SoDirectionalLight;
	light->direction.setValue(0,-1,0);


	_root->addChild(headCam);
	_root->addChild(light);

	headCam->nearDistance = 0.1f;
	headCam->farDistance = 5000;
	headCam->orientation.setValue(rot1*rot2);
	headCam->position.setValue(0,slider->value() ,0); 

	
}





HeadView::~HeadView()
{
    
}

void HeadView::setScene(Scene* sc)
{
	SoVRMLGroup* root = sc->getRoot();

	root->ref();

	SoSearchAction* s = new SoSearchAction;
	s->setSearchingAll(true);
	s->setInterest(SoSearchAction::ALL);
	s->setName("Tree");
	s->apply(root);

	SoPathList list = s->getPaths();

	for (int i=0; i<list.getLength(); i++) {
		if (list[i]->getTail()->getTypeId() == SoVRMLTransform::getClassTypeId()) {
			SoVRMLTransform* newTrans = new SoVRMLTransform;
			SoVRMLTransform* trans = (SoVRMLTransform*) list[i]->getTail();

			SbVec3f vec = trans->translation.getValue();
			newTrans->translation.setValue(vec);

			SoVRMLTransform* stem = (SoVRMLTransform*) trans->getByName("Stem");
			SbVec3f stem_scale = stem->scale.getValue();

			SoVRMLTransform* crown = (SoVRMLTransform*) trans->getByName("Crown");
			SbVec3f crown_vec = crown->translation.getValue();
			SbVec3f crown_scale = crown->scale.getValue();

			crown_vec[1] += crown_scale[1]*0.5f;

			SoVRMLTransform* crown_pos = new SoVRMLTransform;
			crown_pos->translation.setValue(crown_vec);

			s->reset();
			s->setSearchingAll(true);
			s->setInterest(SoSearchAction::ALL);
			s->setType(SoVRMLIndexedFaceSet::getClassTypeId());
			s->apply(trans);

			SoPathList cgeos = s->getPaths();

			float* l = new float[6];
			SoMFVec3f points;
			float rad = 1.04719755119f;

			for (int a = 0; a < cgeos.getLength(); a++) {
				
				SoVRMLIndexedFaceSet* ifc = (SoVRMLIndexedFaceSet*) ((SoFullPath*)cgeos[a])->getTail();
				SoVRMLCoordinate* coord = (SoVRMLCoordinate*) ifc->coord.getValue();
				l[a] = coord->point[1][0] * crown_scale[0];
				float x = crown_vec[0] + l[a] * sin(rad);
				float z = crown_vec[2] + l[a] * cos(rad);
				points.set1Value(a, x, 0, z);
				rad += 1.04719755119f;
			}

			SoVRMLIndexedFaceSet* new_ifs = new SoVRMLIndexedFaceSet;
			new_ifs->solid = true;
			new_ifs->convex = false;

			SoVRMLColor* crown_color = new SoVRMLColor;
			crown_color->color.setValue(0,0.6f,0);
	

			new_ifs->color = crown_color;
			new_ifs->colorPerVertex = false;

			SoVRMLCoordinate* coord = new SoVRMLCoordinate;
			coord->point = points;
			new_ifs->coord = coord;

			int coord_index[7] = { 0, 1, 2, 3, 4, 5, -1 };

			new_ifs->coordIndex.setValues(0, 7,  coord_index);

			SoVRMLColor* color = new SoVRMLColor;
			color->color.setValue(0.5f,0.5f,0);


			SoVRMLCylinder* new_stem = new SoVRMLCylinder;
			new_stem->radius = 0.5f;
			new_stem->height = stem_scale[1] + crown_vec[1] + 1;
			new_stem->top = true;
			new_stem->bottom = true;

			newTrans->addChild(color);
			newTrans->addChild(new_stem);
			crown_pos->addChild(new_ifs);
			newTrans->addChild(crown_pos);
			_root->addChild(newTrans);	
		}
	}

	
	SoVRMLElevationGrid* ground = sc->getGround();
	_root->addChild(ground);
}

void HeadView::set(const SbRotation& rot, const SbVec3f& pos)
{	









	SbRotation headCam_rot = headCam->orientation.getValue();

	SbMatrix headCam_mat;
	headCam_rot.getValue(headCam_mat);

	SbVec3f vec(0,0,-1);
	rot.multVec(vec, vec);


	

	SbRotation _rot(SbVec3f(0,0,1), vec[2]);
	


	headCam->position.setValue(pos[0], slider->value(), pos[2]);
}

void HeadView::_onSlider(int value)
{
	SbVec3f pos = headCam->position.getValue();
	headCam->position.setValue(pos[0], value, pos[2]);
}


